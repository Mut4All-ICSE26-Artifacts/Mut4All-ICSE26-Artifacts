{"messages": [{"role": "system", "content": "You are an expert in C++ compiler development and AST manipulation"}, {"role": "user", "content": "Based on the provided mutator specification and example mutators for the target language, complete the C++ mutator template to implement the intended transformation. 1. Ensure that the generated code is syntactically valid C++; 2. Correctly implement the mutation logic as described in the specification; 3. Follow the structure of the provided template; 4. Use appropriate C++ APIs for AST manipulation; 5. Includes all necessary imports and dependencies; 6. Analyze the provided mutator suggestion and implement only this specific mutator by completing the provided C++ mutator template; 7. Preserves the template's existing comments and structure; 8. If the suggestion requires new types, variables, or functions, declare them appropriately; 9. Provide only the complete C++ code for the mutator, matching the template's style; 10. Do not wrap the output in Markdown code blocks (e.g., ```C++ or ```). Output only the raw C++ code; 11. Do not implement the mutator based on the examples provided in mutation_content. Instead, focus on designing and implementing complex mutation effects, ideally creating a mutator that maximizes coverage of the seed program's code; 12. Design a unique name that can clearly demonstrate the function of the mutator, replace \"Mutator_\" in the code template, Name words are separated by _, and the first letter of each word is capitalized (for example :Add_Const_Generics),and attach \"_1\",Be sure to specify this name separately on the last line at the end of the output text; Output only the filled-in C++ code, without additional explanations, comments beyond those in the template, or Markdown code blocks. Output only the completed C++ code, without any additional explanations or formatting, ensuring that no comments beyond those in the template or Markdown code blocks are included. Here are the necessary inputs: Mutator Specification: Mutation Operator: Insert Wrapper Method for Static Non-Void Method (No Parameters) Target Code Construct: Class or Struct Definition with Static Non-Void Methods Mutation Rule: Identify a class or struct definition that contains at least one static, non-void, and explicitly declared method. For each such method that takes zero parameters, insert a public wrapper method directly into the class body. The wrapper method should: Have return type void. Be named using a prefix (e.g., mut1_) followed by the original method name, its return type, and a timestamp or unique ID. Call the original static method inside a synthetic parameter list (e.g., (int=foo())). Contain an empty function body. Example: Original Code: class A { public: static int foo() { return 42; } }; Mutated Code: class A { public: static int foo() { return 42; } /*mut1*/ public: void mut1_foo_int_1721449283(int=foo()) {} }; Instructions: The inserted method must be syntactically valid and compilable, but semantically meaningless or misleading (e.g., synthetic parameters that mimic expressions). Wrapper methods do not serve any functional purpose and are intended to introduce potential confusion or IR generation irregularities. Do not mutate implicit methods or those with parameters. Do not insert wrapper methods into incomplete class definitions or lambda types. Ensure the mutation is applied only once per method per class to avoid excessive code bloat. Mutator Template for C++ : //header file #pragma once #include \"Mutator_base.h\" /** * Mutator_ */ class MutatorFrontendAction_{{bugno}} : public MutatorFrontendAction { public: MUTATOR_FRONTEND_ACTION_CREATE_ASTCONSUMER({{bugno}}) private: class MutatorASTConsumer_{{bugno}} : public MutatorASTConsumer { public: MutatorASTConsumer_{{bugno}}(Rewriter &R) : TheRewriter(R) {} void HandleTranslationUnit(ASTContext &Context) override; private: Rewriter &TheRewriter; }; class Callback : public MatchFinder::MatchCallback { public: Callback(Rewriter &Rewrite) : Rewrite(Rewrite) {} virtual void run(const MatchFinder::MatchResult &Result); private: Rewriter &Rewrite; //Necessary node information record used in the mutation process }; }; //source file #include \"../include/Mutator_.h\" // ======================================================================================================== #define MUT{{bugno}}_OUTPUT 1 void MutatorFrontendAction_{{bugno}}::Callback::run(const MatchFinder::MatchResult &Result) { //Check whether the matched AST node is the target node if (auto *MT = Result.Nodes.getNodeAs<clang::{{ASTNodeType}}>({{NodeName}})) { //Filter nodes in header files if (!MT || !Result.Context->getSourceManager().isWrittenInMainFile( MT->getLocation())) return; //Get the source code text of target node //(optional)Record the node information to be used in the mutation process //Perform mutation on the source code text by applying string replacement //Replace the original AST node with the mutated one } } void MutatorFrontendAction_{{bugno}}::MutatorASTConsumer_{{bugno}}::HandleTranslationUnit(ASTContext &Context) { MatchFinder matchFinder; //Define one or more ASTMatchers to identify the target AST node for mutation. DeclarationMatcher matcher = {{MatchRule}}.bind({{NodeName}}); Callback callback(TheRewriter); matchFinder.addMatcher(matcher, &callback); matchFinder.matchAST(Context); }. Human-written C++ mutators: //header file #pragma once #include \"Mutator_base.h\" /** * Insert_Lambda_Expression_1 */ class MutatorFrontendAction_1 : public MutatorFrontendAction { public: MUTATOR_FRONTEND_ACTION_CREATE_ASTCONSUMER(1) private: class MutatorASTConsumer_1 : public MutatorASTConsumer { public: MutatorASTConsumer_1(Rewriter &R) : TheRewriter(R) {} void HandleTranslationUnit(ASTContext &Context) override; private: Rewriter &TheRewriter; }; class Callback : public MatchFinder::MatchCallback { public: Callback(Rewriter &Rewrite) : Rewrite(Rewrite) {} virtual void run(const MatchFinder::MatchResult &Result); private: Rewriter &Rewrite; //Necessary node information record used in the mutation process }; }; //source file #include \"../include/insert_lambda_expression_1.h\" // ======================================================================================================== #define MUT1_OUTPUT 1 void MutatorFrontendAction_1::Callback::run(const MatchFinder::MatchResult &Result) { //Check whether the matched AST node is the target node if (auto *MT = Result.Nodes.getNodeAs<clang::CXXMethodDecl>(\"Methods\")) { //Filter nodes in header files if (!MT || !Result.Context->getSourceManager().isWrittenInMainFile( MT->getLocation())) return; if (MT->hasBody() && !MT->isVirtual()) { //Get the source code text of target node auto declaration = stringutils::rangetoStr(*(Result.SourceManager), MT->getSourceRange()); //Perform mutation on the source code text by applying string replacement declaration.insert(declaration.find(\"{\") + 1, \" /*mut9*/[&](){ \"); declaration.insert(declaration.rfind(\"}\"), \" }(); \"); int choice = getrandom::getRandomIndex(1); //Replace the original AST node with the mutated one if (choice) { Rewrite.ReplaceText(CharSourceRange::getTokenRange(MT->getSourceRange()), declaration); } } } } void MutatorFrontendAction__1::MutatorASTConsumer_1::HandleTranslationUnit(ASTContext &Context) { MatchFinder matchFinder; //Define an ASTMatcher to identify the target AST node for mutation. DeclarationMatcher matcher = cxxMethodDecl(unless(cxxConstructorDecl())).bind(\"Methods\"); Callback callback(TheRewriter); matchFinder.addMatcher(matcher, &callback); matchFinder.matchAST(Context); }."}, {"role": "assistant", "content": "//header file #pragma once #include \"Mutator_base.h\" /** * Insert_Wrapper_Method_For_Static_NonVoid_NoParam_1 */ class MutatorFrontendAction_1 : public MutatorFrontendAction { public: MUTATOR_FRONTEND_ACTION_CREATE_ASTCONSUMER(1) private: class MutatorASTConsumer_1 : public MutatorASTConsumer { public: MutatorASTConsumer_1(Rewriter &R) : TheRewriter(R) {} void HandleTranslationUnit(ASTContext &Context) override; private: Rewriter &TheRewriter; }; class Callback : public MatchFinder::MatchCallback { public: Callback(Rewriter &Rewrite) : Rewrite(Rewrite) {} virtual void run(const MatchFinder::MatchResult &Result); private: Rewriter &Rewrite; }; }; //source file #include \"../include/Insert_Wrapper_Method_For_Static_NonVoid_NoParam_1 // ======================================================================================================== #define MUT1_OUTPUT 1 void MutatorFrontendAction_1::Callback::run(const MatchFinder::MatchResult &Result) { SourceManager &SM = Rewrite.getSourceMgr(); if (const CXXRecordDecl *recordDecl = Result.Nodes.getNodeAs<CXXRecordDecl>(\"hasStaticNonVoidMethod\")) { if (!recordDecl) return; if (!Result.Context->getSourceManager().isWrittenInMainFile(recordDecl->getBeginLoc())) return; if ((!recordDecl->isStruct() && !recordDecl->isClass()) || recordDecl->isLambda()) return; if (!recordDecl->isCompleteDefinition()) return; auto recordName = recordDecl->getNameAsString(); #if MUT1_OUTPUT llvm::errs() << \"MUT1: \" << \"Match record with static non void method: \" << recordName << \" \"; #endif string insText = \"/*mut1*/ public: \"; bool insFlag = false; for (const auto *methodDecl : recordDecl->methods()) { string methodName = methodDecl->getNameAsString(); SourceRange returnTypeRange = methodDecl->getReturnTypeSourceRange(); QualType returnType = methodDecl->getReturnType(); string returnTypeName = stringutils::rangetoStr(SM, returnTypeRange); if (methodDecl->isImplicit()) continue; bool isStatic = methodDecl->isStatic(); bool notReturnsVoid = returnTypeName != \"void\"; assert(isStatic && notReturnsVoid && \"Mut1: should be a static non void method \"); if (methodDecl->getNumParams() > 0) continue; #if MUT1_OUTPUT llvm::errs() << \" \" << \"Static non void method with 0 param: \" << methodName << \" \"; #endif string insMethodType = \"void\"; string insMethodName = \"mut1_\" + methodDecl->getNameAsString() + \"_\" + returnTypeName + \"_\" + stringutils::getTimestamp(); string insMethodParams = \"(\" + returnTypeName + \"=\" + methodName + \"()\" +\")\"; insText += \" \" + insMethodType + \" \" + insMethodName + insMethodParams + \"{} \"; insFlag = true; } if (insFlag) { SourceLocation recordEndLoc = recordDecl->getEndLoc(); Rewrite.InsertText(recordEndLoc, insText, false, true); #if MUT1_OUTPUT llvm::errs() << \" \" << \"insert: \" << insText << \" \"; #endif } } } void MutatorFrontendAction_1::MutatorASTConsumer_1::HandleTranslationUnit(ASTContext &Context) { MatchFinder matchFinder; DeclarationMatcher matcher = cxxRecordDecl(has(cxxMethodDecl( isStaticStorageClass(), unless(returns(asString(\"void\"))) ))).bind(\"hasStaticNonVoidMethod\");; Callback callback(TheRewriter); matchFinder.addMatcher(matcher, &callback); matchFinder.matchAST(Context); }"}]}
{"messages": [{"role": "system", "content": "You are an expert in C++ compiler development and AST manipulation"}, {"role": "user", "content": "Based on the provided mutator specification and example mutators for the target language, complete the C++ mutator template to implement the intended transformation. 1. Ensure that the generated code is syntactically valid C++; 2. Correctly implement the mutation logic as described in the specification; 3. Follow the structure of the provided template; 4. Use appropriate C++ APIs for AST manipulation; 5. Includes all necessary imports and dependencies; 6. Analyze the provided mutator suggestion and implement only this specific mutator by completing the provided C++ mutator template; 7. Preserves the template's existing comments and structure; 8. If the suggestion requires new types, variables, or functions, declare them appropriately; 9. Provide only the complete C++ code for the mutator, matching the template's style; 10. Do not wrap the output in Markdown code blocks (e.g., ```C++ or ```). Output only the raw C++ code; 11. Do not implement the mutator based on the examples provided in mutation_content. Instead, focus on designing and implementing complex mutation effects, ideally creating a mutator that maximizes coverage of the seed program's code; 12. Design a unique name that can clearly demonstrate the function of the mutator, replace \"Mutator_\" in the code template, Name words are separated by _, and the first letter of each word is capitalized (for example :Add_Const_Generics),and attach \"_3\",Be sure to specify this name separately on the last line at the end of the output text; Output only the filled-in C++ code, without additional explanations, comments beyond those in the template, or Markdown code blocks. Output only the completed C++ code, without any additional explanations or formatting, ensuring that no comments beyond those in the template or Markdown code blocks are included. Here are the necessary inputs: Mutator Specification: Mutation Operator: Insert Random Friend Class Declaration Target Code Construct: Class or Struct Definition Mutation Rule: Traverse all complete class or struct definitions in the main source file. Maintain a list of all such class declarations encountered so far. When visiting a new class C, randomly select a previously encountered class P from the list. Inject a friend declaration friend class P; into class C to grant friendship to class P. Prefix the inserted code with a comment (e.g., /*mut2*/) for tracking. Ensure each class is only visited and mutated once (based on class name). Example: Original Code: class A { public: void foo(); }; class B { public: void bar(); }; Mutated Code: class A { public: void foo(); }; class B { public: void bar(); /*mut2*/ friend class A; }; Instructions: The inserted friend class declaration must refer to an actual previously declared class in the same translation unit. Skip lambda types and incomplete class definitions. Avoid injecting duplicate friend declarations into the same class. Ensure that injected declarations are syntactically valid and appear in proper locations (e.g., before class closing brace).. Mutator Template for C++ : //header file #pragma once #include \"Mutator_base.h\" /** * Mutator_ */ class MutatorFrontendAction_{{bugno}} : public MutatorFrontendAction { public: MUTATOR_FRONTEND_ACTION_CREATE_ASTCONSUMER({{bugno}}) private: class MutatorASTConsumer_{{bugno}} : public MutatorASTConsumer { public: MutatorASTConsumer_{{bugno}}(Rewriter &R) : TheRewriter(R) {} void HandleTranslationUnit(ASTContext &Context) override; private: Rewriter &TheRewriter; }; class Callback : public MatchFinder::MatchCallback { public: Callback(Rewriter &Rewrite) : Rewrite(Rewrite) {} virtual void run(const MatchFinder::MatchResult &Result); private: Rewriter &Rewrite; //Necessary node information record used in the mutation process }; }; //source file #include \"../include/Mutator_.h\" // ======================================================================================================== #define MUT{{bugno}}_OUTPUT 1 void MutatorFrontendAction_{{bugno}}::Callback::run(const MatchFinder::MatchResult &Result) { //Check whether the matched AST node is the target node if (auto *MT = Result.Nodes.getNodeAs<clang::{{ASTNodeType}}>({{NodeName}})) { //Filter nodes in header files if (!MT || !Result.Context->getSourceManager().isWrittenInMainFile( MT->getLocation())) return; //Get the source code text of target node //(optional)Record the node information to be used in the mutation process //Perform mutation on the source code text by applying string replacement //Replace the original AST node with the mutated one } } void MutatorFrontendAction_{{bugno}}::MutatorASTConsumer_{{bugno}}::HandleTranslationUnit(ASTContext &Context) { MatchFinder matchFinder; //Define one or more ASTMatchers to identify the target AST node for mutation. DeclarationMatcher matcher = {{MatchRule}}.bind({{NodeName}}); Callback callback(TheRewriter); matchFinder.addMatcher(matcher, &callback); matchFinder.matchAST(Context); }. Human-written C++ mutators: //header file #pragma once #include \"Mutator_base.h\" /** * Insert_Lambda_Expression_1 */ class MutatorFrontendAction_1 : public MutatorFrontendAction { public: MUTATOR_FRONTEND_ACTION_CREATE_ASTCONSUMER(1) private: class MutatorASTConsumer_1 : public MutatorASTConsumer { public: MutatorASTConsumer_1(Rewriter &R) : TheRewriter(R) {} void HandleTranslationUnit(ASTContext &Context) override; private: Rewriter &TheRewriter; }; class Callback : public MatchFinder::MatchCallback { public: Callback(Rewriter &Rewrite) : Rewrite(Rewrite) {} virtual void run(const MatchFinder::MatchResult &Result); private: Rewriter &Rewrite; //Necessary node information record used in the mutation process }; }; //source file #include \"../include/insert_lambda_expression_1.h\" // ======================================================================================================== #define MUT1_OUTPUT 1 void MutatorFrontendAction_1::Callback::run(const MatchFinder::MatchResult &Result) { //Check whether the matched AST node is the target node if (auto *MT = Result.Nodes.getNodeAs<clang::CXXMethodDecl>(\"Methods\")) { //Filter nodes in header files if (!MT || !Result.Context->getSourceManager().isWrittenInMainFile( MT->getLocation())) return; if (MT->hasBody() && !MT->isVirtual()) { //Get the source code text of target node auto declaration = stringutils::rangetoStr(*(Result.SourceManager), MT->getSourceRange()); //Perform mutation on the source code text by applying string replacement declaration.insert(declaration.find(\"{\") + 1, \" /*mut9*/[&](){ \"); declaration.insert(declaration.rfind(\"}\"), \" }(); \"); int choice = getrandom::getRandomIndex(1); //Replace the original AST node with the mutated one if (choice) { Rewrite.ReplaceText(CharSourceRange::getTokenRange(MT->getSourceRange()), declaration); } } } } void MutatorFrontendAction__1::MutatorASTConsumer_1::HandleTranslationUnit(ASTContext &Context) { MatchFinder matchFinder; //Define an ASTMatcher to identify the target AST node for mutation. DeclarationMatcher matcher = cxxMethodDecl(unless(cxxConstructorDecl())).bind(\"Methods\"); Callback callback(TheRewriter); matchFinder.addMatcher(matcher, &callback); matchFinder.matchAST(Context); }."}, {"role": "assistant", "content": "//header file #pragma once #include \"Mutator_base.h\" /** * Insert_Random_Friend_Declaration_In_Class_2 */ class MutatorFrontendAction_2 : public MutatorFrontendAction { public: MUTATOR_FRONTEND_ACTION_CREATE_ASTCONSUMER(2) private: class MutatorASTConsumer_2 : public MutatorASTConsumer { public: MutatorASTConsumer_2(Rewriter &R) : TheRewriter(R) {} void HandleTranslationUnit(ASTContext &Context) override; private: Rewriter &TheRewriter; }; class Callback : public MatchFinder::MatchCallback { public: Callback(Rewriter &Rewrite) : Rewrite(Rewrite) {} virtual void run(const MatchFinder::MatchResult &Result); private: Rewriter &Rewrite; std::vector<const clang::CXXRecordDecl *> cur_classes; std::set<string> cur_classnames; }; }; //source file #include \"../include/Insert_Random_Friend_Declaration_In_Class_2.h\" // ======================================================================================================== #define MUT2_OUTPUT 1 void MutatorFrontendAction_2::Callback::run(const MatchFinder::MatchResult &Result) { if (auto *DL = Result.Nodes.getNodeAs<clang::CXXRecordDecl>(\"Classes\")) { if (!DL || !Result.Context->getSourceManager().isWrittenInMainFile( DL->getLocation())) return; // DL->dump(); if (cur_classnames.count(DL->getNameAsString())) return; if ((!DL->isStruct() && !DL->isClass()) || DL->isLambda()) return; if (DL->isCompleteDefinition()) { if (!cur_classes.empty()) { // llvm::outs()<<DL->getNameAsString()<<' '; auto index = getrandom::getRandomIndex(cur_classes.size() - 2); // llvm::outs()<<index<<' '; auto target_class = cur_classes[index]; // target_class->dump(); string friend_dec = \"friend class \" + target_class->getNameAsString() + \";\"; friend_dec = \"/*mut2*/ \" + friend_dec; Rewrite.ReplaceText(DL->getEndLoc(), 0, friend_dec); } } cur_classes.push_back(DL); cur_classnames.insert(DL->getNameAsString()); } } void MutatorFrontendAction_2::MutatorASTConsumer_2::HandleTranslationUnit(ASTContext &Context) { MatchFinder matchFinder; DeclarationMatcher matcher = cxxRecordDecl().bind(\"Classes\"); Callback callback(TheRewriter); matchFinder.addMatcher(matcher, &callback); matchFinder.matchAST(Context); }"}]}
{"messages": [{"role": "system", "content": "You are an expert in C++ compiler development and AST manipulation"}, {"role": "user", "content": "Based on the provided mutator specification and example mutators for the target language, complete the C++ mutator template to implement the intended transformation. 1. Ensure that the generated code is syntactically valid C++; 2. Correctly implement the mutation logic as described in the specification; 3. Follow the structure of the provided template; 4. Use appropriate C++ APIs for AST manipulation; 5. Includes all necessary imports and dependencies; 6. Analyze the provided mutator suggestion and implement only this specific mutator by completing the provided C++ mutator template; 7. Preserves the template's existing comments and structure; 8. If the suggestion requires new types, variables, or functions, declare them appropriately; 9. Provide only the complete C++ code for the mutator, matching the template's style; 10. Do not wrap the output in Markdown code blocks (e.g., ```C++ or ```). Output only the raw C++ code; 11. Do not implement the mutator based on the examples provided in mutation_content. Instead, focus on designing and implementing complex mutation effects, ideally creating a mutator that maximizes coverage of the seed program's code; 12. Design a unique name that can clearly demonstrate the function of the mutator, replace \"Mutator_\" in the code template, Name words are separated by _, and the first letter of each word is capitalized (for example :Add_Const_Generics),and attach \"_4\",Be sure to specify this name separately on the last line at the end of the output text; Output only the filled-in C++ code, without additional explanations, comments beyond those in the template, or Markdown code blocks. Output only the completed C++ code, without any additional explanations or formatting, ensuring that no comments beyond those in the template or Markdown code blocks are included. Here are the necessary inputs: Mutator Specification: Mutation Operator: Wrap Non-Virtual Method Body in Immediately-Invoked Lambda Target Code Construct: Non-Virtual Method Definition (excluding constructors) Mutation Rule: 1. Identify all method definitions in the main source file that: * Are **not constructors**. * Are **not virtual**. * Have a defined **function body**. 2. Wrap the contents of the method body in a lambda expression: * Use a capture list of `[&]`. * Immediately invoke the lambda (`();`). * Insert this transformation directly inside the original function braces. 3. Prefix the inserted code with a comment such as `/*mut3*/` to aid in debugging or tracking. Example: Original Code: ``` int foo() { return 42; } ``` Mutated Code: ``` int foo() { /*mut3*/[&](){ return 42; }(); } ``` Instructions: * Do **not** mutate constructors or virtual functions. * Ensure the insertion is inside the method body, preserving the original logic semantics. * The mutation is semantically valid but structurally redundant and may affect compiler optimization or trigger subtle backend bugs. * Randomize whether or not to apply the mutation per method to simulate variability during fuzzing. . Mutator Template for C++ : //header file #pragma once #include \"Mutator_base.h\" /** * Mutator_ */ class MutatorFrontendAction_{{bugno}} : public MutatorFrontendAction { public: MUTATOR_FRONTEND_ACTION_CREATE_ASTCONSUMER({{bugno}}) private: class MutatorASTConsumer_{{bugno}} : public MutatorASTConsumer { public: MutatorASTConsumer_{{bugno}}(Rewriter &R) : TheRewriter(R) {} void HandleTranslationUnit(ASTContext &Context) override; private: Rewriter &TheRewriter; }; class Callback : public MatchFinder::MatchCallback { public: Callback(Rewriter &Rewrite) : Rewrite(Rewrite) {} virtual void run(const MatchFinder::MatchResult &Result); private: Rewriter &Rewrite; //Necessary node information record used in the mutation process }; }; //source file #include \"../include/Mutator_.h\" // ======================================================================================================== #define MUT{{bugno}}_OUTPUT 1 void MutatorFrontendAction_{{bugno}}::Callback::run(const MatchFinder::MatchResult &Result) { //Check whether the matched AST node is the target node if (auto *MT = Result.Nodes.getNodeAs<clang::{{ASTNodeType}}>({{NodeName}})) { //Filter nodes in header files if (!MT || !Result.Context->getSourceManager().isWrittenInMainFile( MT->getLocation())) return; //Get the source code text of target node //(optional)Record the node information to be used in the mutation process //Perform mutation on the source code text by applying string replacement //Replace the original AST node with the mutated one } } void MutatorFrontendAction_{{bugno}}::MutatorASTConsumer_{{bugno}}::HandleTranslationUnit(ASTContext &Context) { MatchFinder matchFinder; //Define one or more ASTMatchers to identify the target AST node for mutation. DeclarationMatcher matcher = {{MatchRule}}.bind({{NodeName}}); Callback callback(TheRewriter); matchFinder.addMatcher(matcher, &callback); matchFinder.matchAST(Context); }. Human-written C++ mutators: //header file #pragma once #include \"Mutator_base.h\" /** * Insert_Lambda_Expression_1 */ class MutatorFrontendAction_1 : public MutatorFrontendAction { public: MUTATOR_FRONTEND_ACTION_CREATE_ASTCONSUMER(1) private: class MutatorASTConsumer_1 : public MutatorASTConsumer { public: MutatorASTConsumer_1(Rewriter &R) : TheRewriter(R) {} void HandleTranslationUnit(ASTContext &Context) override; private: Rewriter &TheRewriter; }; class Callback : public MatchFinder::MatchCallback { public: Callback(Rewriter &Rewrite) : Rewrite(Rewrite) {} virtual void run(const MatchFinder::MatchResult &Result); private: Rewriter &Rewrite; //Necessary node information record used in the mutation process }; }; //source file #include \"../include/insert_lambda_expression_1.h\" // ======================================================================================================== #define MUT1_OUTPUT 1 void MutatorFrontendAction_1::Callback::run(const MatchFinder::MatchResult &Result) { //Check whether the matched AST node is the target node if (auto *MT = Result.Nodes.getNodeAs<clang::CXXMethodDecl>(\"Methods\")) { //Filter nodes in header files if (!MT || !Result.Context->getSourceManager().isWrittenInMainFile( MT->getLocation())) return; if (MT->hasBody() && !MT->isVirtual()) { //Get the source code text of target node auto declaration = stringutils::rangetoStr(*(Result.SourceManager), MT->getSourceRange()); //Perform mutation on the source code text by applying string replacement declaration.insert(declaration.find(\"{\") + 1, \" /*mut9*/[&](){ \"); declaration.insert(declaration.rfind(\"}\"), \" }(); \"); int choice = getrandom::getRandomIndex(1); //Replace the original AST node with the mutated one if (choice) { Rewrite.ReplaceText(CharSourceRange::getTokenRange(MT->getSourceRange()), declaration); } } } } void MutatorFrontendAction__1::MutatorASTConsumer_1::HandleTranslationUnit(ASTContext &Context) { MatchFinder matchFinder; //Define an ASTMatcher to identify the target AST node for mutation. DeclarationMatcher matcher = cxxMethodDecl(unless(cxxConstructorDecl())).bind(\"Methods\"); Callback callback(TheRewriter); matchFinder.addMatcher(matcher, &callback); matchFinder.matchAST(Context); }."}, {"role": "assistant", "content": "//header file #pragma once #include \"Mutator_base.h\" /** * Wrap_Method_Body_In_IIFE_Lambda_3 */ class MutatorFrontendAction_3 : public MutatorFrontendAction { public: MUTATOR_FRONTEND_ACTION_CREATE_ASTCONSUMER(3) private: class MutatorASTConsumer_3 : public MutatorASTConsumer { public: MutatorASTConsumer_3(Rewriter &R) : TheRewriter(R) {} void HandleTranslationUnit(ASTContext &Context) override; private: Rewriter &TheRewriter; }; class Callback : public MatchFinder::MatchCallback { public: Callback(Rewriter &Rewrite) : Rewrite(Rewrite) {} virtual void run(const MatchFinder::MatchResult &Result); private: Rewriter &Rewrite; }; }; //source file #include \"../include/Wrap_Method_Body_In_IIFE_Lambda_3.h\" // ======================================================================================================== #define MUT3_OUTPUT 1 void MutatorFrontendAction_3::Callback::run(const MatchFinder::MatchResult &Result) { if (auto *MT = Result.Nodes.getNodeAs<clang::CXXMethodDecl>(\"Methods\")) { if (!MT || !Result.Context->getSourceManager().isWrittenInMainFile( MT->getLocation())) return; // DL->dump(); if (MT->hasBody() && !MT->isVirtual()) { auto declaration = stringutils::rangetoStr(*(Result.SourceManager), MT->getSourceRange()); // llvm::outs()<<declaration<<' '; declaration.insert(declaration.find(\"{\") + 1, \" /*mut3*/[&](){ \"); declaration.insert(declaration.rfind(\"}\"), \" }(); \"); int choice = getrandom::getRandomIndex(1); llvm::outs() << choice << ' '; if (choice) { Rewrite.ReplaceText(CharSourceRange::getTokenRange(MT->getSourceRange()), declaration); } } } } void MutatorFrontendAction_3::MutatorASTConsumer_3::HandleTranslationUnit(ASTContext &Context) { MatchFinder matchFinder; DeclarationMatcher matcher = cxxMethodDecl(unless(cxxConstructorDecl())).bind(\"Methods\"); Callback callback(TheRewriter); matchFinder.addMatcher(matcher, &callback); matchFinder.matchAST(Context); }"}]}
{"messages": [{"role": "system", "content": "You are an expert in C++ compiler development and AST manipulation"}, {"role": "user", "content": "Based on the provided mutator specification and example mutators for the target language, complete the C++ mutator template to implement the intended transformation. 1. Ensure that the generated code is syntactically valid C++; 2. Correctly implement the mutation logic as described in the specification; 3. Follow the structure of the provided template; 4. Use appropriate C++ APIs for AST manipulation; 5. Includes all necessary imports and dependencies; 6. Analyze the provided mutator suggestion and implement only this specific mutator by completing the provided C++ mutator template; 7. Preserves the template's existing comments and structure; 8. If the suggestion requires new types, variables, or functions, declare them appropriately; 9. Provide only the complete C++ code for the mutator, matching the template's style; 10. Do not wrap the output in Markdown code blocks (e.g., ```C++ or ```). Output only the raw C++ code; 11. Do not implement the mutator based on the examples provided in mutation_content. Instead, focus on designing and implementing complex mutation effects, ideally creating a mutator that maximizes coverage of the seed program's code; 12. Design a unique name that can clearly demonstrate the function of the mutator, replace \"Mutator_\" in the code template, Name words are separated by _, and the first letter of each word is capitalized (for example :Add_Const_Generics),and attach \"_5\",Be sure to specify this name separately on the last line at the end of the output text; Output only the filled-in C++ code, without additional explanations, comments beyond those in the template, or Markdown code blocks. Output only the completed C++ code, without any additional explanations or formatting, ensuring that no comments beyond those in the template or Markdown code blocks are included. Here are the necessary inputs: Mutator Specification: Mutation Operator: Inject Useless Enum and Using-Enum Directive into Class Target Code Construct: Class or Struct Definition, Enum Declaration, and Template Class Declaration Mutation Rule: 1. Identify the first complete class or template class definition in the main source file. 2. Inject a dummy scoped enum declaration (e.g., `enum class mut_4 { };`) at the beginning of this class/template. 3. Collect all enum names declared in the translation unit. 4. For each subsequent complete class definition: * If it does **not** already contain a `using enum` directive, insert a statement of the form `using enum <enum_name>;` at the end of the class body. * Randomly choose one of the collected enums for injection. * Prefix the inserted directive with a comment like `/*mut4*/` for traceability. Example: Original Code: ``` class A { public: void foo(); }; enum Color { RED, GREEN, BLUE }; class B { public: void bar(); }; ``` Mutated Code: ``` enum class mut_4 { }; class A { public: void foo(); }; enum Color { RED, GREEN, BLUE }; class B { public: void bar(); /*mut4*/using enum mut_4; }; ``` Instructions: * Ensure `enum class mut_4` is inserted only **once**, at the beginning of the first matched class or template. * Use `using enum` only with valid, visible enum names. * Avoid injecting into classes that already use a `using enum` directive. * The mutation should be syntactically valid but semantically irrelevant, intended to stress test enum scoping and name resolution mechanisms in the compiler. . Mutator Template for C++ : //header file #pragma once #include \"Mutator_base.h\" /** * Mutator_ */ class MutatorFrontendAction_{{bugno}} : public MutatorFrontendAction { public: MUTATOR_FRONTEND_ACTION_CREATE_ASTCONSUMER({{bugno}}) private: class MutatorASTConsumer_{{bugno}} : public MutatorASTConsumer { public: MutatorASTConsumer_{{bugno}}(Rewriter &R) : TheRewriter(R) {} void HandleTranslationUnit(ASTContext &Context) override; private: Rewriter &TheRewriter; }; class Callback : public MatchFinder::MatchCallback { public: Callback(Rewriter &Rewrite) : Rewrite(Rewrite) {} virtual void run(const MatchFinder::MatchResult &Result); private: Rewriter &Rewrite; //Necessary node information record used in the mutation process }; }; //source file #include \"../include/Mutator_.h\" // ======================================================================================================== #define MUT{{bugno}}_OUTPUT 1 void MutatorFrontendAction_{{bugno}}::Callback::run(const MatchFinder::MatchResult &Result) { //Check whether the matched AST node is the target node if (auto *MT = Result.Nodes.getNodeAs<clang::{{ASTNodeType}}>({{NodeName}})) { //Filter nodes in header files if (!MT || !Result.Context->getSourceManager().isWrittenInMainFile( MT->getLocation())) return; //Get the source code text of target node //(optional)Record the node information to be used in the mutation process //Perform mutation on the source code text by applying string replacement //Replace the original AST node with the mutated one } } void MutatorFrontendAction_{{bugno}}::MutatorASTConsumer_{{bugno}}::HandleTranslationUnit(ASTContext &Context) { MatchFinder matchFinder; //Define one or more ASTMatchers to identify the target AST node for mutation. DeclarationMatcher matcher = {{MatchRule}}.bind({{NodeName}}); Callback callback(TheRewriter); matchFinder.addMatcher(matcher, &callback); matchFinder.matchAST(Context); }. Human-written C++ mutators: //header file #pragma once #include \"Mutator_base.h\" /** * Insert_Lambda_Expression_1 */ class MutatorFrontendAction_1 : public MutatorFrontendAction { public: MUTATOR_FRONTEND_ACTION_CREATE_ASTCONSUMER(1) private: class MutatorASTConsumer_1 : public MutatorASTConsumer { public: MutatorASTConsumer_1(Rewriter &R) : TheRewriter(R) {} void HandleTranslationUnit(ASTContext &Context) override; private: Rewriter &TheRewriter; }; class Callback : public MatchFinder::MatchCallback { public: Callback(Rewriter &Rewrite) : Rewrite(Rewrite) {} virtual void run(const MatchFinder::MatchResult &Result); private: Rewriter &Rewrite; //Necessary node information record used in the mutation process }; }; //source file #include \"../include/insert_lambda_expression_1.h\" // ======================================================================================================== #define MUT1_OUTPUT 1 void MutatorFrontendAction_1::Callback::run(const MatchFinder::MatchResult &Result) { //Check whether the matched AST node is the target node if (auto *MT = Result.Nodes.getNodeAs<clang::CXXMethodDecl>(\"Methods\")) { //Filter nodes in header files if (!MT || !Result.Context->getSourceManager().isWrittenInMainFile( MT->getLocation())) return; if (MT->hasBody() && !MT->isVirtual()) { //Get the source code text of target node auto declaration = stringutils::rangetoStr(*(Result.SourceManager), MT->getSourceRange()); //Perform mutation on the source code text by applying string replacement declaration.insert(declaration.find(\"{\") + 1, \" /*mut9*/[&](){ \"); declaration.insert(declaration.rfind(\"}\"), \" }(); \"); int choice = getrandom::getRandomIndex(1); //Replace the original AST node with the mutated one if (choice) { Rewrite.ReplaceText(CharSourceRange::getTokenRange(MT->getSourceRange()), declaration); } } } } void MutatorFrontendAction__1::MutatorASTConsumer_1::HandleTranslationUnit(ASTContext &Context) { MatchFinder matchFinder; //Define an ASTMatcher to identify the target AST node for mutation. DeclarationMatcher matcher = cxxMethodDecl(unless(cxxConstructorDecl())).bind(\"Methods\"); Callback callback(TheRewriter); matchFinder.addMatcher(matcher, &callback); matchFinder.matchAST(Context); }."}, {"role": "assistant", "content": "//header file #pragma once #include \"Mutator_base.h\" /** * Inject_Enum_And_UsingEnum_Into_Class_4 */ class MutatorFrontendAction_4 : public MutatorFrontendAction { public: MUTATOR_FRONTEND_ACTION_CREATE_ASTCONSUMER(4) private: class MutatorASTConsumer_4 : public MutatorASTConsumer { public: MutatorASTConsumer_4(Rewriter &R) : TheRewriter(R) {} void HandleTranslationUnit(ASTContext &Context) override; private: Rewriter &TheRewriter; }; class Callback : public MatchFinder::MatchCallback { public: Callback(Rewriter &Rewrite) : Rewrite(Rewrite) {} virtual void run(const MatchFinder::MatchResult &Result); private: Rewriter &Rewrite; std::vector<std::string> enumerate_set; std::set <std::string> classnames; int first=0; }; }; //source file #include \"../include/Inject_Enum_And_UsingEnum_Into_Class_4.h\" // ======================================================================================================== #define MUT4_OUTPUT 1 void MutatorFrontendAction_4::Callback::run(const MatchFinder::MatchResult &Result) { if (auto *DL = Result.Nodes.getNodeAs<clang::CXXRecordDecl>(\"Classes\")) { if (!DL || !Result.Context->getSourceManager().isWrittenInMainFile( DL->getLocation())) return; // DL->dump(); if ((!DL->isStruct() && !DL->isClass()) || DL->isLambda()) return; if (classnames.count(DL->getNameAsString())) return; classnames.insert(DL->getNameAsString()); if (DL->isCompleteDefinition()) { if (first == 0) { Rewrite.ReplaceText(DL->getInnerLocStart(), 0, \"enum class mut_4{ }; \"); enumerate_set.push_back(\"mut_4\"); first = first + 1; } auto content = stringutils::rangetoStr(*(Result.SourceManager), DL->getSourceRange()); if (content.find(\"using enum\") == string::npos) { int judge = getrandom::getRandomIndex(enumerate_set.size() - 1); llvm::outs() << enumerate_set[judge] << ' '; Rewrite.ReplaceText(DL->getEndLoc(), 0, \"/*mut4*/using enum \" + enumerate_set[judge] + \" ; \"); } } } else if (auto *EN = Result.Nodes.getNodeAs<clang::EnumDecl>(\"Enums\")) { if (!EN || !Result.Context->getSourceManager().isWrittenInMainFile( EN->getLocation())) return; // DL->dump(); enumerate_set.push_back(EN->getNameAsString()); } else if (auto *TP = Result.Nodes.getNodeAs<clang::ClassTemplateDecl>( \"Templated\")) { if (!TP || !Result.Context->getSourceManager().isWrittenInMainFile( TP->getLocation())) return; if (first == 0) { llvm::outs() << TP->getNameAsString() << ' '; classnames.insert(TP->getNameAsString()); first = 1; Rewrite.ReplaceText(TP->getBeginLoc(), 0, \"enum class mut_4{ }; \"); } } } void MutatorFrontendAction_4::MutatorASTConsumer_4::HandleTranslationUnit(ASTContext &Context) { MatchFinder matchFinder; auto class_matcher = cxxRecordDecl().bind(\"Classes\"); auto enum_matcher = enumDecl().bind(\"Enums\"); auto template_matcher = classTemplateDecl().bind(\"Templated\"); Callback callback(TheRewriter); matchFinder.addMatcher(class_matcher, &callback); matchFinder.addMatcher(enum_matcher, &callback); matchFinder.addMatcher(template_matcher, &callback); matchFinder.matchAST(Context); }"}]}
{"messages": [{"role": "system", "content": "You are an expert in C++ compiler development and AST manipulation"}, {"role": "user", "content": "Based on the provided mutator specification and example mutators for the target language, complete the C++ mutator template to implement the intended transformation. 1. Ensure that the generated code is syntactically valid C++; 2. Correctly implement the mutation logic as described in the specification; 3. Follow the structure of the provided template; 4. Use appropriate C++ APIs for AST manipulation; 5. Includes all necessary imports and dependencies; 6. Analyze the provided mutator suggestion and implement only this specific mutator by completing the provided C++ mutator template; 7. Preserves the template's existing comments and structure; 8. If the suggestion requires new types, variables, or functions, declare them appropriately; 9. Provide only the complete C++ code for the mutator, matching the template's style; 10. Do not wrap the output in Markdown code blocks (e.g., ```C++ or ```). Output only the raw C++ code; 11. Do not implement the mutator based on the examples provided in mutation_content. Instead, focus on designing and implementing complex mutation effects, ideally creating a mutator that maximizes coverage of the seed program's code; 12. Design a unique name that can clearly demonstrate the function of the mutator, replace \"Mutator_\" in the code template, Name words are separated by _, and the first letter of each word is capitalized (for example :Add_Const_Generics),and attach \"_6\",Be sure to specify this name separately on the last line at the end of the output text; Output only the filled-in C++ code, without additional explanations, comments beyond those in the template, or Markdown code blocks. Output only the completed C++ code, without any additional explanations or formatting, ensuring that no comments beyond those in the template or Markdown code blocks are included. Here are the necessary inputs: Mutator Specification: Mutation Operator: Replace Dot-Based Member Call with Pointer-to-Member Expression Target Code Construct: Member Function Call Expression Mutation Rule: 1. Match dot-based member function calls (`obj.foo()`), excluding arrow calls (`obj->foo()`). 2. Extract the variable declaration of the instance `obj`, and determine the class type it belongs to. 3. For each unique instance declaration: * Insert a new pointer-to-member variable with the form `auto mut5_obj_foo_ptr = ClassType::foo;`, directly after the original variable declaration. * Track the inserted variable using a map to avoid duplicate insertion. 4. Replace the original member function call (`obj.foo()`) with a call through pointer-to-member: * `obj.foo()` → `(obj.*mut5_obj_foo_ptr)()` * Prefix with comment `/*mut5*/` to denote transformation. 5. Perform this replacement consistently for all matching member calls that originate from the same variable instance. Example: Original Code: ``` class A { public: void bar() {} }; void func() { A obj; obj.bar(); } ``` Mutated Code: ``` class A { public: void bar() {} }; void func() { A obj; /*mut5*/auto mut5_obj_bar_ptr = A::bar; /*mut5*/(obj.*mut5_obj_bar_ptr)(); } ``` Instructions: * Only apply this transformation if the class type is known and fully declared (i.e., a valid `CXXRecordDecl`). * Skip arrow (`->`) member calls or cases where the base is not a simple variable reference. * Ensure inserted pointer-to-member declarations do not conflict with existing names. * Maintain semantic equivalence while changing call style to stress the compiler's handling of member pointer indirection. . Mutator Template for C++ : //header file #pragma once #include \"Mutator_base.h\" /** * Mutator_ */ class MutatorFrontendAction_{{bugno}} : public MutatorFrontendAction { public: MUTATOR_FRONTEND_ACTION_CREATE_ASTCONSUMER({{bugno}}) private: class MutatorASTConsumer_{{bugno}} : public MutatorASTConsumer { public: MutatorASTConsumer_{{bugno}}(Rewriter &R) : TheRewriter(R) {} void HandleTranslationUnit(ASTContext &Context) override; private: Rewriter &TheRewriter; }; class Callback : public MatchFinder::MatchCallback { public: Callback(Rewriter &Rewrite) : Rewrite(Rewrite) {} virtual void run(const MatchFinder::MatchResult &Result); private: Rewriter &Rewrite; //Necessary node information record used in the mutation process }; }; //source file #include \"../include/Mutator_.h\" // ======================================================================================================== #define MUT{{bugno}}_OUTPUT 1 void MutatorFrontendAction_{{bugno}}::Callback::run(const MatchFinder::MatchResult &Result) { //Check whether the matched AST node is the target node if (auto *MT = Result.Nodes.getNodeAs<clang::{{ASTNodeType}}>({{NodeName}})) { //Filter nodes in header files if (!MT || !Result.Context->getSourceManager().isWrittenInMainFile( MT->getLocation())) return; //Get the source code text of target node //(optional)Record the node information to be used in the mutation process //Perform mutation on the source code text by applying string replacement //Replace the original AST node with the mutated one } } void MutatorFrontendAction_{{bugno}}::MutatorASTConsumer_{{bugno}}::HandleTranslationUnit(ASTContext &Context) { MatchFinder matchFinder; //Define one or more ASTMatchers to identify the target AST node for mutation. DeclarationMatcher matcher = {{MatchRule}}.bind({{NodeName}}); Callback callback(TheRewriter); matchFinder.addMatcher(matcher, &callback); matchFinder.matchAST(Context); }. Human-written C++ mutators: //header file #pragma once #include \"Mutator_base.h\" /** * Insert_Lambda_Expression_1 */ class MutatorFrontendAction_1 : public MutatorFrontendAction { public: MUTATOR_FRONTEND_ACTION_CREATE_ASTCONSUMER(1) private: class MutatorASTConsumer_1 : public MutatorASTConsumer { public: MutatorASTConsumer_1(Rewriter &R) : TheRewriter(R) {} void HandleTranslationUnit(ASTContext &Context) override; private: Rewriter &TheRewriter; }; class Callback : public MatchFinder::MatchCallback { public: Callback(Rewriter &Rewrite) : Rewrite(Rewrite) {} virtual void run(const MatchFinder::MatchResult &Result); private: Rewriter &Rewrite; //Necessary node information record used in the mutation process }; }; //source file #include \"../include/insert_lambda_expression_1.h\" // ======================================================================================================== #define MUT1_OUTPUT 1 void MutatorFrontendAction_1::Callback::run(const MatchFinder::MatchResult &Result) { //Check whether the matched AST node is the target node if (auto *MT = Result.Nodes.getNodeAs<clang::CXXMethodDecl>(\"Methods\")) { //Filter nodes in header files if (!MT || !Result.Context->getSourceManager().isWrittenInMainFile( MT->getLocation())) return; if (MT->hasBody() && !MT->isVirtual()) { //Get the source code text of target node auto declaration = stringutils::rangetoStr(*(Result.SourceManager), MT->getSourceRange()); //Perform mutation on the source code text by applying string replacement declaration.insert(declaration.find(\"{\") + 1, \" /*mut9*/[&](){ \"); declaration.insert(declaration.rfind(\"}\"), \" }(); \"); int choice = getrandom::getRandomIndex(1); //Replace the original AST node with the mutated one if (choice) { Rewrite.ReplaceText(CharSourceRange::getTokenRange(MT->getSourceRange()), declaration); } } } } void MutatorFrontendAction__1::MutatorASTConsumer_1::HandleTranslationUnit(ASTContext &Context) { MatchFinder matchFinder; //Define an ASTMatcher to identify the target AST node for mutation. DeclarationMatcher matcher = cxxMethodDecl(unless(cxxConstructorDecl())).bind(\"Methods\"); Callback callback(TheRewriter); matchFinder.addMatcher(matcher, &callback); matchFinder.matchAST(Context); }."}, {"role": "assistant", "content": "//header file #pragma once #include \"Mutator_base.h\" /** * Replace_Member_Call_With_PointerToMember_5 */ class MutatorFrontendAction_5 : public MutatorFrontendAction { public: MUTATOR_FRONTEND_ACTION_CREATE_ASTCONSUMER(5) private: class MutatorASTConsumer_5 : public MutatorASTConsumer { public: MutatorASTConsumer_5(Rewriter &R) : TheRewriter(R) {} void HandleTranslationUnit(ASTContext &Context) override; private: Rewriter &TheRewriter; }; class Callback : public MatchFinder::MatchCallback { public: Callback(Rewriter &Rewrite) : Rewrite(Rewrite) {} virtual void run(const MatchFinder::MatchResult &Result); private: Rewriter &Rewrite; std::map<std::string, std::string> instrumentedDeclMap; }; }; //source file #include \"../include/Replace_Member_Call_With_PointerToMember_5.h\" // ======================================================================================================== #define MUT5_OUTPUT 1 void MutatorFrontendAction_5::Callback::run(const MatchFinder::MatchResult &Result) { if (auto *MC = Result.Nodes.getNodeAs<clang::CXXMemberCallExpr>(\"memberCall\")) { if (!MC || !Result.Context->getSourceManager().isWrittenInMainFile( MC->getBeginLoc())) return; if (const MemberExpr *Member = dyn_cast<MemberExpr>(MC->getCallee())) { // member call if (Member->isArrow()) return; std::string memberName = Member->getMemberDecl()->getNameAsString(); if (const DeclRefExpr *Object = dyn_cast<DeclRefExpr>(Member->getBase()->IgnoreImpCasts())) { if (const VarDecl *Var = dyn_cast<VarDecl>(Object->getDecl())) { std::string instanceName = Var->getNameAsString(); std::string varDecl = stringutils::rangetoStr(*(Result.SourceManager), Var->getSourceRange()); auto varTypeLoc = Var->getTypeSourceInfo()->getTypeLoc(); auto varType = stringutils::rangetoStr(*(Result.SourceManager), varTypeLoc.getSourceRange()); if (const CXXRecordDecl *RecordDecl = Var->getType()->getAsCXXRecordDecl()) { std::string recordName = RecordDecl->getNameAsString(); if (instrumentedDeclMap.find(varDecl) == instrumentedDeclMap.end()) { auto content = stringutils::rangetoStr(*(Result.SourceManager), Var->getSourceRange()); std::string mut_memberCalleeName = \"mut5_\" + instanceName + \"_\" + memberName + \"_ptr\"; instrumentedDeclMap[varDecl] = mut_memberCalleeName; content += \"; /*mut5*/auto \" + mut_memberCalleeName + \" = \" + varType + \"::\" + memberName; Rewrite.ReplaceText(CharSourceRange::getTokenRange(Var->getSourceRange()), content); #if MUT5_OUTPUT llvm::errs() << \"MUT5: \" << \"instrument VarDecl\" << content << \" \"; #endif } std::string mut_memberCalleeName = instrumentedDeclMap[varDecl]; std::string callByDot = instanceName + \".\" + memberName; std::string callByMutPtr = \"/*mut5*/(\" + instanceName + \".*\" + mut_memberCalleeName + \")\"; auto content = stringutils::rangetoStr(*(Result.SourceManager), MC->getSourceRange()); assert(content.find(callByDot, 0) != string::npos && \"Mut5: can not find a member call by dot\"); stringutils::strReplace(content, callByDot, callByMutPtr); Rewrite.ReplaceText( CharSourceRange::getTokenRange(MC->getSourceRange()), content); #if MUT5_OUTPUT llvm::errs() << \"MUT5: \" << \"instrument MemberExpr\" << content << \" \"; #endif } } } } } } void MutatorFrontendAction_5::MutatorASTConsumer_5::HandleTranslationUnit(ASTContext &Context) { MatchFinder matchFinder; auto matcher = cxxMemberCallExpr().bind(\"memberCall\"); Callback callback(TheRewriter); matchFinder.addMatcher(matcher, &callback); matchFinder.matchAST(Context); }"}]}
{"messages": [{"role": "system", "content": "You are an expert in C++ compiler development and AST manipulation"}, {"role": "user", "content": "Based on the provided mutator specification and example mutators for the target language, complete the C++ mutator template to implement the intended transformation. 1. Ensure that the generated code is syntactically valid C++; 2. Correctly implement the mutation logic as described in the specification; 3. Follow the structure of the provided template; 4. Use appropriate C++ APIs for AST manipulation; 5. Includes all necessary imports and dependencies; 6. Analyze the provided mutator suggestion and implement only this specific mutator by completing the provided C++ mutator template; 7. Preserves the template's existing comments and structure; 8. If the suggestion requires new types, variables, or functions, declare them appropriately; 9. Provide only the complete C++ code for the mutator, matching the template's style; 10. Do not wrap the output in Markdown code blocks (e.g., ```C++ or ```). Output only the raw C++ code; 11. Do not implement the mutator based on the examples provided in mutation_content. Instead, focus on designing and implementing complex mutation effects, ideally creating a mutator that maximizes coverage of the seed program's code; 12. Design a unique name that can clearly demonstrate the function of the mutator, replace \"Mutator_\" in the code template, Name words are separated by _, and the first letter of each word is capitalized (for example :Add_Const_Generics),and attach \"_7\",Be sure to specify this name separately on the last line at the end of the output text; Output only the filled-in C++ code, without additional explanations, comments beyond those in the template, or Markdown code blocks. Output only the completed C++ code, without any additional explanations or formatting, ensuring that no comments beyond those in the template or Markdown code blocks are included. Here are the necessary inputs: Mutator Specification: Mutation Operator: Flip Inheritance Access Specifiers in Base Class List Target Code Construct: Class or Struct Definition with Inheritance Mutation Rule: 1. Match all complete class definitions in the main source file that declare at least one base class. 2. For each base specifier in the class's inheritance list: * If it is explicitly marked `public`, replace it with `private`. * If it is explicitly marked `private`, replace it with `public`. * If there is **no access specifier**, insert `private` before the base class name. 3. Prefix the modified base specifier with a comment like `/*mut6*/` to indicate mutation. 4. Apply the transformation by replacing the entire text span corresponding to the base specifier in the source code. Example: Original Code: ``` class Base {}; class Derived : public Base { }; ``` Mutated Code: ``` class Base {}; class Derived : /*mut6*/private Base { }; ``` Instructions: * Do not mutate incomplete class definitions or classes defined outside the main file. * Only operate on syntactically valid inheritance lists. * This mutation may affect name lookup and member visibility, thus altering program semantics, which is intended for stress testing compiler behavior and access resolution. * The mutated access specifier must remain valid under C++ syntax. . Mutator Template for C++ : //header file #pragma once #include \"Mutator_base.h\" /** * Mutator_ */ class MutatorFrontendAction_{{bugno}} : public MutatorFrontendAction { public: MUTATOR_FRONTEND_ACTION_CREATE_ASTCONSUMER({{bugno}}) private: class MutatorASTConsumer_{{bugno}} : public MutatorASTConsumer { public: MutatorASTConsumer_{{bugno}}(Rewriter &R) : TheRewriter(R) {} void HandleTranslationUnit(ASTContext &Context) override; private: Rewriter &TheRewriter; }; class Callback : public MatchFinder::MatchCallback { public: Callback(Rewriter &Rewrite) : Rewrite(Rewrite) {} virtual void run(const MatchFinder::MatchResult &Result); private: Rewriter &Rewrite; //Necessary node information record used in the mutation process }; }; //source file #include \"../include/Mutator_.h\" // ======================================================================================================== #define MUT{{bugno}}_OUTPUT 1 void MutatorFrontendAction_{{bugno}}::Callback::run(const MatchFinder::MatchResult &Result) { //Check whether the matched AST node is the target node if (auto *MT = Result.Nodes.getNodeAs<clang::{{ASTNodeType}}>({{NodeName}})) { //Filter nodes in header files if (!MT || !Result.Context->getSourceManager().isWrittenInMainFile( MT->getLocation())) return; //Get the source code text of target node //(optional)Record the node information to be used in the mutation process //Perform mutation on the source code text by applying string replacement //Replace the original AST node with the mutated one } } void MutatorFrontendAction_{{bugno}}::MutatorASTConsumer_{{bugno}}::HandleTranslationUnit(ASTContext &Context) { MatchFinder matchFinder; //Define one or more ASTMatchers to identify the target AST node for mutation. DeclarationMatcher matcher = {{MatchRule}}.bind({{NodeName}}); Callback callback(TheRewriter); matchFinder.addMatcher(matcher, &callback); matchFinder.matchAST(Context); }. Human-written C++ mutators: //header file #pragma once #include \"Mutator_base.h\" /** * Insert_Lambda_Expression_1 */ class MutatorFrontendAction_1 : public MutatorFrontendAction { public: MUTATOR_FRONTEND_ACTION_CREATE_ASTCONSUMER(1) private: class MutatorASTConsumer_1 : public MutatorASTConsumer { public: MutatorASTConsumer_1(Rewriter &R) : TheRewriter(R) {} void HandleTranslationUnit(ASTContext &Context) override; private: Rewriter &TheRewriter; }; class Callback : public MatchFinder::MatchCallback { public: Callback(Rewriter &Rewrite) : Rewrite(Rewrite) {} virtual void run(const MatchFinder::MatchResult &Result); private: Rewriter &Rewrite; //Necessary node information record used in the mutation process }; }; //source file #include \"../include/insert_lambda_expression_1.h\" // ======================================================================================================== #define MUT1_OUTPUT 1 void MutatorFrontendAction_1::Callback::run(const MatchFinder::MatchResult &Result) { //Check whether the matched AST node is the target node if (auto *MT = Result.Nodes.getNodeAs<clang::CXXMethodDecl>(\"Methods\")) { //Filter nodes in header files if (!MT || !Result.Context->getSourceManager().isWrittenInMainFile( MT->getLocation())) return; if (MT->hasBody() && !MT->isVirtual()) { //Get the source code text of target node auto declaration = stringutils::rangetoStr(*(Result.SourceManager), MT->getSourceRange()); //Perform mutation on the source code text by applying string replacement declaration.insert(declaration.find(\"{\") + 1, \" /*mut9*/[&](){ \"); declaration.insert(declaration.rfind(\"}\"), \" }(); \"); int choice = getrandom::getRandomIndex(1); //Replace the original AST node with the mutated one if (choice) { Rewrite.ReplaceText(CharSourceRange::getTokenRange(MT->getSourceRange()), declaration); } } } } void MutatorFrontendAction__1::MutatorASTConsumer_1::HandleTranslationUnit(ASTContext &Context) { MatchFinder matchFinder; //Define an ASTMatcher to identify the target AST node for mutation. DeclarationMatcher matcher = cxxMethodDecl(unless(cxxConstructorDecl())).bind(\"Methods\"); Callback callback(TheRewriter); matchFinder.addMatcher(matcher, &callback); matchFinder.matchAST(Context); }."}, {"role": "assistant", "content": "//header file #pragma once #include \"Mutator_base.h\" /** * Flip_Inheritance_Access_Specifier_6 */ class MutatorFrontendAction_6 : public MutatorFrontendAction { public: MUTATOR_FRONTEND_ACTION_CREATE_ASTCONSUMER(6) private: class MutatorASTConsumer_6 : public MutatorASTConsumer { public: MutatorASTConsumer_6(Rewriter &R) : TheRewriter(R) {} void HandleTranslationUnit(ASTContext &Context) override; private: Rewriter &TheRewriter; }; class Callback : public MatchFinder::MatchCallback { public: Callback(Rewriter &Rewrite) : Rewrite(Rewrite) {} virtual void run(const MatchFinder::MatchResult &Result); private: Rewriter &Rewrite; }; }; //source file #include \"../include/Flip_Inheritance_Access_Specifier_6.h\" // ======================================================================================================== #define MUT6_OUTPUT 1 void MutatorFrontendAction_6::Callback::run(const MatchFinder::MatchResult &Result) { if (auto *DL = Result.Nodes.getNodeAs<clang::CXXRecordDecl>(\"Derived\")) { if (!DL || !Result.Context->getSourceManager().isWrittenInMainFile( DL->getLocation())) return; if (DL->isCompleteDefinition() == false) return; auto bases = DL->getDefinition()->bases(); for (auto base : bases) { auto base_str = stringutils::rangetoStr(*(Result.SourceManager), base.getSourceRange()); auto length = base_str.length(); // llvm::outs()<<base_str<<' '; if (base_str.find(\"private\", 0) != string::npos) { stringutils::strReplace(base_str, \"private\", \"public\"); } else if (base_str.find(\"public\", 0) != string::npos) { stringutils::strReplace(base_str, \"public\", \"private\"); } else { base_str = \"private \" + base_str; } base_str = \"/*mut6*/\" + base_str; llvm::outs() << base_str << ' '; Rewrite.ReplaceText(base.getBeginLoc(), length, base_str); } } } void MutatorFrontendAction_6::MutatorASTConsumer_6::HandleTranslationUnit(ASTContext &Context) { MatchFinder matchFinder; DeclarationMatcher matcher = cxxRecordDecl(hasAnyBase(hasType(cxxRecordDecl()))).bind(\"Derived\"); Callback callback(TheRewriter); matchFinder.addMatcher(matcher, &callback); matchFinder.matchAST(Context); }"}]}
{"messages": [{"role": "system", "content": "You are an expert in C++ compiler development and AST manipulation"}, {"role": "user", "content": "Based on the provided mutator specification and example mutators for the target language, complete the C++ mutator template to implement the intended transformation. 1. Ensure that the generated code is syntactically valid C++; 2. Correctly implement the mutation logic as described in the specification; 3. Follow the structure of the provided template; 4. Use appropriate C++ APIs for AST manipulation; 5. Includes all necessary imports and dependencies; 6. Analyze the provided mutator suggestion and implement only this specific mutator by completing the provided C++ mutator template; 7. Preserves the template's existing comments and structure; 8. If the suggestion requires new types, variables, or functions, declare them appropriately; 9. Provide only the complete C++ code for the mutator, matching the template's style; 10. Do not wrap the output in Markdown code blocks (e.g., ```C++ or ```). Output only the raw C++ code; 11. Do not implement the mutator based on the examples provided in mutation_content. Instead, focus on designing and implementing complex mutation effects, ideally creating a mutator that maximizes coverage of the seed program's code; 12. Design a unique name that can clearly demonstrate the function of the mutator, replace \"Mutator_\" in the code template, Name words are separated by _, and the first letter of each word is capitalized (for example :Add_Const_Generics),and attach \"_8\",Be sure to specify this name separately on the last line at the end of the output text; Output only the filled-in C++ code, without additional explanations, comments beyond those in the template, or Markdown code blocks. Output only the completed C++ code, without any additional explanations or formatting, ensuring that no comments beyond those in the template or Markdown code blocks are included. Here are the necessary inputs: Mutator Specification: Mutation Operator: Insert Explicit Default Destructor Declaration for Implicit Destructor Target Code Construct: Class or Struct Definition Mutation Rule: 1. Match all complete class or struct definitions in the main source file. 2. For each matched class, retrieve its destructor declaration (if any). 3. If the destructor exists but is **implicitly declared**, insert an explicit defaulted destructor declaration. 4. The inserted destructor declaration should: * Use the tilde `~` followed by the class name. * Be marked with `= default;`. * Be prefixed with a mutation marker comment (e.g., `/*mut7*/`). 5. Insert the synthesized declaration before the closing brace of the class definition. Example: Original Code: ``` class A { }; ``` Mutated Code: ``` class A { }; /*mut7*/~A()=default; ``` Instructions: * Do not inject duplicate destructors; only mutate if the destructor is implicit. * Ensure the injected code uses the correct class name and proper syntax. * This mutation retains functional equivalence but alters the AST, which may impact compiler optimization, ABI generation, or destructor inlining behavior. * Do not apply to lambda types or incomplete definitions. . Mutator Template for C++ : //header file #pragma once #include \"Mutator_base.h\" /** * Mutator_ */ class MutatorFrontendAction_{{bugno}} : public MutatorFrontendAction { public: MUTATOR_FRONTEND_ACTION_CREATE_ASTCONSUMER({{bugno}}) private: class MutatorASTConsumer_{{bugno}} : public MutatorASTConsumer { public: MutatorASTConsumer_{{bugno}}(Rewriter &R) : TheRewriter(R) {} void HandleTranslationUnit(ASTContext &Context) override; private: Rewriter &TheRewriter; }; class Callback : public MatchFinder::MatchCallback { public: Callback(Rewriter &Rewrite) : Rewrite(Rewrite) {} virtual void run(const MatchFinder::MatchResult &Result); private: Rewriter &Rewrite; //Necessary node information record used in the mutation process }; }; //source file #include \"../include/Mutator_.h\" // ======================================================================================================== #define MUT{{bugno}}_OUTPUT 1 void MutatorFrontendAction_{{bugno}}::Callback::run(const MatchFinder::MatchResult &Result) { //Check whether the matched AST node is the target node if (auto *MT = Result.Nodes.getNodeAs<clang::{{ASTNodeType}}>({{NodeName}})) { //Filter nodes in header files if (!MT || !Result.Context->getSourceManager().isWrittenInMainFile( MT->getLocation())) return; //Get the source code text of target node //(optional)Record the node information to be used in the mutation process //Perform mutation on the source code text by applying string replacement //Replace the original AST node with the mutated one } } void MutatorFrontendAction_{{bugno}}::MutatorASTConsumer_{{bugno}}::HandleTranslationUnit(ASTContext &Context) { MatchFinder matchFinder; //Define one or more ASTMatchers to identify the target AST node for mutation. DeclarationMatcher matcher = {{MatchRule}}.bind({{NodeName}}); Callback callback(TheRewriter); matchFinder.addMatcher(matcher, &callback); matchFinder.matchAST(Context); }. Human-written C++ mutators: //header file #pragma once #include \"Mutator_base.h\" /** * Insert_Lambda_Expression_1 */ class MutatorFrontendAction_1 : public MutatorFrontendAction { public: MUTATOR_FRONTEND_ACTION_CREATE_ASTCONSUMER(1) private: class MutatorASTConsumer_1 : public MutatorASTConsumer { public: MutatorASTConsumer_1(Rewriter &R) : TheRewriter(R) {} void HandleTranslationUnit(ASTContext &Context) override; private: Rewriter &TheRewriter; }; class Callback : public MatchFinder::MatchCallback { public: Callback(Rewriter &Rewrite) : Rewrite(Rewrite) {} virtual void run(const MatchFinder::MatchResult &Result); private: Rewriter &Rewrite; //Necessary node information record used in the mutation process }; }; //source file #include \"../include/insert_lambda_expression_1.h\" // ======================================================================================================== #define MUT1_OUTPUT 1 void MutatorFrontendAction_1::Callback::run(const MatchFinder::MatchResult &Result) { //Check whether the matched AST node is the target node if (auto *MT = Result.Nodes.getNodeAs<clang::CXXMethodDecl>(\"Methods\")) { //Filter nodes in header files if (!MT || !Result.Context->getSourceManager().isWrittenInMainFile( MT->getLocation())) return; if (MT->hasBody() && !MT->isVirtual()) { //Get the source code text of target node auto declaration = stringutils::rangetoStr(*(Result.SourceManager), MT->getSourceRange()); //Perform mutation on the source code text by applying string replacement declaration.insert(declaration.find(\"{\") + 1, \" /*mut9*/[&](){ \"); declaration.insert(declaration.rfind(\"}\"), \" }(); \"); int choice = getrandom::getRandomIndex(1); //Replace the original AST node with the mutated one if (choice) { Rewrite.ReplaceText(CharSourceRange::getTokenRange(MT->getSourceRange()), declaration); } } } } void MutatorFrontendAction__1::MutatorASTConsumer_1::HandleTranslationUnit(ASTContext &Context) { MatchFinder matchFinder; //Define an ASTMatcher to identify the target AST node for mutation. DeclarationMatcher matcher = cxxMethodDecl(unless(cxxConstructorDecl())).bind(\"Methods\"); Callback callback(TheRewriter); matchFinder.addMatcher(matcher, &callback); matchFinder.matchAST(Context); }."}, {"role": "assistant", "content": "//header file #pragma once #include \"Mutator_base.h\" /** * Insert_Explicit_Default_Destructor_For_Implicit_7 */ class MutatorFrontendAction_7 : public MutatorFrontendAction { public: MUTATOR_FRONTEND_ACTION_CREATE_ASTCONSUMER(7) private: class MutatorASTConsumer_7 : public MutatorASTConsumer { public: MutatorASTConsumer_7(Rewriter &R) : TheRewriter(R) {} void HandleTranslationUnit(ASTContext &Context) override; private: Rewriter &TheRewriter; }; class Callback : public MatchFinder::MatchCallback { public: Callback(Rewriter &Rewrite) : Rewrite(Rewrite) {} virtual void run(const MatchFinder::MatchResult &Result); private: Rewriter &Rewrite; }; }; //source file #include \"../include/Insert_Explicit_Default_Destructor_For_Implicit_7.h\" // ======================================================================================================== #define MUT7_OUTPUT 1 void MutatorFrontendAction_7::Callback::run(const MatchFinder::MatchResult &Result) { if (auto *CL = Result.Nodes.getNodeAs<clang::CXXRecordDecl>(\"Classes\")) { if (!CL || !Result.Context->getSourceManager().isWrittenInMainFile( CL->getLocation())) return; if ((!CL->isStruct() && !CL->isClass()) || CL->isLambda()) return; if (!CL->isCompleteDefinition()) return; // L->dump(); auto TD = CL->getDestructor(); if (TD == nullptr) return; auto def = stringutils::rangetoStr(*(Result.SourceManager), TD->getSourceRange()); string dtor_definition = \"~\" + def + \"()=default; \"; dtor_definition = \"/*mut7*/\" + dtor_definition; if (TD->isImplicit()) { llvm::outs() << dtor_definition << ' '; Rewrite.ReplaceText(CL->getEndLoc(), 0, dtor_definition); } } } void MutatorFrontendAction_7::MutatorASTConsumer_7::HandleTranslationUnit(ASTContext &Context) { MatchFinder matchFinder; DeclarationMatcher matcher = cxxRecordDecl().bind(\"Classes\"); Callback callback(TheRewriter); matchFinder.addMatcher(matcher, &callback); matchFinder.matchAST(Context); }"}]}
{"messages": [{"role": "system", "content": "You are an expert in C++ compiler development and AST manipulation"}, {"role": "user", "content": "Based on the provided mutator specification and example mutators for the target language, complete the C++ mutator template to implement the intended transformation. 1. Ensure that the generated code is syntactically valid C++; 2. Correctly implement the mutation logic as described in the specification; 3. Follow the structure of the provided template; 4. Use appropriate C++ APIs for AST manipulation; 5. Includes all necessary imports and dependencies; 6. Analyze the provided mutator suggestion and implement only this specific mutator by completing the provided C++ mutator template; 7. Preserves the template's existing comments and structure; 8. If the suggestion requires new types, variables, or functions, declare them appropriately; 9. Provide only the complete C++ code for the mutator, matching the template's style; 10. Do not wrap the output in Markdown code blocks (e.g., ```C++ or ```). Output only the raw C++ code; 11. Do not implement the mutator based on the examples provided in mutation_content. Instead, focus on designing and implementing complex mutation effects, ideally creating a mutator that maximizes coverage of the seed program's code; 12. Design a unique name that can clearly demonstrate the function of the mutator, replace \"Mutator_\" in the code template, Name words are separated by _, and the first letter of each word is capitalized (for example :Add_Const_Generics),and attach \"_9\",Be sure to specify this name separately on the last line at the end of the output text; Output only the filled-in C++ code, without additional explanations, comments beyond those in the template, or Markdown code blocks. Output only the completed C++ code, without any additional explanations or formatting, ensuring that no comments beyond those in the template or Markdown code blocks are included. Here are the necessary inputs: Mutator Specification: * **Mutation Operator**: Switch access specifier of inherited fields using `using` declarations * **Target Code Construct**: Inherited protected/public fields in C++ class hierarchies * **Mutation Rule**: 1. Identify a derived class `D` that inherits from a base class `B`. 2. For every `protected` field in `B`, inject a `using B::field;` declaration under `public` section of `D`. 3. For every `public` field in `B`, inject a `using B::field;` declaration under `protected` section of `D`. 4. Insert the mutation at the end of the derived class `D`, preserving syntax validity. * **Example**: *Original Code* ```cpp class Base { protected: int protectedField; public: int publicField; }; class Derived : public Base {}; ``` *Mutated Code* ```cpp class Derived : public Base { /*mut8*/ public: using Base :: protectedField; protected: using Base :: publicField; }; ``` * **Instructions**: * Use this operator to assess the sensitivity of field accessibility on program behavior. * Avoid applying to classes with duplicate or ambiguous member names from multiple base classes. * Best used in inheritance-heavy C++ projects. . Mutator Template for C++ : //header file #pragma once #include \"Mutator_base.h\" /** * Mutator_ */ class MutatorFrontendAction_{{bugno}} : public MutatorFrontendAction { public: MUTATOR_FRONTEND_ACTION_CREATE_ASTCONSUMER({{bugno}}) private: class MutatorASTConsumer_{{bugno}} : public MutatorASTConsumer { public: MutatorASTConsumer_{{bugno}}(Rewriter &R) : TheRewriter(R) {} void HandleTranslationUnit(ASTContext &Context) override; private: Rewriter &TheRewriter; }; class Callback : public MatchFinder::MatchCallback { public: Callback(Rewriter &Rewrite) : Rewrite(Rewrite) {} virtual void run(const MatchFinder::MatchResult &Result); private: Rewriter &Rewrite; //Necessary node information record used in the mutation process }; }; //source file #include \"../include/Mutator_.h\" // ======================================================================================================== #define MUT{{bugno}}_OUTPUT 1 void MutatorFrontendAction_{{bugno}}::Callback::run(const MatchFinder::MatchResult &Result) { //Check whether the matched AST node is the target node if (auto *MT = Result.Nodes.getNodeAs<clang::{{ASTNodeType}}>({{NodeName}})) { //Filter nodes in header files if (!MT || !Result.Context->getSourceManager().isWrittenInMainFile( MT->getLocation())) return; //Get the source code text of target node //(optional)Record the node information to be used in the mutation process //Perform mutation on the source code text by applying string replacement //Replace the original AST node with the mutated one } } void MutatorFrontendAction_{{bugno}}::MutatorASTConsumer_{{bugno}}::HandleTranslationUnit(ASTContext &Context) { MatchFinder matchFinder; //Define one or more ASTMatchers to identify the target AST node for mutation. DeclarationMatcher matcher = {{MatchRule}}.bind({{NodeName}}); Callback callback(TheRewriter); matchFinder.addMatcher(matcher, &callback); matchFinder.matchAST(Context); }. Human-written C++ mutators: //header file #pragma once #include \"Mutator_base.h\" /** * Insert_Lambda_Expression_1 */ class MutatorFrontendAction_1 : public MutatorFrontendAction { public: MUTATOR_FRONTEND_ACTION_CREATE_ASTCONSUMER(1) private: class MutatorASTConsumer_1 : public MutatorASTConsumer { public: MutatorASTConsumer_1(Rewriter &R) : TheRewriter(R) {} void HandleTranslationUnit(ASTContext &Context) override; private: Rewriter &TheRewriter; }; class Callback : public MatchFinder::MatchCallback { public: Callback(Rewriter &Rewrite) : Rewrite(Rewrite) {} virtual void run(const MatchFinder::MatchResult &Result); private: Rewriter &Rewrite; //Necessary node information record used in the mutation process }; }; //source file #include \"../include/insert_lambda_expression_1.h\" // ======================================================================================================== #define MUT1_OUTPUT 1 void MutatorFrontendAction_1::Callback::run(const MatchFinder::MatchResult &Result) { //Check whether the matched AST node is the target node if (auto *MT = Result.Nodes.getNodeAs<clang::CXXMethodDecl>(\"Methods\")) { //Filter nodes in header files if (!MT || !Result.Context->getSourceManager().isWrittenInMainFile( MT->getLocation())) return; if (MT->hasBody() && !MT->isVirtual()) { //Get the source code text of target node auto declaration = stringutils::rangetoStr(*(Result.SourceManager), MT->getSourceRange()); //Perform mutation on the source code text by applying string replacement declaration.insert(declaration.find(\"{\") + 1, \" /*mut9*/[&](){ \"); declaration.insert(declaration.rfind(\"}\"), \" }(); \"); int choice = getrandom::getRandomIndex(1); //Replace the original AST node with the mutated one if (choice) { Rewrite.ReplaceText(CharSourceRange::getTokenRange(MT->getSourceRange()), declaration); } } } } void MutatorFrontendAction__1::MutatorASTConsumer_1::HandleTranslationUnit(ASTContext &Context) { MatchFinder matchFinder; //Define an ASTMatcher to identify the target AST node for mutation. DeclarationMatcher matcher = cxxMethodDecl(unless(cxxConstructorDecl())).bind(\"Methods\"); Callback callback(TheRewriter); matchFinder.addMatcher(matcher, &callback); matchFinder.matchAST(Context); }."}, {"role": "assistant", "content": "//header file #pragma once #include \"Mutator_base.h\" /** * Switch_Access_Of_Inherited_Field_UsingDeclaration_8 */ class MutatorFrontendAction_8 : public MutatorFrontendAction { public: MUTATOR_FRONTEND_ACTION_CREATE_ASTCONSUMER(8) private: class MutatorASTConsumer_8 : public MutatorASTConsumer { public: MutatorASTConsumer_8(Rewriter &R) : TheRewriter(R) {} void HandleTranslationUnit(ASTContext &Context) override; private: Rewriter &TheRewriter; }; class Callback : public MatchFinder::MatchCallback { public: Callback(Rewriter &Rewrite) : Rewrite(Rewrite) {} virtual void run(const MatchFinder::MatchResult &Result); private: Rewriter &Rewrite; std::vector<const clang::CXXRecordDecl *> cur_classes; }; }; //source file #include \"../include/Switch_Access_Of_Inherited_Field_UsingDeclaration_8.h\" // ======================================================================================================== #define MUT8_OUTPUT 1 void MutatorFrontendAction_8::Callback::run(const MatchFinder::MatchResult &Result) { string acc_sep; if (auto *CL = Result.Nodes.getNodeAs<clang::CXXRecordDecl>(\"Classes\")) { if (!CL || !Result.Context->getSourceManager().isWrittenInMainFile( CL->getLocation())) return; if ((!CL->isStruct() && !CL->isClass()) || CL->isLambda()) return; cur_classes.push_back(CL); } else if (auto *DL = Result.Nodes.getNodeAs<clang::CXXRecordDecl>(\"Derived\")) { if (!DL || !Result.Context->getSourceManager().isWrittenInMainFile( DL->getLocation())) return; auto decls = DL->decls(); for (auto decl : decls) { if (decl->getIdentifierNamespace() == Decl::IdentifierNamespace::IDNS_Using) { // auto usingdecl=(UsingDecl)decl; } } if (DL->isCompleteDefinition() == false) return; for (std::size_t j = 0; j < cur_classes.size(); ++j) { if (DL->isDerivedFrom(cur_classes[j])) { auto fields = cur_classes[j]->fields(); std::vector<FieldDecl *> public_field; std::vector<FieldDecl *> protected_field; for (auto field : fields) { if (field->getAccess() == AccessSpecifier::AS_protected) protected_field.push_back(field); else if (field->getAccess() == AccessSpecifier::AS_public) public_field.push_back(field); } if (!protected_field.empty()) { acc_sep += \" public: \"; string classname = cur_classes[j]->getNameAsString(); for (auto field : protected_field) { string fieldname = field->getNameAsString(); acc_sep += \"using \" + classname + \" :: \" + fieldname + \"; \"; } llvm::outs() << acc_sep; // auto Err = // rep.add(Replacement(*(Result.SourceManager),DL->getEndLoc(),0,acc_sep)); } if (!public_field.empty()) { acc_sep += \"protected: \"; string classname = cur_classes[j]->getNameAsString(); for (auto field : public_field) { string fieldname = field->getNameAsString(); acc_sep += \"using \" + classname + \" :: \" + fieldname + \"; \"; } } } } acc_sep = \" /*mut8*/\" + acc_sep; llvm::outs() << acc_sep; Rewrite.ReplaceText(DL->getEndLoc(), 0, acc_sep); } } void MutatorFrontendAction_8::MutatorASTConsumer_8::HandleTranslationUnit(ASTContext &Context) { MatchFinder matchFinder; DeclarationMatcher matcher = cxxRecordDecl().bind(\"Classes\"); auto derived_matcher = cxxRecordDecl(hasAnyBase(hasType(cxxRecordDecl()))).bind(\"Derived\"); auto class_matcher = cxxRecordDecl().bind(\"Classes\"); Callback callback(TheRewriter); matchFinder.addMatcher(derived_matcher, &callback); matchFinder.addMatcher(class_matcher, &callback); matchFinder.matchAST(Context); }"}]}
{"messages": [{"role": "system", "content": "You are an expert in C++ compiler development and AST manipulation"}, {"role": "user", "content": "Based on the provided mutator specification and example mutators for the target language, complete the C++ mutator template to implement the intended transformation. 1. Ensure that the generated code is syntactically valid C++; 2. Correctly implement the mutation logic as described in the specification; 3. Follow the structure of the provided template; 4. Use appropriate C++ APIs for AST manipulation; 5. Includes all necessary imports and dependencies; 6. Analyze the provided mutator suggestion and implement only this specific mutator by completing the provided C++ mutator template; 7. Preserves the template's existing comments and structure; 8. If the suggestion requires new types, variables, or functions, declare them appropriately; 9. Provide only the complete C++ code for the mutator, matching the template's style; 10. Do not wrap the output in Markdown code blocks (e.g., ```C++ or ```). Output only the raw C++ code; 11. Do not implement the mutator based on the examples provided in mutation_content. Instead, focus on designing and implementing complex mutation effects, ideally creating a mutator that maximizes coverage of the seed program's code; 12. Design a unique name that can clearly demonstrate the function of the mutator, replace \"Mutator_\" in the code template, Name words are separated by _, and the first letter of each word is capitalized (for example :Add_Const_Generics),and attach \"_10\",Be sure to specify this name separately on the last line at the end of the output text; Output only the filled-in C++ code, without additional explanations, comments beyond those in the template, or Markdown code blocks. Output only the completed C++ code, without any additional explanations or formatting, ensuring that no comments beyond those in the template or Markdown code blocks are included. Here are the necessary inputs: Mutator Specification: Mutation Operator: Rotate and Annotate Constructor Initializer List Order Target Code Construct: Constructor Definition with Initializer List Mutation Rule: 1. Identify constructors in the main source file that have an initializer list with more than one member initializer. 2. Extract all member initializer expressions from the constructor’s initializer list. 3. Perform a rotation on the initializer list by moving the first initializer to the end, shifting others forward by one. 4. For each initializer in the rotated list, prefix it with a mutation comment such as `/*mut9*/`. 5. Replace the original initializer list entries in source code with the rotated and annotated initializers. Example: Original Code: ``` class A { public: int x, y; A(int a, int b) : x(a), y(b) {} }; ``` Mutated Code: ``` class A { public: int x, y; A(int a, int b) : /*mut9*/y(b), /*mut9*/x(a) {} }; ``` Instructions: * Only apply when the constructor initializer list contains multiple initializers. * The mutation may alter initialization order, potentially causing subtle semantic or runtime differences. * The inserted comment is for traceability during testing and debugging. * This mutation aims to explore compiler or runtime sensitivity to initializer ordering. . Mutator Template for C++ : //header file #pragma once #include \"Mutator_base.h\" /** * Mutator_ */ class MutatorFrontendAction_{{bugno}} : public MutatorFrontendAction { public: MUTATOR_FRONTEND_ACTION_CREATE_ASTCONSUMER({{bugno}}) private: class MutatorASTConsumer_{{bugno}} : public MutatorASTConsumer { public: MutatorASTConsumer_{{bugno}}(Rewriter &R) : TheRewriter(R) {} void HandleTranslationUnit(ASTContext &Context) override; private: Rewriter &TheRewriter; }; class Callback : public MatchFinder::MatchCallback { public: Callback(Rewriter &Rewrite) : Rewrite(Rewrite) {} virtual void run(const MatchFinder::MatchResult &Result); private: Rewriter &Rewrite; //Necessary node information record used in the mutation process }; }; //source file #include \"../include/Mutator_.h\" // ======================================================================================================== #define MUT{{bugno}}_OUTPUT 1 void MutatorFrontendAction_{{bugno}}::Callback::run(const MatchFinder::MatchResult &Result) { //Check whether the matched AST node is the target node if (auto *MT = Result.Nodes.getNodeAs<clang::{{ASTNodeType}}>({{NodeName}})) { //Filter nodes in header files if (!MT || !Result.Context->getSourceManager().isWrittenInMainFile( MT->getLocation())) return; //Get the source code text of target node //(optional)Record the node information to be used in the mutation process //Perform mutation on the source code text by applying string replacement //Replace the original AST node with the mutated one } } void MutatorFrontendAction_{{bugno}}::MutatorASTConsumer_{{bugno}}::HandleTranslationUnit(ASTContext &Context) { MatchFinder matchFinder; //Define one or more ASTMatchers to identify the target AST node for mutation. DeclarationMatcher matcher = {{MatchRule}}.bind({{NodeName}}); Callback callback(TheRewriter); matchFinder.addMatcher(matcher, &callback); matchFinder.matchAST(Context); }. Human-written C++ mutators: //header file #pragma once #include \"Mutator_base.h\" /** * Insert_Lambda_Expression_1 */ class MutatorFrontendAction_1 : public MutatorFrontendAction { public: MUTATOR_FRONTEND_ACTION_CREATE_ASTCONSUMER(1) private: class MutatorASTConsumer_1 : public MutatorASTConsumer { public: MutatorASTConsumer_1(Rewriter &R) : TheRewriter(R) {} void HandleTranslationUnit(ASTContext &Context) override; private: Rewriter &TheRewriter; }; class Callback : public MatchFinder::MatchCallback { public: Callback(Rewriter &Rewrite) : Rewrite(Rewrite) {} virtual void run(const MatchFinder::MatchResult &Result); private: Rewriter &Rewrite; //Necessary node information record used in the mutation process }; }; //source file #include \"../include/insert_lambda_expression_1.h\" // ======================================================================================================== #define MUT1_OUTPUT 1 void MutatorFrontendAction_1::Callback::run(const MatchFinder::MatchResult &Result) { //Check whether the matched AST node is the target node if (auto *MT = Result.Nodes.getNodeAs<clang::CXXMethodDecl>(\"Methods\")) { //Filter nodes in header files if (!MT || !Result.Context->getSourceManager().isWrittenInMainFile( MT->getLocation())) return; if (MT->hasBody() && !MT->isVirtual()) { //Get the source code text of target node auto declaration = stringutils::rangetoStr(*(Result.SourceManager), MT->getSourceRange()); //Perform mutation on the source code text by applying string replacement declaration.insert(declaration.find(\"{\") + 1, \" /*mut9*/[&](){ \"); declaration.insert(declaration.rfind(\"}\"), \" }(); \"); int choice = getrandom::getRandomIndex(1); //Replace the original AST node with the mutated one if (choice) { Rewrite.ReplaceText(CharSourceRange::getTokenRange(MT->getSourceRange()), declaration); } } } } void MutatorFrontendAction__1::MutatorASTConsumer_1::HandleTranslationUnit(ASTContext &Context) { MatchFinder matchFinder; //Define an ASTMatcher to identify the target AST node for mutation. DeclarationMatcher matcher = cxxMethodDecl(unless(cxxConstructorDecl())).bind(\"Methods\"); Callback callback(TheRewriter); matchFinder.addMatcher(matcher, &callback); matchFinder.matchAST(Context); }."}, {"role": "assistant", "content": "//header file #pragma once #include \"Mutator_base.h\" /** * Rotate_Constructor_Initializer_List_9 */ class MutatorFrontendAction_9 : public MutatorFrontendAction { public: MUTATOR_FRONTEND_ACTION_CREATE_ASTCONSUMER(9) private: class MutatorASTConsumer_9 : public MutatorASTConsumer { public: MutatorASTConsumer_9(Rewriter &R) : TheRewriter(R) {} void HandleTranslationUnit(ASTContext &Context) override; private: Rewriter &TheRewriter; }; class Callback : public MatchFinder::MatchCallback { public: Callback(Rewriter &Rewrite) : Rewrite(Rewrite) {} virtual void run(const MatchFinder::MatchResult &Result); private: Rewriter &Rewrite; }; }; //source file #include \"../include/Rotate_Constructor_Initializer_List_9.h\" // ======================================================================================================== #define MUT9_OUTPUT 1 void MutatorFrontendAction_9::Callback::run(const MatchFinder::MatchResult &Result) { if (auto *CD = Result.Nodes.getNodeAs<clang::CXXConstructorDecl>(\"Notrivialctor\")) { if (!CD || !Result.Context->getSourceManager().isWrittenInMainFile( CD->getLocation())) return; // if(CD-) auto inits = CD->inits(); std::vector<string> init_codes; for (auto init : inits) { init_codes.push_back(stringutils::rangetoStr(*(Result.SourceManager), init->getSourceRange())); } if (init_codes.size() > 1) { std::rotate(init_codes.begin(), init_codes.begin() + 1, init_codes.end()); } int index = 0; for (auto init : inits) { init_codes[index] = \"/*mut9*/\" + init_codes[index]; llvm::outs() << init_codes[index] << ' '; Rewrite.ReplaceText(CharSourceRange::getTokenRange(init->getSourceRange()), init_codes[index]); index++; } } } void MutatorFrontendAction_9::MutatorASTConsumer_9::HandleTranslationUnit(ASTContext &Context) { MatchFinder matchFinder; auto matcher = cxxConstructorDecl(has(cxxCtorInitializer())).bind(\"Notrivialctor\"); Callback callback(TheRewriter); matchFinder.addMatcher(matcher, &callback); matchFinder.matchAST(Context); }"}]}
{"messages": [{"role": "system", "content": "You are an expert in C++ compiler development and AST manipulation"}, {"role": "user", "content": "Based on the provided mutator specification and example mutators for the target language, complete the C++ mutator template to implement the intended transformation. 1. Ensure that the generated code is syntactically valid C++; 2. Correctly implement the mutation logic as described in the specification; 3. Follow the structure of the provided template; 4. Use appropriate C++ APIs for AST manipulation; 5. Includes all necessary imports and dependencies; 6. Analyze the provided mutator suggestion and implement only this specific mutator by completing the provided C++ mutator template; 7. Preserves the template's existing comments and structure; 8. If the suggestion requires new types, variables, or functions, declare them appropriately; 9. Provide only the complete C++ code for the mutator, matching the template's style; 10. Do not wrap the output in Markdown code blocks (e.g., ```C++ or ```). Output only the raw C++ code; 11. Do not implement the mutator based on the examples provided in mutation_content. Instead, focus on designing and implementing complex mutation effects, ideally creating a mutator that maximizes coverage of the seed program's code; 12. Design a unique name that can clearly demonstrate the function of the mutator, replace \"Mutator_\" in the code template, Name words are separated by _, and the first letter of each word is capitalized (for example :Add_Const_Generics),and attach \"_2\",Be sure to specify this name separately on the last line at the end of the output text; Output only the filled-in C++ code, without additional explanations, comments beyond those in the template, or Markdown code blocks. Output only the completed C++ code, without any additional explanations or formatting, ensuring that no comments beyond those in the template or Markdown code blocks are included. Here are the necessary inputs: Mutator Specification: Mutation Operator: Toggle Access Specifier of Constructors and Destructors Target Code Construct: Class or Struct Definition's Constructors and Destructor Mutation Rule: 1. For each non-implicit constructor in a class defined in the main source file: * If the constructor's access specifier is `private` or `protected`, insert `public:` immediately before the constructor declaration, prefixed with a mutation comment `/*mut10*/`. * Otherwise (i.e., if `public`), insert `protected:` before the constructor declaration with the mutation comment. 2. For the class destructor, if non-implicit and a random choice allows mutation: * Similarly toggle its access specifier between `private/protected` and `public` by inserting corresponding access labels with the mutation comment. 3. These inserted access specifiers appear immediately before the constructor or destructor declarations in source code, altering accessibility. Example: Original Code: ``` class A { protected: A() {} ~A() {} }; ``` Possible Mutated Code: ``` class A { public: /*mut10*/A() {} /*mut10*/protected: ~A() {} }; ``` Instructions: * Mutation is probabilistic per constructor and destructor (based on random index). * Only apply if constructors or destructor are explicitly declared (not implicit). * Changing access specifiers may alter class usability or encapsulation, affecting client code or compiler diagnostics. * Use to evaluate compiler handling of access control changes during compilation or optimization. . Mutator Template for C++ : //header file #pragma once #include \"Mutator_base.h\" /** * Mutator_ */ class MutatorFrontendAction_{{bugno}} : public MutatorFrontendAction { public: MUTATOR_FRONTEND_ACTION_CREATE_ASTCONSUMER({{bugno}}) private: class MutatorASTConsumer_{{bugno}} : public MutatorASTConsumer { public: MutatorASTConsumer_{{bugno}}(Rewriter &R) : TheRewriter(R) {} void HandleTranslationUnit(ASTContext &Context) override; private: Rewriter &TheRewriter; }; class Callback : public MatchFinder::MatchCallback { public: Callback(Rewriter &Rewrite) : Rewrite(Rewrite) {} virtual void run(const MatchFinder::MatchResult &Result); private: Rewriter &Rewrite; //Necessary node information record used in the mutation process }; }; //source file #include \"../include/Mutator_.h\" // ======================================================================================================== #define MUT{{bugno}}_OUTPUT 1 void MutatorFrontendAction_{{bugno}}::Callback::run(const MatchFinder::MatchResult &Result) { //Check whether the matched AST node is the target node if (auto *MT = Result.Nodes.getNodeAs<clang::{{ASTNodeType}}>({{NodeName}})) { //Filter nodes in header files if (!MT || !Result.Context->getSourceManager().isWrittenInMainFile( MT->getLocation())) return; //Get the source code text of target node //(optional)Record the node information to be used in the mutation process //Perform mutation on the source code text by applying string replacement //Replace the original AST node with the mutated one } } void MutatorFrontendAction_{{bugno}}::MutatorASTConsumer_{{bugno}}::HandleTranslationUnit(ASTContext &Context) { MatchFinder matchFinder; //Define one or more ASTMatchers to identify the target AST node for mutation. DeclarationMatcher matcher = {{MatchRule}}.bind({{NodeName}}); Callback callback(TheRewriter); matchFinder.addMatcher(matcher, &callback); matchFinder.matchAST(Context); }. Human-written C++ mutators: //header file #pragma once #include \"Mutator_base.h\" /** * Insert_Lambda_Expression_1 */ class MutatorFrontendAction_1 : public MutatorFrontendAction { public: MUTATOR_FRONTEND_ACTION_CREATE_ASTCONSUMER(1) private: class MutatorASTConsumer_1 : public MutatorASTConsumer { public: MutatorASTConsumer_1(Rewriter &R) : TheRewriter(R) {} void HandleTranslationUnit(ASTContext &Context) override; private: Rewriter &TheRewriter; }; class Callback : public MatchFinder::MatchCallback { public: Callback(Rewriter &Rewrite) : Rewrite(Rewrite) {} virtual void run(const MatchFinder::MatchResult &Result); private: Rewriter &Rewrite; //Necessary node information record used in the mutation process }; }; //source file #include \"../include/insert_lambda_expression_1.h\" // ======================================================================================================== #define MUT1_OUTPUT 1 void MutatorFrontendAction_1::Callback::run(const MatchFinder::MatchResult &Result) { //Check whether the matched AST node is the target node if (auto *MT = Result.Nodes.getNodeAs<clang::CXXMethodDecl>(\"Methods\")) { //Filter nodes in header files if (!MT || !Result.Context->getSourceManager().isWrittenInMainFile( MT->getLocation())) return; if (MT->hasBody() && !MT->isVirtual()) { //Get the source code text of target node auto declaration = stringutils::rangetoStr(*(Result.SourceManager), MT->getSourceRange()); //Perform mutation on the source code text by applying string replacement declaration.insert(declaration.find(\"{\") + 1, \" /*mut9*/[&](){ \"); declaration.insert(declaration.rfind(\"}\"), \" }(); \"); int choice = getrandom::getRandomIndex(1); //Replace the original AST node with the mutated one if (choice) { Rewrite.ReplaceText(CharSourceRange::getTokenRange(MT->getSourceRange()), declaration); } } } } void MutatorFrontendAction__1::MutatorASTConsumer_1::HandleTranslationUnit(ASTContext &Context) { MatchFinder matchFinder; //Define an ASTMatcher to identify the target AST node for mutation. DeclarationMatcher matcher = cxxMethodDecl(unless(cxxConstructorDecl())).bind(\"Methods\"); Callback callback(TheRewriter); matchFinder.addMatcher(matcher, &callback); matchFinder.matchAST(Context); }."}, {"role": "assistant", "content": "//header file #pragma once #include \"Mutator_base.h\" /** * Toggle_Access_Specifier_Constructors_Destructors_10 */ class MutatorFrontendAction_10 : public MutatorFrontendAction { public: MUTATOR_FRONTEND_ACTION_CREATE_ASTCONSUMER(10) private: class MutatorASTConsumer_10 : public MutatorASTConsumer { public: MutatorASTConsumer_10(Rewriter &R) : TheRewriter(R) {} void HandleTranslationUnit(ASTContext &Context) override; private: Rewriter &TheRewriter; }; class Callback : public MatchFinder::MatchCallback { public: Callback(Rewriter &Rewrite) : Rewrite(Rewrite) {} virtual void run(const MatchFinder::MatchResult &Result); private: Rewriter &Rewrite; }; }; //source file #include \"../include/Toggle_Access_Specifier_Constructors_Destructors_10.h\" // ======================================================================================================== #define MUT10_OUTPUT 1 void MutatorFrontendAction_10::Callback::run(const MatchFinder::MatchResult &Result) { if (auto *DL = Result.Nodes.getNodeAs<clang::CXXRecordDecl>(\"Classes\")) { if (!DL || !Result.Context->getSourceManager().isWrittenInMainFile( DL->getLocation())) return; // DL->dump(); if ((!DL->isStruct() && !DL->isClass()) || DL->isLambda()) return; if (DL->isCompleteDefinition() == false) return; auto ctors = DL->ctors(); for (auto ctor : ctors) { if (ctor->isImplicit()) continue; auto acc = ctor->getAccess(); int judge = getrandom::getRandomIndex(1); llvm::outs() << judge << ' '; // if(!judge) continue; if (acc == AccessSpecifier::AS_private || acc == AccessSpecifier::AS_protected) { Rewrite.ReplaceText(ctor->getBeginLoc(), 0, \" /*mut10*/public: \"); } else { Rewrite.ReplaceText(ctor->getBeginLoc(), 0, \" /*mut10*/protected: \"); } } auto dtor = DL->getDestructor(); int judge_dtor = getrandom::getRandomIndex(1); if (judge_dtor && !dtor->isImplicit()) { auto acc = dtor->getAccess(); if (acc == AccessSpecifier::AS_private || acc == AccessSpecifier::AS_protected) { Rewrite.ReplaceText(dtor->getBeginLoc(), 0, \" /*mut10*/public: \"); } else { Rewrite.ReplaceText(dtor->getBeginLoc(), 0, \" /*mut10*/protected: \"); } } } } void MutatorFrontendAction_10::MutatorASTConsumer_10::HandleTranslationUnit(ASTContext &Context) { MatchFinder matchFinder; auto matcher = cxxRecordDecl().bind(\"Classes\"); Callback callback(TheRewriter); matchFinder.addMatcher(matcher, &callback); matchFinder.matchAST(Context); }"}]}
