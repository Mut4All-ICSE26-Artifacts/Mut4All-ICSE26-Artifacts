[
    {
        "mutator_name": "Add_Associated_Const_203",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Add_Associated_Const_203_compling_err_1.rs",
                "errors": "   Compiling windows_x86_64_msvc v0.52.6\n   Compiling proc-macro2 v1.0.92\n   Compiling unicode-ident v1.0.14\n   Compiling shlex v1.3.0\n   Compiling memchr v2.7.4\n   Compiling zerocopy v0.8.24\n   Compiling anstyle v1.0.10\n   Compiling cfg-if v1.0.0\n   Compiling once_cell v1.21.3\n   Compiling utf8parse v0.2.2\n   Compiling is_terminal_polyfill v1.70.1\n   Compiling colorchoice v1.0.3\n   Compiling serde v1.0.219\n   Compiling regex-syntax v0.8.5\n   Compiling heck v0.5.0\n   Compiling prettyplease v0.2.25\n   Compiling getrandom v0.2.15\n   Compiling anstyle-parse v0.2.6\n   Compiling clap_lex v0.7.4\n   Compiling serde_json v1.0.140\n   Compiling tree-sitter-language v0.1.5\n   Compiling cc v1.2.19\n   Compiling rand_core v0.6.4\n   Compiling strsim v0.11.1\n   Compiling itoa v1.0.15\n   Compiling streaming-iterator v0.1.9\n   Compiling ryu v1.0.20\n   Compiling aho-corasick v1.1.3\n   Compiling windows-targets v0.52.6\n   Compiling windows-sys v0.59.0\n   Compiling tree-sitter v0.24.7\n   Compiling tree-sitter-rust v0.23.3\n   Compiling quote v1.0.37\n   Compiling syn v2.0.90\n   Compiling regex-automata v0.4.9\n   Compiling anstyle-query v1.1.2\n   Compiling anstyle-wincon v3.0.7\n   Compiling anstream v0.6.18\n   Compiling clap_builder v4.5.36\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling regex v1.11.1\n   Compiling clap_derive v4.5.32\n   Compiling clap v4.5.36\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0422]: cannot find struct, variant or union type `VisPublic` in crate `syn`\n  --> src\\main.rs:36:63\n   |\n36 | ...                   vis: syn::Visibility::Public(syn::VisPublic {\n   |                                                         ^^^^^^^^^ not found in `syn`\n\nerror[E0063]: missing field `mutability` in initializer of `syn::Field`\n  --> src\\main.rs:34:41\n   |\n34 |                         let new_const = syn::Field {\n   |                                         ^^^^^^^^^^ missing `mutability`\n\nSome errors have detailed explanations: E0063, E0422.\nFor more information about an error, try `rustc --explain E0063`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Add_Associated_Const_203_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0559]: variant `Visibility::Public` has no field named `pub_token`\n  --> src\\main.rs:37:33\n   |\n37 | ...                   pub_token: syn::token::Pub(Span::call_site()),\n   |                       ^^^^^^^^^ field does not exist\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\restriction.rs:16:9\n   |\n16 |         Public(Token![pub]),\n   |         ------ `Visibility::Public` defined here\n   |\nhelp: `Visibility::Public` is a tuple variant, use the appropriate syntax\n   |\n36 -                             vis: syn::Visibility::Public(syn::Visibility::Public {\n37 -                                 pub_token: syn::token::Pub(Span::call_site()),\n38 -                             }),\n36 +                             vis: syn::Visibility::Public(syn::Visibility::Public(/* Pub */)),\n   |\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:36:58\n   |\n36 |   ...                   vis: syn::Visibility::Public(syn::Visibility::Public {\n   |  ____________________________-----------------------_^\n   | |                            |\n   | |                            arguments to this enum variant are incorrect\n37 | | ...                       pub_token: syn::token::Pub(Span::call_site()),\n38 | | ...                   }),\n   | |_______________________^ expected `Pub`, found `Visibility`\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\restriction.rs:16:9\n   |\n16 |         Public(Token![pub]),\n   |         ^^^^^^\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:42:41\n   |\n42 | ...                   mutability: None,\n   |                                   ^^^^ expected `FieldMutability`, found `Option<_>`\n   |\n   = note: expected enum `FieldMutability`\n              found enum `Option<_>`\n\nSome errors have detailed explanations: E0308, E0559.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\add_associated_const_203.rs"
    },
    {
        "mutator_name": "Add_Conflicting_Trait_Bound_235",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Add_Conflicting_Trait_Bound_235_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:32:24\n   |\n32 |                 if let Type::ImplTrait(type_impl_trait) = &type_item.ty {\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ------------- this expression has type `&std::boxed::Box<syn::Type>`\n   |                        |\n   |                        expected `Box<Type>`, found `Type`\n   |\n   = note: expected struct `std::boxed::Box<syn::Type>`\n                found enum `syn::Type`\nhelp: consider dereferencing to access the inner value using the Deref trait\n   |\n32 |                 if let Type::ImplTrait(type_impl_trait) = &*type_item.ty {\n   |                                                            +\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Add_Conflicting_Trait_Bound_235_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:15:37\n   |\n15 |                     new_bounds.push(parse_quote!(Unpin));\n   |                                     ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:3:6\n  |\n3 | impl Mutator for Add_Conflicting_Trait_Bound_235 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n --> src\\main.rs:9:20\n  |\n9 |             if let Item::Type(type_item) = item {\n  |                    ^^^^ use of undeclared type `Item`\n  |\nhelp: consider importing this enum\n  |\n1 + use syn::Item;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:10:24\n   |\n10 |                 if let Type::ImplTrait(type_impl_trait) = &*type_item.ty {\n   |                        ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0412]: cannot find type `Punctuated` in this scope\n  --> src\\main.rs:11:41\n   |\n11 |                     let mut new_bounds: Punctuated<TypeParamBound, Plus> = Punctuated::new();\n   |                                         ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::punctuated::Punctuated;\n   |\n\nerror[E0412]: cannot find type `TypeParamBound` in this scope\n  --> src\\main.rs:11:52\n   |\n11 |                     let mut new_bounds: Punctuated<TypeParamBound, Plus> = Punctuated::new();\n   |                                                    ^^^^^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TypeParamBound;\n   |\n\nerror[E0412]: cannot find type `Plus` in this scope\n  --> src\\main.rs:11:68\n   |\n11 |                     let mut new_bounds: Punctuated<TypeParamBound, Plus> = Punctuated::new();\n   |                                                                    ^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::token::Plus;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Punctuated`\n  --> src\\main.rs:11:76\n   |\n11 |                     let mut new_bounds: Punctuated<TypeParamBound, Plus> = Punctuated::new();\n   |                                                                            ^^^^^^^^^^ use of undeclared type `Punctuated`\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::punctuated::Punctuated;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:16:45\n   |\n16 |                     type_item.ty = Box::new(Type::ImplTrait(TypeImplTrait {\n   |                                             ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypeImplTrait` in this scope\n  --> src\\main.rs:16:61\n   |\n16 |                     type_item.ty = Box::new(Type::ImplTrait(TypeImplTrait {\n   |                                                             ^^^^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypeImplTrait;\n   |\n\nSome errors have detailed explanations: E0405, E0412, E0422, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 10 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\add_conflicting_trait_bound_235.rs"
    },
    {
        "mutator_name": "Add_Const_To_Async_In_Trait_Impl_4",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Add_Const_To_Async_In_Trait_Impl_4_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:34:43\n   |\n34 |                     if let syn::ImplItem::Method(method) = impl_item {\n   |                                           ^^^^^^ variant or associated item not found in `ImplItem`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Add_Const_To_Async_In_Trait_Impl_4_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0432]: unresolved import `syn::ImplItemMethod`\n  --> src\\main.rs:19:15\n   |\n19 |     ImplItem, ImplItemMethod,\n   |               ^^^^^^^^^^^^^^\n   |               |\n   |               no `ImplItemMethod` in the root\n   |               help: a similar name exists in the module: `ImplItemMacro`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:35:38\n   |\n35 |                     if let ImplItem::Method(method) = impl_item {\n   |                                      ^^^^^^ variant or associated item not found in `ImplItem`\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\add_const_to_async_in_trait_impl_4.rs"
    },
    {
        "mutator_name": "Add_Nested_Impl_Trait_185",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Add_Nested_Impl_Trait_185_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0499]: cannot borrow `file.items` as mutable more than once at a time\n  --> src\\main.rs:50:29\n   |\n30 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     first mutable borrow occurs here\n   |                     first borrow later used here\n...\n50 |                             file.items.insert(0, new_trait);\n   |                             ^^^^^^^^^^ second mutable borrow occurs here\n\nerror[E0499]: cannot borrow `file.items` as mutable more than once at a time\n  --> src\\main.rs:59:29\n   |\n30 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     first mutable borrow occurs here\n   |                     first borrow later used here\n...\n59 |                             file.items.push(impl_trait_for_i32);\n   |                             ^^^^^^^^^^ second mutable borrow occurs here\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Add_Nested_Impl_Trait_185_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:26:51\n   |\n26 | ...                   let new_trait: Item = parse_quote! {\n   |                                             ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:33:60\n   |\n33 | ...                   let impl_trait_for_i32: Item = parse_quote! {\n   |                                                      ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:42:57\n   |\n42 | ...                   let new_return_type: Type = parse_quote! {\n   |                                                   ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:48:51\n   |\n48 | ...                   let new_body: Block = parse_quote! {\n   |                                             ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:12:20\n   |\n12 |             if let Item::Fn(item_fn) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `ReturnType`\n  --> src\\main.rs:13:24\n   |\n13 |                 if let ReturnType::Type(_, return_type) = &item_fn.sig.output {\n   |                        ^^^^^^^^^^ use of undeclared type `ReturnType`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::ReturnType;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:14:28\n   |\n14 |                     if let Type::ImplTrait(type_impl_trait) = &**return_type {\n   |                            ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TypeParamBound`\n  --> src\\main.rs:17:36\n   |\n17 | ...                   if let TypeParamBound::Trait(trait_bound) = bound {\n   |                              ^^^^^^^^^^^^^^ use of undeclared type `TypeParamBound`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TypeParamBound;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:25:51\n   |\n25 | ...                   let new_trait_ident = Ident::new(\"AdditionalTrait\", Span::call_site());\n   |                                             ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:25:81\n   |\n25 | ...                   let new_trait_ident = Ident::new(\"AdditionalTrait\", Span::call_site());\n   |                                                                           ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0412]: cannot find type `Item` in this scope\n  --> src\\main.rs:26:44\n   |\n26 | ...                   let new_trait: Item = parse_quote! {\n   |                                      ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0412]: cannot find type `Item` in this scope\n  --> src\\main.rs:33:53\n   |\n33 | ...                   let impl_trait_for_i32: Item = parse_quote! {\n   |                                               ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0412]: cannot find type `Type` in this scope\n  --> src\\main.rs:42:50\n   |\n42 | ...                   let new_return_type: Type = parse_quote! {\n   |                                            ^^^^ not found in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `ReturnType`\n  --> src\\main.rs:45:50\n   |\n45 | ...                   item_fn.sig.output = ReturnType::Type(Default::default(), Box::new(new_return_type));\n   |                                            ^^^^^^^^^^ use of undeclared type `ReturnType`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::ReturnType;\n   |\n\nerror[E0412]: cannot find type `Block` in this scope\n  --> src\\main.rs:48:43\n   |\n48 | ...                   let new_body: Block = parse_quote! {\n   |                                     ^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::Block;\n   |\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 15 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Add_Nested_Impl_Trait_185_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:6:6\n  |\n6 | impl Mutator for Add_Nested_Impl_Trait_185 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\add_nested_impl_trait_185.rs"
    },
    {
        "mutator_name": "Add_Redundant_Generic_135",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Add_Redundant_Generic_135_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0615]: attempted to take value of method `path` on type `&Attribute`\n  --> src\\main.rs:35:33\n   |\n35 |                         if attr.path.is_ident(\"const\") {\n   |                                 ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n35 |                         if attr.path().is_ident(\"const\") {\n   |                                     ++\n\nFor more information about this error, try `rustc --explain E0615`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\add_redundant_generic_135.rs"
    },
    {
        "mutator_name": "Adjust_Const_Generic_Params_143",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\adjust_const_generic_params_143.rs"
    },
    {
        "mutator_name": "Alter_Array_Size_Expression_Using_Generic_Const_Parameters_175",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Alter_Array_Size_Expression_Using_Generic_Const_Parameters_175_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:43:71\n   |\n43 | ...                   if let Expr::Block(expr_block) = &mut *type_array.len {\n   |                                                             ^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:45:59\n   |\n45 | ...                   if let Stmt::Expr(Expr::Path(ExprPath { path, .. })) = expr {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n45 |                                         if let Stmt::Expr(Expr::Path(ExprPath { path, .. }), _) = expr {\n   |                                                                                            +++\n\nSome errors have detailed explanations: E0023, E0614.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Array_Size_Expression_Using_Generic_Const_Parameters_175_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:43:67\n   |\n43 | ...                   if let Expr::Lit(expr_lit) = &mut *type_array.len {\n   |                                                         ^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0614]: type `ExprLit` cannot be dereferenced\n  --> src\\main.rs:46:45\n   |\n46 | ...                   *expr_lit = parse_quote!({ #const_param + 1 });\n   |                       ^^^^^^^^^ can't be dereferenced\n\nFor more information about this error, try `rustc --explain E0614`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Array_Size_Expression_Using_Generic_Const_Parameters_175_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:46:57\n   |\n46 |   ...                   *expr_lit = Expr::Lit(syn::ExprLit {\n   |  _______________________---------___^\n   | |                       |\n   | |                       expected due to the type of this binding\n47 | | ...                       attrs: Vec::new(),\n48 | | ...                       lit: syn::Lit::Verbatim(parse_quote!({ #const_param + 1 })),\n49 | | ...                   });\n   | |________________________^ expected `ExprLit`, found `Expr`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Array_Size_Expression_Using_Generic_Const_Parameters_175_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:46:62\n   |\n46 | ...                   type_array.len = Box::new(Expr::Verbatim(parse_quote!({ #const_param + 1 })));\n   |                       --------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Expr`, found `Box<Expr>`\n   |                       |\n   |                       expected due to the type of this binding\n   |\n   = note: expected enum `syn::Expr`\n            found struct `std::boxed::Box<syn::Expr>`\nhelp: consider unboxing the value\n   |\n46 |                                             type_array.len = *Box::new(Expr::Verbatim(parse_quote!({ #const_param + 1 })));\n   |                                                              +\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\alter_array_size_expression_using_generic_const_parameters_175.rs"
    },
    {
        "mutator_name": "Alter_Array_Size_In_Generic_Constants_169",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Alter_Array_Size_In_Generic_Constants_169_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0594]: cannot assign to `*expr`, which is behind a `&` reference\n  --> src\\main.rs:44:45\n   |\n44 | ...                   *expr = doubled_expr.clone();\n   |                       ^^^^^ `expr` is a `&` reference, so the data it refers to cannot be written\n\nFor more information about this error, try `rustc --explain E0594`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Array_Size_In_Generic_Constants_169_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `args.args` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:36:40\n   |\n36 | ...                   for arg in &mut args.args {\n   |                                  ^^^^^^^^^^^^^^ `args` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Array_Size_In_Generic_Constants_169_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `segment.arguments` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:35:70\n   |\n34 |                     for segment in &path.segments {\n   |                                    -------------- this iterator yields `&` references\n35 |                         if let PathArguments::AngleBracketed(args) = &mut segment.arguments {\n   |                                                                      ^^^^^^^^^^^^^^^^^^^^^^ `segment` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n   |\nhelp: use a mutable iterator instead\n   |\n34 |                     for segment in &mut path.segments {\n   |                                     +++\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Array_Size_In_Generic_Constants_169_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:20:70\n   |\n20 | ...                   let doubled_expr: Expr = parse_quote!(#ident * 2);\n   |                                                ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:21:74\n   |\n21 | ...                   let incremented_expr: Expr = parse_quote!(#ident + 1);\n   |                                                    ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:12:20\n   |\n12 |             if let Item::Impl(item_impl) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `PathArguments`\n  --> src\\main.rs:15:32\n   |\n15 |                         if let PathArguments::AngleBracketed(args) = &mut segment.arguments {\n   |                                ^^^^^^^^^^^^^ use of undeclared type `PathArguments`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::PathArguments;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericArgument`\n  --> src\\main.rs:17:40\n   |\n17 | ...                   if let GenericArgument::Const(expr) = arg {\n   |                              ^^^^^^^^^^^^^^^ use of undeclared type `GenericArgument`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericArgument;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:18:44\n   |\n18 | ...                   if let Expr::Path(expr_path) = expr {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0412]: cannot find type `Expr` in this scope\n  --> src\\main.rs:20:63\n   |\n20 | ...                   let doubled_expr: Expr = parse_quote!(#ident * 2);\n   |                                         ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0412]: cannot find type `Expr` in this scope\n  --> src\\main.rs:21:67\n   |\n21 | ...                   let incremented_expr: Expr = parse_quote!(#ident + 1);\n   |                                             ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericArgument`\n  --> src\\main.rs:24:52\n   |\n24 | ...                   *arg = GenericArgument::Const(doubled_expr.clone());\n   |                              ^^^^^^^^^^^^^^^ use of undeclared type `GenericArgument`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericArgument;\n   |\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 9 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Array_Size_In_Generic_Constants_169_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Alter_Array_Size_In_Generic_Constants_169 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Array_Size_In_Generic_Constants_169_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `path.segments` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:15:36\n   |\n15 |                     for segment in &mut path.segments {\n   |                                    ^^^^^^^^^^^^^^^^^^ `path` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Array_Size_In_Generic_Constants_169_compling_err_7.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:15:59\n   |\n15 |                     let segments: &mut Vec<PathSegment> = &mut path.segments;\n   |                                   ---------------------   ^^^^^^^^^^^^^^^^^^ expected `&mut Vec<PathSegment>`, found `&mut Punctuated<PathSegment, PathSep>`\n   |                                   |\n   |                                   expected due to this\n   |\n   = note: expected mutable reference `&mut Vec<PathSegment>`\n              found mutable reference `&mut syn::punctuated::Punctuated<PathSegment, PathSep>`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\alter_array_size_in_generic_constants_169.rs"
    },
    {
        "mutator_name": "Alter_Closure_Structure_71",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Alter_Closure_Structure_71_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:36:43\n   |\n36 |                         if let Stmt::Expr(Expr::Unsafe(_)) = stmt {\n   |                                           ^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n36 |                         if let Stmt::Expr(Expr::Unsafe(_), _) = stmt {\n   |                                                          +++\n\nFor more information about this error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Closure_Structure_71_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `expr_block.block.stmts` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:42:44\n   |\n42 |                         let unsafe_block = expr_block.block.stmts.remove(0);\n   |                                            ^^^^^^^^^^^^^^^^^^^^^^ `expr_block` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nerror[E0506]: cannot assign to `i.body` because it is borrowed\n  --> src\\main.rs:44:25\n   |\n34 |                 if let Expr::Block(expr_block) = &*i.body {\n   |                                                  -------- `i.body` is borrowed here\n...\n44 |                         i.body = Box::new(parse_quote!({ #closure_body }));\n   |                         ^^^^^^ `i.body` is assigned to here but it was already borrowed\n45 |                         expr_block.block.stmts.insert(0, unsafe_block);\n   |                         ---------------------- borrow later used here\n\nerror[E0596]: cannot borrow `expr_block.block.stmts` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:45:25\n   |\n45 |                         expr_block.block.stmts.insert(0, unsafe_block);\n   |                         ^^^^^^^^^^^^^^^^^^^^^^ `expr_block` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nSome errors have detailed explanations: E0506, E0596.\nFor more information about an error, try `rustc --explain E0506`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Closure_Structure_71_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:36:43\n   |\n36 |                         if let Stmt::Expr(Expr::Unsafe(_)) = stmt {\n   |                                           ^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n36 |                         if let Stmt::Expr(Expr::Unsafe(_), _) = stmt {\n   |                                                          +++\n\nFor more information about this error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Closure_Structure_71_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0502]: cannot borrow `i.body` as immutable because it is also borrowed as mutable\n  --> src\\main.rs:43:44\n   |\n34 |                 if let Expr::Block(expr_block) = &mut *i.body {\n   |                                                  ------------ mutable borrow occurs here\n...\n43 |                         let closure_body = i.body.clone();\n   |                                            ^^^^^^ immutable borrow occurs here\n44 |                         i.body = Box::new(parse_quote!({ #closure_body }));\n45 |                         expr_block.block.stmts.insert(0, unsafe_block);\n   |                         ---------------------- mutable borrow later used here\n\nerror[E0506]: cannot assign to `i.body` because it is borrowed\n  --> src\\main.rs:44:25\n   |\n34 |                 if let Expr::Block(expr_block) = &mut *i.body {\n   |                                                  ------------ `i.body` is borrowed here\n...\n44 |                         i.body = Box::new(parse_quote!({ #closure_body }));\n   |                         ^^^^^^ `i.body` is assigned to here but it was already borrowed\n45 |                         expr_block.block.stmts.insert(0, unsafe_block);\n   |                         ---------------------- borrow later used here\n\nSome errors have detailed explanations: E0502, E0506.\nFor more information about an error, try `rustc --explain E0502`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Closure_Structure_71_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0502]: cannot borrow `i.body` as immutable because it is also borrowed as mutable\n  --> src\\main.rs:43:44\n   |\n34 |                 if let Expr::Block(expr_block) = &mut *i.body {\n   |                                                  ------------ mutable borrow occurs here\n...\n43 |                         let closure_body = i.body.clone();\n   |                                            ^^^^^^ immutable borrow occurs here\n44 |                         i.body = Box::new(parse_quote!({ #closure_body }));\n45 |                         expr_block.block.stmts.insert(0, unsafe_block);\n   |                         ---------------------- mutable borrow later used here\n\nerror[E0506]: cannot assign to `i.body` because it is borrowed\n  --> src\\main.rs:44:25\n   |\n34 |                 if let Expr::Block(expr_block) = &mut *i.body {\n   |                                                  ------------ `i.body` is borrowed here\n...\n44 |                         i.body = Box::new(parse_quote!({ #closure_body }));\n   |                         ^^^^^^ `i.body` is assigned to here but it was already borrowed\n45 |                         expr_block.block.stmts.insert(0, unsafe_block);\n   |                         ---------------------- borrow later used here\n\nSome errors have detailed explanations: E0502, E0506.\nFor more information about an error, try `rustc --explain E0502`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Closure_Structure_71_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:36:43\n   |\n36 |                         if let Stmt::Expr(Expr::Unsafe(_)) = stmt {\n   |                                           ^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n36 |                         if let Stmt::Expr(Expr::Unsafe(_), _) = stmt {\n   |                                                          +++\n\nFor more information about this error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\alter_closure_structure_71.rs"
    },
    {
        "mutator_name": "Alter_Function_Signature_With_Nested_Associated_Type_219",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Alter_Function_Signature_With_Nested_Associated_Type_219_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:29\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                             ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n31 -             if let Item::Fn(ref mut func) = item {\n31 +             if let Item::Fn(func) = item {\n   |\n\nerror[E0502]: cannot borrow `*nested_path` as immutable because it is also borrowed as mutable\n  --> src\\main.rs:40:55\n   |\n37 | ...                   if let Some(last_nested_segment) = nested_path.segments.last_mut() {\n   |                                                          -------------------- mutable borrow occurs here\n38 | ...                       if let PathArguments::AngleBracketed(ref mut nested_args) = last_nested_segment.arguments {\n39 | ...                           nested_args.args.push(GenericArgument::Type(Type::Path(TypePath {\n   |                                                ---- mutable borrow later used by call\n40 | ...                               path: nested_path.clone(),\n   |                                         ^^^^^^^^^^^ immutable borrow occurs here\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Function_Signature_With_Nested_Associated_Type_219_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0502]: cannot borrow `*nested_path` as immutable because it is also borrowed as mutable\n  --> src\\main.rs:39:63\n   |\n37 | ...                   if let Some(last_nested_segment) = nested_path.segments.last_mut() {\n   |                                                          -------------------- mutable borrow occurs here\n38 | ...                       if let PathArguments::AngleBracketed(ref mut nested_args) = last_nested_segment.arguments {\n39 | ...                           let cloned_path = nested_path.clone();\n   |                                                 ^^^^^^^^^^^ immutable borrow occurs here\n40 | ...                           nested_args.args.push(GenericArgument::Type(Type::Path(TypePath {\n   |                               ---------------- mutable borrow later used here\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Function_Signature_With_Nested_Associated_Type_219_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Fn(func) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `FnArg`\n  --> src\\main.rs:12:29\n   |\n12 |                 if let Some(FnArg::Typed(PatType { ty, .. })) = func.sig.inputs.first_mut() {\n   |                             ^^^^^ use of undeclared type `FnArg`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::FnArg;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `PatType` in this scope\n  --> src\\main.rs:12:42\n   |\n12 |                 if let Some(FnArg::Typed(PatType { ty, .. })) = func.sig.inputs.first_mut() {\n   |                                          ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::PatType;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:13:28\n   |\n13 |                     if let Type::Path(TypePath { path, .. }) = &mut **ty {\n   |                            ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypePath` in this scope\n  --> src\\main.rs:13:39\n   |\n13 |                     if let Type::Path(TypePath { path, .. }) = &mut **ty {\n   |                                       ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypePath;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `PathArguments`\n  --> src\\main.rs:15:36\n   |\n15 | ...                   if let PathArguments::AngleBracketed(ref mut args) = last_segment.arguments {\n   |                              ^^^^^^^^^^^^^ use of undeclared type `PathArguments`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::PathArguments;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericArgument`\n  --> src\\main.rs:16:45\n   |\n16 | ...                   if let Some(GenericArgument::Type(Type::Path(TypePath { path: nested_path, .. }))) = args.args.first_mut() {\n   |                                   ^^^^^^^^^^^^^^^ use of undeclared type `GenericArgument`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericArgument;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:16:67\n   |\n16 | ...                   if let Some(GenericArgument::Type(Type::Path(TypePath { path: nested_path, .. }))) = args.args.first_mut() {\n   |                                                         ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypePath` in this scope\n  --> src\\main.rs:16:78\n   |\n16 | ...                   if let Some(GenericArgument::Type(Type::Path(TypePath { path: nested_path, .. }))) = args.args.first_mut() {\n   |                                                                    ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypePath;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `PathArguments`\n  --> src\\main.rs:19:48\n   |\n19 | ...                   if let PathArguments::AngleBracketed(ref mut nested_args) = last_nested_segment.arguments {\n   |                              ^^^^^^^^^^^^^ use of undeclared type `PathArguments`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::PathArguments;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericArgument`\n  --> src\\main.rs:20:67\n   |\n20 | ...                   nested_args.args.push(GenericArgument::Type(Type::Path(TypePath {\n   |                                             ^^^^^^^^^^^^^^^ use of undeclared type `GenericArgument`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericArgument;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:20:89\n   |\n20 | ...                   nested_args.args.push(GenericArgument::Type(Type::Path(TypePath {\n   |                                                                   ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypePath` in this scope\n  --> src\\main.rs:20:100\n   |\n20 | ...                   nested_args.args.push(GenericArgument::Type(Type::Path(TypePath {\n   |                                                                              ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypePath;\n   |\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 13 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Function_Signature_With_Nested_Associated_Type_219_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `mutate` found for struct `Alter_Function_Signature_With_Nested_Associated_Type_219` in the current scope\n  --> src\\main.rs:60:70\n   |\n3  | pub struct Alter_Function_Signature_With_Nested_Associated_Type_219;\n   | ------------------------------------------------------------------- method `mutate` not found for this struct\n...\n60 |             Alter_Function_Signature_With_Nested_Associated_Type_219.mutate(&mut file_ast);\n   |                                                                      ^^^^^^ method not found in `Alter_Function_Signature_With_Nested_Associated_Type_219`\n   |\n  ::: src\\mutator.rs:15:8\n   |\n15 |     fn mutate(&self, file: &mut syn::File);\n   |        ------ the method is available for `Alter_Function_Signature_With_Nested_Associated_Type_219` here\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: trait `Mutator` which provides `mutate` is implemented but not in scope; perhaps you want to import it\n   |\n1  + use crate::mutator::Mutator;\n   |\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\alter_function_signature_with_nested_associated_type_219.rs"
    },
    {
        "mutator_name": "Alter_Lifetime_Annotations_7",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\alter_lifetime_annotations_7.rs"
    },
    {
        "mutator_name": "Alter_Lifetime_Annotations_93",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Alter_Lifetime_Annotations_93_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:32:29\n   |\n32 |                 if let Some((_, ref generics, _, _)) = &item_impl.trait_ {\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^    ----------------- this expression has type `&Option<(Option<syn::token::Not>, syn::Path, For)>`\n   |                             |\n   |                             expected a tuple with 3 elements, found one with 4 elements\n   |\n   = note: expected tuple `(Option<syn::token::Not>, syn::Path, For)`\n              found tuple `(_, _, _, _)`\n\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:43:73\n   |\n43 | ...                   if let Type::Reference(type_ref) = &mut *impl_type.ty {\n   |                                                               ^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0609]: no field `lifetime` on type `&mut syn::Lifetime`\n  --> src\\main.rs:45:71\n   |\n45 | ...                   if lifetime.ident == lifetime.lifetime.ident {\n   |                                                     ^^^^^^^^ unknown field\n   |\n   = note: available fields are: `apostrophe`, `ident`\n\nSome errors have detailed explanations: E0308, E0609, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Lifetime_Annotations_93_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0609]: no field `params` on type `&syn::Path`\n  --> src\\main.rs:33:54\n   |\n33 |                     if let Some(lifetime) = generics.params.iter().find_map(|param| {\n   |                                                      ^^^^^^ unknown field\n   |\n   = note: available fields are: `leading_colon`, `segments`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Lifetime_Annotations_93_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Impl(item_impl) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `PathArguments`\n  --> src\\main.rs:14:32\n   |\n14 |                         if let PathArguments::AngleBracketed(ref data) = segment.arguments {\n   |                                ^^^^^^^^^^^^^ use of undeclared type `PathArguments`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::PathArguments;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericArgument`\n  --> src\\main.rs:16:40\n   |\n16 | ...                   if let GenericArgument::Lifetime(lifetime) = arg {\n   |                              ^^^^^^^^^^^^^^^ use of undeclared type `GenericArgument`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericArgument;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Lifetime`\n  --> src\\main.rs:26:44\n   |\n26 |                         let new_lifetime = Lifetime::new(\"'b\", Span::call_site());\n   |                                            ^^^^^^^^ use of undeclared type `Lifetime`\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::Lifetime;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:26:64\n   |\n26 |                         let new_lifetime = Lifetime::new(\"'b\", Span::call_site());\n   |                                                                ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:29:40\n   |\n29 | ...                   if let Type::Reference(type_ref) = &mut impl_type.ty {\n   |                              ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nFor more information about this error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 6 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Lifetime_Annotations_93_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `mutate` found for struct `Alter_Lifetime_Annotations_93` in the current scope\n  --> src\\main.rs:70:43\n   |\n4  | pub struct Alter_Lifetime_Annotations_93;\n   | ---------------------------------------- method `mutate` not found for this struct\n...\n70 |             Alter_Lifetime_Annotations_93.mutate(&mut file_ast);\n   |                                           ^^^^^^ method not found in `Alter_Lifetime_Annotations_93`\n   |\n  ::: src\\mutator.rs:15:8\n   |\n15 |     fn mutate(&self, file: &mut syn::File);\n   |        ------ the method is available for `Alter_Lifetime_Annotations_93` here\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: trait `Mutator` which provides `mutate` is implemented but not in scope; perhaps you want to import it\n   |\n1  + use crate::mutator::Mutator;\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:13:33\n   |\n13 |                 if let Some((_, ref path, _)) = &item_impl.trait_ {\n   |                                 ^^^ binding modifier not allowed under `ref` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:13:24\n   |\n13 |                 if let Some((_, ref path, _)) = &item_impl.trait_ {\n   |                        ^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&_`\nhelp: remove the unnecessary binding modifier\n   |\n13 -                 if let Some((_, ref path, _)) = &item_impl.trait_ {\n13 +                 if let Some((_, path, _)) = &item_impl.trait_ {\n   |\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\alter_lifetime_annotations_93.rs"
    },
    {
        "mutator_name": "Alter_Loop_Break_Value_18",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Alter_Loop_Break_Value_18_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0408]: variable `expr_loop` is not bound in all patterns\n  --> src\\main.rs:37:36\n   |\n37 | ...                   if let Stmt::Expr(Expr::While(expr_while)) | Stmt::Expr(Expr::Loop(expr_loop)) = stmt {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^                         --------- variable not in all patterns\n   |                              |\n   |                              pattern doesn't bind `expr_loop`\n\nerror[E0408]: variable `expr_while` is not bound in all patterns\n  --> src\\main.rs:37:74\n   |\n37 | ...                   if let Stmt::Expr(Expr::While(expr_while)) | Stmt::Expr(Expr::Loop(expr_loop)) = stmt {\n   |                                                     ----------     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern doesn't bind `expr_while`\n   |                                                     |\n   |                                                     variable not in all patterns\n\nerror[E0615]: attempted to take value of method `path` on type `&Attribute`\n  --> src\\main.rs:35:64\n   |\n35 |                     if expr_block.attrs.iter().any(|attr| attr.path.is_ident(\"const\")) {\n   |                                                                ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n35 |                     if expr_block.attrs.iter().any(|attr| attr.path().is_ident(\"const\")) {\n   |                                                                    ++\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:37:47\n   |\n37 | ...                   if let Stmt::Expr(Expr::While(expr_while)) | Stmt::Expr(Expr::Loop(expr_loop)) = stmt {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n37 |                             if let Stmt::Expr(Expr::While(expr_while), _) | Stmt::Expr(Expr::Loop(expr_loop)) = stmt {\n   |                                                                      +++\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:37:85\n   |\n37 | ...                   if let Stmt::Expr(Expr::While(expr_while)) | Stmt::Expr(Expr::Loop(expr_loop)) = stmt {\n   |                                                                               ^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n37 |                             if let Stmt::Expr(Expr::While(expr_while)) | Stmt::Expr(Expr::Loop(expr_loop), _) = stmt {\n   |                                                                                                          +++\n\nerror[E0599]: no variant or associated item named `Semi` found for enum `Stmt` in the current scope\n  --> src\\main.rs:40:69\n   |\n40 | ...                   .filter_map(|stmt| if let Stmt::Semi(Expr::Break(expr_break), _) = stmt {\n   |                                                       ^^^^ variant or associated item not found in `Stmt`\n\nSome errors have detailed explanations: E0023, E0408, E0599, E0615.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 6 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Loop_Break_Value_18_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0408]: variable `expr_loop` is not bound in all patterns\n  --> src\\main.rs:37:36\n   |\n37 | ...                   if let Stmt::Expr(Expr::While(expr_while), _) | Stmt::Expr(Expr::Loop(expr_loop), _) = stmt {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^                         --------- variable not in all patterns\n   |                              |\n   |                              pattern doesn't bind `expr_loop`\n\nerror[E0408]: variable `expr_while` is not bound in all patterns\n  --> src\\main.rs:37:77\n   |\n37 | ...                   if let Stmt::Expr(Expr::While(expr_while), _) | Stmt::Expr(Expr::Loop(expr_loop), _) = stmt {\n   |                                                     ----------        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern doesn't bind `expr_while`\n   |                                                     |\n   |                                                     variable not in all patterns\n\nerror[E0505]: cannot move out of `stmt` because it is borrowed\n  --> src\\main.rs:45:47\n   |\n44 | ...                   .filter_map(|stmt| if let Stmt::Expr(Expr::Break(expr_break), _) = stmt {\n   |                                        -                               ---------- borrow of `stmt.0.0` occurs here\n   |                                        |\n   |                                        return type of closure is Option<(&mut Stmt, &'1 mut ExprBreak)>\n45 | ...                       Some((stmt, expr_break))\n   |                           ------^^^^--------------\n   |                           |     |\n   |                           |     move out of `stmt` occurs here\n   |                           returning this value requires that `stmt.0.0` is borrowed for `'1`\n\nerror[E0384]: cannot assign twice to immutable variable `expr_loop`\n  --> src\\main.rs:37:99\n   |\n37 | ...                   if let Stmt::Expr(Expr::While(expr_while), _) | Stmt::Expr(Expr::Loop(expr_loop), _) = stmt {\n   |                                                                                             ^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0503]: cannot use `*stmt` because it was mutably borrowed\n  --> src\\main.rs:38:93\n   |\n37 | ...                   if let Stmt::Expr(Expr::While(expr_while), _) | Stmt::Expr(Expr::Loop(expr_loop), _) = stmt {\n   |                                                                                             --------- `stmt.0.0` is borrowed here\n38 | ...                       let stmts = if let Stmt::Expr(Expr::While(expr_while), _) = stmt {\n   |                                                                                       ^^^^ use of borrowed `stmt.0.0`\n...\n41 | ...                           &mut expr_loop.body.stmts\n   |                               ------------------------- borrow later used here\n\nerror[E0503]: cannot use `stmt.0` because it was mutably borrowed\n  --> src\\main.rs:38:93\n   |\n37 | ...                   if let Stmt::Expr(Expr::While(expr_while), _) | Stmt::Expr(Expr::Loop(expr_loop), _) = stmt {\n   |                                                                                             --------- `stmt.0.0` is borrowed here\n38 | ...                       let stmts = if let Stmt::Expr(Expr::While(expr_while), _) = stmt {\n   |                                                                                       ^^^^ use of borrowed `stmt.0.0`\n...\n41 | ...                           &mut expr_loop.body.stmts\n   |                               ------------------------- borrow later used here\n\nerror[E0381]: used binding `expr_loop` is possibly-uninitialized\n  --> src\\main.rs:41:37\n   |\n37 | ...                   if let Stmt::Expr(Expr::While(expr_while), _) | Stmt::Expr(Expr::Loop(expr_loop), _) = stmt {\n   |                                                                                             ---------\n   |                                                                                             |\n   |                                                                                             binding initialized here in some conditions\n   |                                                                                             binding declared here but left uninitialized\n...\n41 | ...                           &mut expr_loop.body.stmts\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^ `expr_loop.body.stmts` used here but it is possibly-uninitialized\n\nSome errors have detailed explanations: E0381, E0384, E0408, E0503, E0505.\nFor more information about an error, try `rustc --explain E0381`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 7 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Loop_Break_Value_18_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:27:93\n   |\n27 | ...                   break_expr.expr = Some(Box::new(Expr::Tuple(parse_quote!(()))));\n   |                                                                   ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:39:93\n   |\n39 | ...                   break_expr.expr = Some(Box::new(Expr::Tuple(parse_quote!(()))));\n   |                                                                   ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0405]: cannot find trait `VisitMut` in this scope\n  --> src\\main.rs:12:14\n   |\n12 |         impl VisitMut for LoopVisitor {\n   |              ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this trait\n   |\n1  + use syn::visit_mut::VisitMut;\n   |\n\nerror[E0412]: cannot find type `Expr` in this scope\n  --> src\\main.rs:13:53\n   |\n13 |             fn visit_expr_mut(&mut self, expr: &mut Expr) {\n   |                                                     ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:14:24\n   |\n14 |                 if let Expr::Block(expr_block) = expr {\n   |                        ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:17:36\n   |\n17 | ...                   if let Stmt::Expr(expr_stmt) = stmt {\n   |                              ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:18:40\n   |\n18 | ...                   if let Expr::While(expr_while) = expr_stmt {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:21:67\n   |\n21 | ...                   .filter_map(|stmt| if let Stmt::Expr(Expr::Break(expr_break)) = stmt {\n   |                                                 ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:21:78\n   |\n21 | ...                   .filter_map(|stmt| if let Stmt::Expr(Expr::Break(expr_break)) = stmt {\n   |                                                            ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:27:81\n   |\n27 | ...                   break_expr.expr = Some(Box::new(Expr::Tuple(parse_quote!(()))));\n   |                                                       ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:30:47\n   |\n30 | ...                   } else if let Expr::Loop(expr_loop) = expr_stmt {\n   |                                     ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:33:67\n   |\n33 | ...                   .filter_map(|stmt| if let Stmt::Expr(Expr::Break(expr_break)) = stmt {\n   |                                                 ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:33:78\n   |\n33 | ...                   .filter_map(|stmt| if let Stmt::Expr(Expr::Break(expr_break)) = stmt {\n   |                                                            ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:39:81\n   |\n39 | ...                   break_expr.expr = Some(Box::new(Expr::Tuple(parse_quote!(()))));\n   |                                                       ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nSome errors have detailed explanations: E0405, E0412, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 14 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Loop_Break_Value_18_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Alter_Loop_Break_Value_18 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Loop_Break_Value_18_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:18:47\n   |\n18 | ...                   if let Stmt::Expr(expr_stmt) = stmt {\n   |                                         ^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n18 |                             if let Stmt::Expr(expr_stmt, _) = stmt {\n   |                                                        +++\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:22:78\n   |\n22 | ...                   .filter_map(|stmt| if let Stmt::Expr(Expr::Break(expr_break)) = stmt {\n   |                                                            ^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n22 |                                         .filter_map(|stmt| if let Stmt::Expr(Expr::Break(expr_break), _) = stmt {\n   |                                                                                                     +++\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:34:78\n   |\n34 | ...                   .filter_map(|stmt| if let Stmt::Expr(Expr::Break(expr_break)) = stmt {\n   |                                                            ^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n34 |                                         .filter_map(|stmt| if let Stmt::Expr(Expr::Break(expr_break), _) = stmt {\n   |                                                                                                     +++\n\nFor more information about this error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Loop_Break_Value_18_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0505]: cannot move out of `stmt` because it is borrowed\n  --> src\\main.rs:23:51\n   |\n22 | ...                   .filter_map(|stmt| if let Stmt::Expr(Expr::Break(expr_break), _) = stmt {\n   |                                        -                               ---------- borrow of `stmt.0.0` occurs here\n   |                                        |\n   |                                        return type of closure is Option<(&mut Stmt, &'1 mut ExprBreak)>\n23 | ...                       Some((stmt, expr_break))\n   |                           ------^^^^--------------\n   |                           |     |\n   |                           |     move out of `stmt` occurs here\n   |                           returning this value requires that `stmt.0.0` is borrowed for `'1`\n\nerror[E0505]: cannot move out of `stmt` because it is borrowed\n  --> src\\main.rs:35:51\n   |\n34 | ...                   .filter_map(|stmt| if let Stmt::Expr(Expr::Break(expr_break), _) = stmt {\n   |                                        -                               ---------- borrow of `stmt.0.0` occurs here\n   |                                        |\n   |                                        return type of closure is Option<(&mut Stmt, &'1 mut ExprBreak)>\n35 | ...                       Some((stmt, expr_break))\n   |                           ------^^^^--------------\n   |                           |     |\n   |                           |     move out of `stmt` occurs here\n   |                           returning this value requires that `stmt.0.0` is borrowed for `'1`\n\nFor more information about this error, try `rustc --explain E0505`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Loop_Break_Value_18_compling_err_7.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:18:47\n   |\n18 | ...                   if let Stmt::Expr(expr_stmt) = stmt {\n   |                                         ^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n18 |                             if let Stmt::Expr(expr_stmt, _) = stmt {\n   |                                                        +++\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:22:78\n   |\n22 | ...                   .filter_map(|stmt| if let Stmt::Expr(Expr::Break(expr_break)) = stmt {\n   |                                                            ^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n22 |                                         .filter_map(|stmt| if let Stmt::Expr(Expr::Break(expr_break), _) = stmt {\n   |                                                                                                     +++\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:34:78\n   |\n34 | ...                   .filter_map(|stmt| if let Stmt::Expr(Expr::Break(expr_break)) = stmt {\n   |                                                            ^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n34 |                                         .filter_map(|stmt| if let Stmt::Expr(Expr::Break(expr_break), _) = stmt {\n   |                                                                                                     +++\n\nFor more information about this error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\alter_loop_break_value_18.rs"
    },
    {
        "mutator_name": "Alter_Macro_Path_96",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\alter_macro_path_96.rs"
    },
    {
        "mutator_name": "Alter_Trait_Bounds_179",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\alter_trait_bounds_179.rs"
    },
    {
        "mutator_name": "Alter_Type_Aliases_In_Structs_102",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Alter_Type_Aliases_In_Structs_102_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n  --> src\\main.rs:30:34\n   |\n30 |         let mut type_alias_map = HashMap::new();\n   |                                  ^^^^^^^ use of undeclared type `HashMap`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use crate::collections::HashMap;\n   |\n1  + use std::collections::HashMap;\n   |\n\nFor more information about this error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Type_Aliases_In_Structs_102_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Alter_Type_Aliases_In_Structs_102 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:13:20\n   |\n13 |             if let Item::Type(item_type) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:21:20\n   |\n21 |             if let Item::Struct(item_struct) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:23:28\n   |\n23 |                     if let Type::Path(TypePath { path, .. }) = &field.ty {\n   |                            ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypePath` in this scope\n  --> src\\main.rs:23:39\n   |\n23 |                     if let Type::Path(TypePath { path, .. }) = &field.ty {\n   |                                       ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypePath;\n   |\n\nSome errors have detailed explanations: E0405, E0422, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 5 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Type_Aliases_In_Structs_102_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:27:44\n   |\n27 | ...                   field.ty = expanded_type.clone();\n   |                       --------   ^^^^^^^^^^^^^^^^^^^^^ expected `Type`, found `Box<Type>`\n   |                       |\n   |                       expected due to the type of this binding\n   |\n   = note: expected enum `syn::Type`\n            found struct `std::boxed::Box<syn::Type>`\nhelp: consider unboxing the value\n   |\n27 |                                 field.ty = *expanded_type.clone();\n   |                                            +\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\alter_type_aliases_in_structs_102.rs"
    },
    {
        "mutator_name": "Alter_Type_Alias_With_Trait_Bounds_239",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Alter_Type_Alias_With_Trait_Bounds_239_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:32:24\n   |\n32 |                 if let Type::ImplTrait(type_impl_trait) = &type_item.ty {\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ------------- this expression has type `&std::boxed::Box<syn::Type>`\n   |                        |\n   |                        expected `Box<Type>`, found `Type`\n   |\n   = note: expected struct `std::boxed::Box<syn::Type>`\n                found enum `syn::Type`\nhelp: consider dereferencing to access the inner value using the Deref trait\n   |\n32 |                 if let Type::ImplTrait(type_impl_trait) = &*type_item.ty {\n   |                                                            +\n\nerror[E0063]: missing field `impl_token` in initializer of `TypeImplTrait`\n  --> src\\main.rs:41:65\n   |\n41 |                         type_item.ty = Box::new(Type::ImplTrait(TypeImplTrait {\n   |                                                                 ^^^^^^^^^^^^^ missing `impl_token`\n\nSome errors have detailed explanations: E0063, E0308.\nFor more information about an error, try `rustc --explain E0063`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Type_Alias_With_Trait_Bounds_239_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.76s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:35:64:\nexpected identifier\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\alter_type_alias_with_trait_bounds_239.rs"
    },
    {
        "mutator_name": "Array_Index_Overflow_46",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Array_Index_Overflow_46_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:50:43\n   |\n50 |                         if let Stmt::Expr(Expr::Unsafe(expr_unsafe)) = stmt {\n   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n50 |                         if let Stmt::Expr(Expr::Unsafe(expr_unsafe), _) = stmt {\n   |                                                                    +++\n\nerror[E0614]: type `syn::Block` cannot be dereferenced\n  --> src\\main.rs:51:68\n   |\n51 | ...                   UnsafeArrayVisitor.visit_expr_mut(&mut *expr_unsafe.block);\n   |                                                              ^^^^^^^^^^^^^^^^^^ can't be dereferenced\n\nSome errors have detailed explanations: E0023, E0614.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Array_Index_Overflow_46_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n   --> src\\main.rs:51:63\n    |\n51  | ...                   UnsafeArrayVisitor.visit_expr_mut(&mut expr_unsafe.block);\n    |                                          -------------- ^^^^^^^^^^^^^^^^^^^^^^ expected `&mut Expr`, found `&mut Block`\n    |                                          |\n    |                                          arguments to this method are incorrect\n    |\n    = note: expected mutable reference `&mut syn::Expr`\n               found mutable reference `&mut syn::Block`\nnote: method defined here\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\gen\\visit_mut.rs:142:8\n    |\n142 |     fn visit_expr_mut(&mut self, i: &mut crate::Expr) {\n    |        ^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Array_Index_Overflow_46_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:50:43\n   |\n50 |                         if let Stmt::Expr(Expr::Unsafe(expr_unsafe)) = stmt {\n   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n50 |                         if let Stmt::Expr(Expr::Unsafe(expr_unsafe), _) = stmt {\n   |                                                                    +++\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:52:51\n   |\n52 | ...                   if let Stmt::Expr(ref mut inner_expr) = expr {\n   |                                         ^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n52 |                                 if let Stmt::Expr(ref mut inner_expr, _) = expr {\n   |                                                                     +++\n\nFor more information about this error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Array_Index_Overflow_46_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:52:51\n   |\n52 | ...                   if let Stmt::Expr(ref mut inner_expr, _) = expr {\n   |                                         ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:52:40\n   |\n52 | ...                   if let Stmt::Expr(ref mut inner_expr, _) = expr {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n52 -                                 if let Stmt::Expr(ref mut inner_expr, _) = expr {\n52 +                                 if let Stmt::Expr(inner_expr, _) = expr {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\array_index_overflow_46.rs"
    },
    {
        "mutator_name": "Async_Function_Await_Manipulation_1",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Async_Function_Await_Manipulation_1_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0063]: missing field `dot_token` in initializer of `syn::ExprAwait`\n  --> src\\main.rs:43:68\n   |\n43 | ...                   let new_expr = Expr::Await(ExprAwait {\n   |                                                  ^^^^^^^^^ missing `dot_token`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:53:60\n   |\n53 | ...                   *expr_await.base = Box::new(new_expr);\n   |                       ----------------   ^^^^^^^^^^^^^^^^^^ expected `Expr`, found `Box<Expr>`\n   |                       |\n   |                       expected due to the type of this binding\n   |\n   = note: expected enum `syn::Expr`\n            found struct `std::boxed::Box<syn::Expr>`\nhelp: consider unboxing the value\n   |\n53 |                                         *expr_await.base = *Box::new(new_expr);\n   |                                                            +\n\nSome errors have detailed explanations: E0063, E0308.\nFor more information about an error, try `rustc --explain E0063`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Async_Function_Await_Manipulation_1_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0594]: cannot assign to `*expr_await.base`, as `expr_await` is not declared as mutable\n  --> src\\main.rs:54:41\n   |\n54 | ...                   *expr_await.base = new_expr;\n   |                       ^^^^^^^^^^^^^^^^ cannot assign\n   |\nhelp: consider changing this to be mutable\n   |\n40 |                             if let Expr::Await(mut expr_await) = expr {\n   |                                                +++\n\nFor more information about this error, try `rustc --explain E0594`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\async_function_await_manipulation_1.rs"
    },
    {
        "mutator_name": "Async_Function_3",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\async_function_3.rs"
    },
    {
        "mutator_name": "Change_Struct_Field_Type_38",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\change_struct_field_type_38.rs"
    },
    {
        "mutator_name": "Change_Trait_Impl_Const_Generic_194",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [],
        "label": "Negative",
        "file": ".\\mutators\\change_trait_impl_const_generic_194.rs"
    },
    {
        "mutator_name": "Change_Type_Alias_Impl_Trait_238",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Change_Type_Alias_Impl_Trait_238_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:51:70\n   |\n51 | ...                   new_items.push(Stmt::Item(Item::Type(new_type_alias)));\n   |                                                 ---------- ^^^^^^^^^^^^^^ expected `ItemType`, found `Item`\n   |                                                 |\n   |                                                 arguments to this enum variant are incorrect\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\item.rs:70:9\n   |\n70 |         Type(ItemType),\n   |         ^^^^\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\change_type_alias_impl_trait_238.rs"
    },
    {
        "mutator_name": "Conditional_Associated_Type_210",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\conditional_associated_type_210.rs"
    },
    {
        "mutator_name": "Const_Complexity_Mutator_41",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Const_Complexity_Mutator_41_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:32:24\n   |\n32 |                 if let Expr::Lit(expr_lit) = &item_const.expr {\n   |                        ^^^^^^^^^^^^^^^^^^^   ---------------- this expression has type `&std::boxed::Box<syn::Expr>`\n   |                        |\n   |                        expected `Box<Expr>`, found `Expr`\n   |\n   = note: expected struct `std::boxed::Box<syn::Expr>`\n                found enum `syn::Expr`\nhelp: consider dereferencing to access the inner value using the Deref trait\n   |\n32 |                 if let Expr::Lit(expr_lit) = &*item_const.expr {\n   |                                               +\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Const_Complexity_Mutator_41_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:15:50\n   |\n15 | ...                   let new_expr: Expr = parse_quote! {\n   |                                            ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Const(item_const) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:12:24\n   |\n12 |                 if let Expr::Lit(expr_lit) = &*item_const.expr {\n   |                        ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0412]: cannot find type `Expr` in this scope\n  --> src\\main.rs:15:43\n   |\n15 | ...                   let new_expr: Expr = parse_quote! {\n   |                                     ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Const_Complexity_Mutator_41_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Const_Complexity_Mutator_41 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\const_complexity_mutator_41.rs"
    },
    {
        "mutator_name": "Const_Parameter_Misplacement_204",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\const_parameter_misplacement_204.rs"
    },
    {
        "mutator_name": "Dereference_Unsupported_Types_22",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Dereference_Unsupported_Types_22_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:32\n   |\n31 |             if let Item::Const(ref mut const_item) = item {\n   |                                ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Const(ref mut const_item) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n31 -             if let Item::Const(ref mut const_item) = item {\n31 +             if let Item::Const(const_item) = item {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:41:40\n   |\n41 |             } else if let Item::Static(ref mut static_item) = item {\n   |                                        ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:41:27\n   |\n41 |             } else if let Item::Static(ref mut static_item) = item {\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n41 -             } else if let Item::Static(ref mut static_item) = item {\n41 +             } else if let Item::Static(static_item) = item {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Dereference_Unsupported_Types_22_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:16:50\n   |\n16 | ...                   let new_expr: Expr = parse_quote!(*#const_item.expr);\n   |                                            ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:26:50\n   |\n26 | ...                   let new_expr: Expr = parse_quote!(*#static_item.expr);\n   |                                            ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Const(const_item) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:12:24\n   |\n12 |                 if let Type::Path(TypePath { path, .. }) = &*const_item.ty {\n   |                        ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypePath` in this scope\n  --> src\\main.rs:12:35\n   |\n12 |                 if let Type::Path(TypePath { path, .. }) = &*const_item.ty {\n   |                                   ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypePath;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:15:32\n   |\n15 |                         if let Expr::Lit(_) = *const_item.expr {\n   |                                ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0412]: cannot find type `Expr` in this scope\n  --> src\\main.rs:16:43\n   |\n16 | ...                   let new_expr: Expr = parse_quote!(*#const_item.expr);\n   |                                     ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:21:27\n   |\n21 |             } else if let Item::Static(static_item) = item {\n   |                           ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:22:24\n   |\n22 |                 if let Type::Path(TypePath { path, .. }) = &*static_item.ty {\n   |                        ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypePath` in this scope\n  --> src\\main.rs:22:35\n   |\n22 |                 if let Type::Path(TypePath { path, .. }) = &*static_item.ty {\n   |                                   ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypePath;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:25:32\n   |\n25 |                         if let Expr::Lit(_) = *static_item.expr {\n   |                                ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0412]: cannot find type `Expr` in this scope\n  --> src\\main.rs:26:43\n   |\n26 | ...                   let new_expr: Expr = parse_quote!(*#static_item.expr);\n   |                                     ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nSome errors have detailed explanations: E0412, E0422, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 12 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Dereference_Unsupported_Types_22_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Dereference_Unsupported_Types_22 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\dereference_unsupported_types_22.rs"
    },
    {
        "mutator_name": "Enum_Const_Expr_Cycle_140",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Enum_Const_Expr_Cycle_140_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0502]: cannot borrow `item_enum` as immutable because it is also borrowed as mutable\n  --> src\\main.rs:44:54\n   |\n41 |                       for variant in &mut item_enum.variants {\n   |                                      -----------------------\n   |                                      |\n   |                                      mutable borrow occurs here\n   |                                      mutable borrow later used here\n...\n44 |                                   let new_expr: Expr = parse_quote! {\n   |  ______________________________________________________^\n45 | |                                     #item_enum::#variant as u8 - 1\n46 | |                                 };\n   | |_________________________________^ immutable borrow occurs here\n   |\n   = note: this error originates in the macro `$crate::quote_token_with_context` which comes from the expansion of the macro `parse_quote` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Enum_Const_Expr_Cycle_140_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:25:54\n   |\n25 | ...                   let new_expr: Expr = parse_quote! {\n   |                                            ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Enum(item_enum) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:14:37\n   |\n14 |                     if let Some((_, Expr::Path(expr_path))) = &variant.discriminant {\n   |                                     ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:22:41\n   |\n22 |                         if let Some((_, Expr::Path(expr_path))) = &variant.discriminant {\n   |                                         ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0412]: cannot find type `Expr` in this scope\n  --> src\\main.rs:25:47\n   |\n25 | ...                   let new_expr: Expr = parse_quote! {\n   |                                     ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `token`\n  --> src\\main.rs:28:62\n   |\n28 | ...                   variant.discriminant = Some((token::Eq::default(), new_expr));\n   |                                                    ^^^^^ use of unresolved module or unlinked crate `token`\n   |\n   = help: if you wanted to use a crate named `token`, use `cargo add token` to add it to your `Cargo.toml`\nhelp: consider importing one of these items\n   |\n1  + use std::cmp::Eq;\n   |\n1  + use syn::token::Eq;\n   |\nhelp: if you import `Eq`, refer to it directly\n   |\n28 -                                 variant.discriminant = Some((token::Eq::default(), new_expr));\n28 +                                 variant.discriminant = Some((Eq::default(), new_expr));\n   |\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 6 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Enum_Const_Expr_Cycle_140_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Enum_Const_Expr_Cycle_140 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Enum_Const_Expr_Cycle_140_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0502]: cannot borrow `item_enum` as immutable because it is also borrowed as mutable\n  --> src\\main.rs:26:54\n   |\n22 |                       for variant in &mut item_enum.variants {\n   |                                      -----------------------\n   |                                      |\n   |                                      mutable borrow occurs here\n   |                                      mutable borrow later used here\n...\n26 |                                   let new_expr: Expr = parse_quote! {\n   |  ______________________________________________________^\n27 | |                                     #item_enum::#variant_ident as u8 - 1\n28 | |                                 };\n   | |_________________________________^ immutable borrow occurs here\n   |\n   = note: this error originates in the macro `$crate::quote_token_with_context` which comes from the expansion of the macro `parse_quote` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Enum_Const_Expr_Cycle_140_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0277]: can't compare `syn::Ident` with `&syn::Ident`\n  --> src\\main.rs:25:83\n   |\n25 | ...                   if expr_path.path.segments.iter().any(|seg| seg.ident == enum_ident) {\n   |                                                                             ^^ no implementation for `syn::Ident == &syn::Ident`\n   |\n   = help: the trait `AsRef<str>` is not implemented for `syn::Ident`\n   = note: required for `&syn::Ident` to implement `AsRef<str>`\n   = note: required for `syn::Ident` to implement `PartialEq<&syn::Ident>`\nhelp: consider dereferencing here\n   |\n25 |                             if expr_path.path.segments.iter().any(|seg| seg.ident == *enum_ident) {\n   |                                                                                      +\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\enum_const_expr_cycle_140.rs"
    },
    {
        "mutator_name": "Enum_Variant_Overloading_43",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\enum_variant_overloading_43.rs"
    },
    {
        "mutator_name": "Enum_With_Exotic_Discriminant_31",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Enum_With_Exotic_Discriminant_31_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0615]: attempted to take value of method `path` on type `&&Attribute`\n  --> src\\main.rs:32:77\n   |\n32 |                 if let Some(attr) = item_enum.attrs.iter().find(|attr| attr.path.is_ident(\"repr\")) {\n   |                                                                             ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n32 |                 if let Some(attr) = item_enum.attrs.iter().find(|attr| attr.path().is_ident(\"repr\")) {\n   |                                                                                 ++\n\nerror[E0599]: no method named `parse_meta` found for reference `&Attribute` in the current scope\n   --> src\\main.rs:33:44\n    |\n33  |                     if let Ok(meta) = attr.parse_meta() {\n    |                                            ^^^^^^^^^^\n    |\nhelp: there is a method `parse_nested_meta` with a similar name, but with different arguments\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\attr.rs:391:5\n    |\n391 | /     pub fn parse_nested_meta(\n392 | |         &self,\n393 | |         logic: impl FnMut(ParseNestedMeta) -> Result<()>,\n394 | |     ) -> Result<()> {\n    | |___________________^\n\nerror[E0609]: no field `nested` on type `MetaList`\n  --> src\\main.rs:35:42\n   |\n35 | ...                   if meta_list.nested.iter().any(|nested| match nested {\n   |                                    ^^^^^^ unknown field\n   |\n   = note: available fields are: `path`, `delimiter`, `tokens`\n\nerror[E0433]: failed to resolve: use of undeclared type `NestedMeta`\n  --> src\\main.rs:36:33\n   |\n36 | ...                   NestedMeta::Meta(Meta::Path(path)) => path.is_ident(\"usize\"),\n   |                       ^^^^^^^^^^ use of undeclared type `NestedMeta`\n\nSome errors have detailed explanations: E0433, E0599, E0609, E0615.\nFor more information about an error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Enum_With_Exotic_Discriminant_31_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `parse_meta` found for reference `&Attribute` in the current scope\n   --> src\\main.rs:33:44\n    |\n33  |                     if let Ok(meta) = attr.parse_meta() {\n    |                                            ^^^^^^^^^^\n    |\nhelp: there is a method `parse_nested_meta` with a similar name, but with different arguments\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\attr.rs:391:5\n    |\n391 | /     pub fn parse_nested_meta(\n392 | |         &self,\n393 | |         logic: impl FnMut(ParseNestedMeta) -> Result<()>,\n394 | |     ) -> Result<()> {\n    | |___________________^\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\enum_with_exotic_discriminant_31.rs"
    },
    {
        "mutator_name": "Function_As_Const_Argument_223",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Function_As_Const_Argument_223_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0615]: attempted to take value of method `path` on type `&Attribute`\n  --> src\\main.rs:44:51\n   |\n44 |             if !file.attrs.iter().any(|attr| attr.path.is_ident(\"feature\")) {\n   |                                                   ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n44 |             if !file.attrs.iter().any(|attr| attr.path().is_ident(\"feature\")) {\n   |                                                       ++\n\nFor more information about this error, try `rustc --explain E0615`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\function_as_const_argument_223.rs"
    },
    {
        "mutator_name": "Function_Signature_Trait_Bounds_121",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Function_Signature_Trait_Bounds_121_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0422]: cannot find struct, variant or union type `TildeConst` in module `token`\n  --> src\\main.rs:41:94\n   |\n41 | ...                   trait_bound.modifier = TraitBoundModifier::MaybeConst(token::TildeConst {\n   |                                                                                    ^^^^^^^^^^ not found in `token`\n\nerror[E0599]: no variant or associated item named `MaybeConst` found for enum `TraitBoundModifier` in the current scope\n  --> src\\main.rs:41:76\n   |\n41 | ...                   trait_bound.modifier = TraitBoundModifier::MaybeConst(token::TildeConst {\n   |                                                                  ^^^^^^^^^^ variant or associated item not found in `TraitBoundModifier`\n\nSome errors have detailed explanations: E0422, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\function_signature_trait_bounds_121.rs"
    },
    {
        "mutator_name": "Incomplete_Trait_Impl_193",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Incomplete_Trait_Impl_193_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:36:51\n   |\n36 | ...                   if let syn::ImplItem::Method(method) = impl_item {\n   |                                             ^^^^^^ variant or associated item not found in `ImplItem`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:44:55\n   |\n44 | ...                   if let syn::ImplItem::Method(method) = impl_item {\n   |                                             ^^^^^^ variant or associated item not found in `ImplItem`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Incomplete_Trait_Impl_193_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0432]: unresolved import `syn::ImplItemMethod`\n  --> src\\main.rs:19:15\n   |\n19 |     ImplItem, ImplItemMethod\n   |               ^^^^^^^^^^^^^^\n   |               |\n   |               no `ImplItemMethod` in the root\n   |               help: a similar name exists in the module: `ImplItemMacro`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:37:46\n   |\n37 | ...                   if let ImplItem::Method(method) = impl_item {\n   |                                        ^^^^^^ variant or associated item not found in `ImplItem`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:45:50\n   |\n45 | ...                   if let ImplItem::Method(method) = impl_item {\n   |                                        ^^^^^^ variant or associated item not found in `ImplItem`\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\incomplete_trait_impl_193.rs"
    },
    {
        "mutator_name": "Incorrect_Generic_Constraint_159",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\incorrect_generic_constraint_159.rs"
    },
    {
        "mutator_name": "Incorrect_Lifetime_Annotation_183",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Incorrect_Lifetime_Annotation_183_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0594]: cannot assign to `lifetime_param.lifetime`, which is behind a `&` reference\n  --> src\\main.rs:35:25\n   |\n35 |                         lifetime_param.lifetime = incorrect_lifetime.clone();\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^ `lifetime_param` is a `&` reference, so the data it refers to cannot be written\n\nFor more information about this error, try `rustc --explain E0594`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\incorrect_lifetime_annotation_183.rs"
    },
    {
        "mutator_name": "Incorrect_Lifetime_Specification_109",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\incorrect_lifetime_specification_109.rs"
    },
    {
        "mutator_name": "Inherent_Associated_Type_Redundancy_216",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Inherent_Associated_Type_Redundancy_216_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n    --> src\\main.rs:57:50\n     |\n57   | ...                   item_impl.items.push(Item::Type(new_type));\n     |                                       ---- ^^^^^^^^^^^^^^^^^^^^ expected `ImplItem`, found `Item`\n     |                                       |\n     |                                       arguments to this method are incorrect\n     |\nnote: method defined here\n    --> C:\\Users\\love\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\alloc\\src\\vec\\mod.rs:2442:12\n     |\n2442 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\inherent_associated_type_redundancy_216.rs"
    },
    {
        "mutator_name": "Inline_Attribute_Manipulation_145",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Inline_Attribute_Manipulation_145_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0615]: attempted to take value of method `path` on type `&Attribute`\n  --> src\\main.rs:33:29\n   |\n33 |                     if attr.path.is_ident(\"inline\") {\n   |                             ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n33 |                     if attr.path().is_ident(\"inline\") {\n   |                                 ++\n\nerror[E0599]: no method named `parse_meta` found for reference `&Attribute` in the current scope\n   --> src\\main.rs:34:48\n    |\n34  |                         if let Ok(meta) = attr.parse_meta() {\n    |                                                ^^^^^^^^^^\n    |\nhelp: there is a method `parse_nested_meta` with a similar name, but with different arguments\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\attr.rs:391:5\n    |\n391 | /     pub fn parse_nested_meta(\n392 | |         &self,\n393 | |         logic: impl FnMut(ParseNestedMeta) -> Result<()>,\n394 | |     ) -> Result<()> {\n    | |___________________^\n\nerror[E0609]: no field `nested` on type `MetaList`\n  --> src\\main.rs:36:46\n   |\n36 | ...                   if meta_list.nested.iter().any(|nested| {\n   |                                    ^^^^^^ unknown field\n   |\n   = note: available fields are: `path`, `delimiter`, `tokens`\n\nerror[E0433]: failed to resolve: use of undeclared type `NestedMeta`\n  --> src\\main.rs:37:44\n   |\n37 | ...                   if let NestedMeta::Meta(Meta::Path(path)) = nested {\n   |                              ^^^^^^^^^^ use of undeclared type `NestedMeta`\n\nSome errors have detailed explanations: E0433, E0599, E0609, E0615.\nFor more information about an error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Inline_Attribute_Manipulation_145_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0432]: unresolved import `syn::NestedMeta`\n  --> src\\main.rs:19:21\n   |\n19 |     Meta, MetaList, NestedMeta\n   |                     ^^^^^^^^^^ no `NestedMeta` in the root\n\nerror[E0599]: no method named `parse_meta` found for reference `&Attribute` in the current scope\n   --> src\\main.rs:35:65\n    |\n35  |                         if let Ok(Meta::List(meta_list)) = attr.parse_meta() {\n    |                                                                 ^^^^^^^^^^\n    |\nhelp: there is a method `parse_nested_meta` with a similar name, but with different arguments\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\attr.rs:391:5\n    |\n391 | /     pub fn parse_nested_meta(\n392 | |         &self,\n393 | |         logic: impl FnMut(ParseNestedMeta) -> Result<()>,\n394 | |     ) -> Result<()> {\n    | |___________________^\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Inline_Attribute_Manipulation_145_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:32:29\n   |\n32 |             if let Item::Fn(ref mut item_fn) = item {\n   |                             ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:32:20\n   |\n32 |             if let Item::Fn(ref mut item_fn) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n32 -             if let Item::Fn(ref mut item_fn) = item {\n32 +             if let Item::Fn(item_fn) = item {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\inline_attribute_manipulation_145.rs"
    },
    {
        "mutator_name": "Introduce_Ambiguous_Inherent_Associated_Type_218",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\introduce_ambiguous_inherent_associated_type_218.rs"
    },
    {
        "mutator_name": "Introduce_Complex_Generic_Const_Expressions_150",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Introduce_Complex_Generic_Const_Expressions_150_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:47:42\n   |\n47 | ...                   colon_token: None,\n   |                                    ^^^^ expected `Colon`, found `Option<_>`\n   |\n   = note: expected struct `syn::token::Colon`\n                found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:48:33\n   |\n48 |   ...                   ty: Box::new(Type::Path(TypePath {\n   |  ___________________________^\n49 | | ...                       qself: None,\n50 | | ...                       path: parse_quote!(usize),\n51 | | ...                   })),\n   | |_________________________^ expected `Type`, found `Box<Type>`\n   |\n   = note: expected enum `syn::Type`\n            found struct `std::boxed::Box<syn::Type>`\nhelp: consider unboxing the value\n   |\n48 |                             ty: *Box::new(Type::Path(TypePath {\n   |                                 +\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:60:36\n   |\n60 |                         init: Some((_, expr)),\n   |                                    ^^^^^^^^^ expected `LocalInit`, found `(_, _)`\n61 |                         ..\n62 |                     }) = stmt\n   |                          ---- this expression has type `&mut Stmt`\n   |\n   = note: expected struct `LocalInit`\n               found tuple `(_, _)`\n\nerror[E0609]: no field `len` on type `ExprArray`\n  --> src\\main.rs:65:70\n   |\n65 | ...                   if let Expr::Lit(expr_lit) = &expr_array.len {\n   |                                                                ^^^ unknown field\n   |\n   = note: available fields are: `attrs`, `bracket_token`, `elems`\n\nerror[E0609]: no field `len` on type `ExprArray`\n  --> src\\main.rs:68:48\n   |\n68 | ...                   expr_array.len = new_expr;\n   |                                  ^^^ unknown field\n   |\n   = note: available fields are: `attrs`, `bracket_token`, `elems`\n\nSome errors have detailed explanations: E0308, E0609.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 5 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Introduce_Complex_Generic_Const_Expressions_150_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:47:42\n   |\n47 | ...                   colon_token: Some(token::Colon(Span::call_site())),\n   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Colon`, found `Option<Colon>`\n   |\n   = note: expected struct `syn::token::Colon`\n                found enum `Option<syn::token::Colon>`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:66:36\n   |\n66 | ...                   if let Expr::Lit(expr_lit) = len_expr {\n   |                              ^^^^^^^^^^^^^^^^^^^   -------- this expression has type `&usize`\n   |                              |\n   |                              expected `usize`, found `Expr`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Introduce_Complex_Generic_Const_Expressions_150_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0594]: cannot assign to `expr_array.elems`, which is behind a `&` reference\n  --> src\\main.rs:67:29\n   |\n67 | ...                   expr_array.elems = Punctuated::new();\n   |                       ^^^^^^^^^^^^^^^^ `expr_array` is a `&` reference, so the data it refers to cannot be written\n\nerror[E0596]: cannot borrow `expr_array.elems` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:68:29\n   |\n68 | ...                   expr_array.elems.push(new_expr);\n   |                       ^^^^^^^^^^^^^^^^ `expr_array` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nSome errors have detailed explanations: E0594, E0596.\nFor more information about an error, try `rustc --explain E0594`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\introduce_complex_generic_const_expressions_150.rs"
    },
    {
        "mutator_name": "Introduce_Generic_Parameters_To_Function_28",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Introduce_Generic_Parameters_To_Function_28_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:29\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                             ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n31 -             if let Item::Fn(ref mut func) = item {\n31 +             if let Item::Fn(func) = item {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Introduce_Generic_Parameters_To_Function_28_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Fn(func) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:13:41\n   |\n13 |                     let generic_ident = Ident::new(\"T\", Span::call_site());\n   |                                         ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:13:57\n   |\n13 |                     let generic_ident = Ident::new(\"T\", Span::call_site());\n   |                                                         ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericParam`\n  --> src\\main.rs:15:42\n   |\n15 |                     generics.params.push(GenericParam::Type(TypeParam {\n   |                                          ^^^^^^^^^^^^ use of undeclared type `GenericParam`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypeParam` in this scope\n  --> src\\main.rs:15:61\n   |\n15 |                     generics.params.push(GenericParam::Type(TypeParam {\n   |                                                             ^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypeParam;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Punctuated`\n  --> src\\main.rs:19:33\n   |\n19 |                         bounds: Punctuated::new(),\n   |                                 ^^^^^^^^^^ use of undeclared type `Punctuated`\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::punctuated::Punctuated;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `FnArg`\n  --> src\\main.rs:26:28\n   |\n26 |                     if let FnArg::Typed(PatType { ty, .. }) = first_param {\n   |                            ^^^^^ use of undeclared type `FnArg`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::FnArg;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `PatType` in this scope\n  --> src\\main.rs:26:41\n   |\n26 |                     if let FnArg::Typed(PatType { ty, .. }) = first_param {\n   |                                         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::PatType;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:27:40\n   |\n27 |                         *ty = Box::new(Type::Path(TypePath {\n   |                                        ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypePath` in this scope\n  --> src\\main.rs:27:51\n   |\n27 |                         *ty = Box::new(Type::Path(TypePath {\n   |                                                   ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypePath;\n   |\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 10 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Introduce_Generic_Parameters_To_Function_28_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:7:6\n  |\n7 | impl Mutator for Introduce_Generic_Parameters_To_Function_28 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\introduce_generic_parameters_to_function_28.rs"
    },
    {
        "mutator_name": "Introduce_Nested_Closure_6",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\introduce_nested_closure_6.rs"
    },
    {
        "mutator_name": "Introduce_Nested_Trait_With_Const_Bounds_168",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Introduce_Nested_Trait_With_Const_Bounds_168_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:32\n   |\n31 |             if let Item::Trait(ref trait_item) = item {\n   |                                ^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Trait(ref trait_item) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: make the implied reference pattern explicit\n   |\n31 |             if let &mut Item::Trait(ref trait_item) = item {\n   |                    ++++\n\nerror[E0499]: cannot borrow `file.items` as mutable more than once at a time\n  --> src\\main.rs:60:21\n   |\n30 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     first mutable borrow occurs here\n   |                     first borrow later used here\n...\n60 |                     file.items.push(nested_trait);\n   |                     ^^^^^^^^^^ second mutable borrow occurs here\n\nerror[E0499]: cannot borrow `file.items` as mutable more than once at a time\n  --> src\\main.rs:61:21\n   |\n30 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     first mutable borrow occurs here\n   |                     first borrow later used here\n...\n61 |                     file.items.push(impl_nested_trait);\n   |                     ^^^^^^^^^^ second mutable borrow occurs here\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Introduce_Nested_Trait_With_Const_Bounds_168_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:32:32\n   |\n32 |             if let Item::Trait(ref trait_item) = item {\n   |                                ^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:32:20\n   |\n32 |             if let Item::Trait(ref trait_item) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: make the implied reference pattern explicit\n   |\n32 |             if let &mut Item::Trait(ref trait_item) = item {\n   |                    ++++\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Introduce_Nested_Trait_With_Const_Bounds_168_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:24:46\n   |\n24 |                     let nested_trait: Item = parse_quote! {\n   |                                              ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:32:51\n   |\n32 |                     let impl_nested_trait: Item = parse_quote! {\n   |                                                   ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:12:25\n   |\n12 |             if let &mut Item::Trait(ref trait_item) = item {\n   |                         ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericParam`\n  --> src\\main.rs:14:28\n   |\n14 |                     if let GenericParam::Const(_) = param {\n   |                            ^^^^^^^^^^^^ use of undeclared type `GenericParam`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:21:45\n   |\n21 |                     let nested_trait_name = Ident::new(\"NestedTrait\", Span::call_site());\n   |                                             ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:21:71\n   |\n21 |                     let nested_trait_name = Ident::new(\"NestedTrait\", Span::call_site());\n   |                                                                       ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:22:39\n   |\n22 |                     let const_param = Ident::new(\"N\", Span::call_site());\n   |                                       ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:22:55\n   |\n22 |                     let const_param = Ident::new(\"N\", Span::call_site());\n   |                                                       ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0412]: cannot find type `Item` in this scope\n  --> src\\main.rs:24:39\n   |\n24 |                     let nested_trait: Item = parse_quote! {\n   |                                       ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0412]: cannot find type `Item` in this scope\n  --> src\\main.rs:32:44\n   |\n32 |                     let impl_nested_trait: Item = parse_quote! {\n   |                                            ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 10 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Introduce_Nested_Trait_With_Const_Bounds_168_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:6:6\n  |\n6 | impl Mutator for Introduce_Nested_Trait_With_Const_Bounds_168 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Introduce_Nested_Trait_With_Const_Bounds_168_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:14:32\n   |\n14 |             if let Item::Trait(ref trait_item) = item {\n   |                                ^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:14:20\n   |\n14 |             if let Item::Trait(ref trait_item) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: make the implied reference pattern explicit\n   |\n14 |             if let &mut Item::Trait(ref trait_item) = item {\n   |                    ++++\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\introduce_nested_trait_with_const_bounds_168.rs"
    },
    {
        "mutator_name": "Introduce_PhantomData_Misuse_240",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Introduce_PhantomData_Misuse_240_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `push` found for mutable reference `&mut Fields` in the current scope\n  --> src\\main.rs:36:28\n   |\n36 |                     fields.push(phantom_field);\n   |                            ^^^^ method not found in `&mut Fields`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\introduce_phantomdata_misuse_240.rs"
    },
    {
        "mutator_name": "Introduce_Undeclared_Lifetime_104",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Introduce_Undeclared_Lifetime_104_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:33:33\n   |\n33 |                 if let Some((_, ref trait_path, _)) = &item_impl.trait_ {\n   |                                 ^^^ binding modifier not allowed under `ref` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:33:24\n   |\n33 |                 if let Some((_, ref trait_path, _)) = &item_impl.trait_ {\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&_`\nhelp: remove the unnecessary binding modifier\n   |\n33 -                 if let Some((_, ref trait_path, _)) = &item_impl.trait_ {\n33 +                 if let Some((_, trait_path, _)) = &item_impl.trait_ {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:42:70\n   |\n42 | ...                   if let GenericArgument::Lifetime(ref mut lifetime) = arg {\n   |                                                        ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:42:44\n   |\n42 | ...                   if let GenericArgument::Lifetime(ref mut lifetime) = arg {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n42 -                                     if let GenericArgument::Lifetime(ref mut lifetime) = arg {\n42 +                                     if let GenericArgument::Lifetime(lifetime) = arg {\n   |\n\nerror[E0596]: cannot borrow `last_segment.arguments.0` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:36:66\n   |\n35 |                         if let Some(last_segment) = type_path.path.segments.last() {\n   |                                     ------------ consider changing this binding's type to be: `&mut PathSegment`\n36 |                             if let PathArguments::AngleBracketed(ref mut args) = last_segment.arguments {\n   |                                                                  ^^^^^^^^^^^^ `last_segment` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Introduce_Undeclared_Lifetime_104_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `type_path.path.segments` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:35:53\n   |\n35 |                         if let Some(last_segment) = type_path.path.segments.last_mut() {\n   |                                                     ^^^^^^^^^^^^^^^^^^^^^^^ `type_path` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Introduce_Undeclared_Lifetime_104_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:12:20\n   |\n12 |             if let Item::Impl(item_impl) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:14:28\n   |\n14 |                     if let Type::Path(type_path) = &mut *item_impl.self_ty {\n   |                            ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `PathArguments`\n  --> src\\main.rs:16:36\n   |\n16 | ...                   if let PathArguments::AngleBracketed(args) = &mut last_segment.arguments {\n   |                              ^^^^^^^^^^^^^ use of undeclared type `PathArguments`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::PathArguments;\n   |\n\nerror[E0412]: cannot find type `HashSet` in this scope\n  --> src\\main.rs:17:57\n   |\n17 | ...                   let declared_lifetimes: HashSet<_> = item_impl.generics.lifetimes()\n   |                                               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericArgument`\n  --> src\\main.rs:22:44\n   |\n22 | ...                   if let GenericArgument::Lifetime(lifetime) = arg {\n   |                              ^^^^^^^^^^^^^^^ use of undeclared type `GenericArgument`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericArgument;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Lifetime`\n  --> src\\main.rs:24:64\n   |\n24 | ...                   let new_lifetime = Lifetime::new(\"'c\", Span::call_site());\n   |                                          ^^^^^^^^ use of undeclared type `Lifetime`\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::Lifetime;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:24:84\n   |\n24 | ...                   let new_lifetime = Lifetime::new(\"'c\", Span::call_site());\n   |                                                              ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 7 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Introduce_Undeclared_Lifetime_104_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:7:6\n  |\n7 | impl Mutator for Introduce_Undeclared_Lifetime_104 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\introduce_undeclared_lifetime_104.rs"
    },
    {
        "mutator_name": "Introduce_Unstable_Feature_Misuse_42",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Introduce_Unstable_Feature_Misuse_42_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0499]: cannot borrow `file.items` as mutable more than once at a time\n  --> src\\main.rs:61:21\n   |\n34 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     first mutable borrow occurs here\n   |                     first borrow later used here\n...\n61 |                     file.items.push(Item::Enum(faulty_enum));\n   |                     ^^^^^^^^^^ second mutable borrow occurs here\n\nerror[E0499]: cannot borrow `file.items` as mutable more than once at a time\n  --> src\\main.rs:68:21\n   |\n34 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     first mutable borrow occurs here\n   |                     first borrow later used here\n...\n68 |                     file.items.push(Item::Fn(usage_fn));\n   |                     ^^^^^^^^^^ second mutable borrow occurs here\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\introduce_unstable_feature_misuse_42.rs"
    },
    {
        "mutator_name": "Introduce_Unstable_Library_Feature_Without_Feature_Attribute_124",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Introduce_Unstable_Library_Feature_Without_Feature_Attribute_124_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0615]: attempted to take value of method `path` on type `&Attribute`\n  --> src\\main.rs:48:39\n   |\n48 |             if let Some(ident) = attr.path.get_ident() {\n   |                                       ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n48 |             if let Some(ident) = attr.path().get_ident() {\n   |                                           ++\n\nerror[E0599]: no method named `parse_meta` found for reference `&Attribute` in the current scope\n   --> src\\main.rs:50:44\n    |\n50  |                     if let Ok(meta) = attr.parse_meta() {\n    |                                            ^^^^^^^^^^\n    |\nhelp: there is a method `parse_nested_meta` with a similar name, but with different arguments\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\attr.rs:391:5\n    |\n391 | /     pub fn parse_nested_meta(\n392 | |         &self,\n393 | |         logic: impl FnMut(ParseNestedMeta) -> Result<()>,\n394 | |     ) -> Result<()> {\n    | |___________________^\n\nerror[E0609]: no field `nested` on type `MetaList`\n  --> src\\main.rs:52:53\n   |\n52 | ...                   for nested in meta_list.nested.iter() {\n   |                                               ^^^^^^ unknown field\n   |\n   = note: available fields are: `path`, `delimiter`, `tokens`\n\nerror[E0433]: failed to resolve: use of undeclared type `NestedMeta`\n  --> src\\main.rs:53:40\n   |\n53 | ...                   if let NestedMeta::Meta(Meta::Path(path)) = nested {\n   |                              ^^^^^^^^^^ use of undeclared type `NestedMeta`\n\nSome errors have detailed explanations: E0433, E0599, E0609, E0615.\nFor more information about an error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Introduce_Unstable_Library_Feature_Without_Feature_Attribute_124_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0432]: unresolved import `syn::NestedMeta`\n --> src\\main.rs:8:79\n  |\n8 |     Item, ItemFn, ItemStruct, Lifetime, LifetimeParam, Local, Meta, MetaList, NestedMeta, Pat, PatType, Path as SynPath,\n  |                                                                               ^^^^^^^^^^ no `NestedMeta` in the root\n\nerror[E0599]: no method named `parse_meta` found for reference `&Attribute` in the current scope\n   --> src\\main.rs:50:61\n    |\n50  |                     if let Ok(Meta::List(meta_list)) = attr.parse_meta() {\n    |                                                             ^^^^^^^^^^\n    |\nhelp: there is a method `parse_nested_meta` with a similar name, but with different arguments\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\attr.rs:391:5\n    |\n391 | /     pub fn parse_nested_meta(\n392 | |         &self,\n393 | |         logic: impl FnMut(ParseNestedMeta) -> Result<()>,\n394 | |     ) -> Result<()> {\n    | |___________________^\n\nerror[E0609]: no field `nested` on type `MetaList`\n  --> src\\main.rs:51:49\n   |\n51 |                         for nested in meta_list.nested.iter() {\n   |                                                 ^^^^^^ unknown field\n   |\n   = note: available fields are: `path`, `delimiter`, `tokens`\n\nSome errors have detailed explanations: E0432, E0599, E0609.\nFor more information about an error, try `rustc --explain E0432`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\introduce_unstable_library_feature_without_feature_attribute_124.rs"
    },
    {
        "mutator_name": "Introduce_Unused_Lifetime_106",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\introduce_unused_lifetime_106.rs"
    },
    {
        "mutator_name": "Introduce_Unused_Variable_91",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Introduce_Unused_Variable_91_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:35:47\n   |\n35 | ...                   if let Stmt::Expr(Expr::Closure(expr_closure)) = stmt {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n35 |                             if let Stmt::Expr(Expr::Closure(expr_closure), _) = stmt {\n   |                                                                          +++\n\nerror[E0599]: no variant or associated item named `Semi` found for enum `Stmt` in the current scope\n  --> src\\main.rs:39:76\n   |\n39 | ...                   expr_block.block.stmts.insert(0, Stmt::Semi(new_var, Default::default()));\n   |                                                              ^^^^ variant or associated item not found in `Stmt`\n\nSome errors have detailed explanations: E0023, E0599.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\introduce_unused_variable_91.rs"
    },
    {
        "mutator_name": "Lifetime_Parameter_Mutator_184",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\lifetime_parameter_mutator_184.rs"
    },
    {
        "mutator_name": "Macro_Invocation_Control_Flow_94",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Macro_Invocation_Control_Flow_94_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0277]: the trait bound `Vec<Stmt>: Parse` is not satisfied\n   --> src\\main.rs:58:44\n    |\n58  |                 let mut stmts: Vec<Stmt> = syn::parse2(group.stream()).unwrap_or_default();\n    |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Parse` is not implemented for `Vec<Stmt>`\n    |\n    = help: the following other types implement trait `Parse`:\n              Abstract\n              AndAnd\n              AndEq\n              AngleBracketedGenericArguments\n              Arm\n              As\n              At\n              Auto\n            and 248 others\nnote: required by a bound in `syn::parse2`\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\lib.rs:920:18\n    |\n920 | pub fn parse2<T: parse::Parse>(tokens: proc_macro2::TokenStream) -> Result<T> {\n    |                  ^^^^^^^^^^^^ required by this bound in `parse2`\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\macro_invocation_control_flow_94.rs"
    },
    {
        "mutator_name": "Manipulate_Function_Return_Type_83",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Manipulate_Function_Return_Type_83_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:37:52\n   |\n37 |                           let recursive_call: Expr = parse_quote! {\n   |  ____________________________________________________^\n38 | |                             #fn_name(#(#fn_params),*)\n39 | |                         };\n   | |                         ^\n   | |                         |\n   | |                         expected `HasIterator`, found `ThereIsNoIteratorInRepetition`\n   | |_________________________expected due to this\n   |                           here the type of `has_iter` is inferred to be `ThereIsNoIteratorInRepetition`\n   |\n   = note: this error originates in the macro `$crate::quote_token_with_context` which comes from the expansion of the macro `parse_quote` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Manipulate_Function_Return_Type_83_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.98s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:37:52:\nexpected `,`\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Manipulate_Function_Return_Type_83_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.63s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:37:52:\nexpected `,`\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Manipulate_Function_Return_Type_83_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:18:52\n   |\n18 |                         let recursive_call: Expr = parse_quote! {\n   |                                                    ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:22:46\n   |\n22 |                         let new_stmt: Stmt = parse_quote! {\n   |                                              ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:3:6\n  |\n3 | impl Mutator for Manipulate_Function_Return_Type_83 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n --> src\\main.rs:9:20\n  |\n9 |             if let Item::Fn(item_fn) = item {\n  |                    ^^^^ use of undeclared type `Item`\n  |\nhelp: consider importing this enum\n  |\n1 + use syn::Item;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `ReturnType`\n  --> src\\main.rs:10:24\n   |\n10 |                 if let ReturnType::Type(_, return_type) = &item_fn.sig.output {\n   |                        ^^^^^^^^^^ use of undeclared type `ReturnType`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::ReturnType;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:11:28\n   |\n11 |                     if let Type::ImplTrait(_) = **return_type {\n   |                            ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `FnArg`\n  --> src\\main.rs:14:29\n   |\n14 | ...                   FnArg::Typed(pat_type) => &pat_type.pat,\n   |                       ^^^^^ use of undeclared type `FnArg`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::FnArg;\n   |\n\nerror[E0412]: cannot find type `Expr` in this scope\n  --> src\\main.rs:18:45\n   |\n18 |                         let recursive_call: Expr = parse_quote! {\n   |                                             ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0412]: cannot find type `Stmt` in this scope\n  --> src\\main.rs:22:39\n   |\n22 |                         let new_stmt: Stmt = parse_quote! {\n   |                                       ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nSome errors have detailed explanations: E0405, E0412, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 9 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Manipulate_Function_Return_Type_83_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.75s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:18:34:\nUnexpected argument type\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\manipulate_function_return_type_83.rs"
    },
    {
        "mutator_name": "Mismatched_Method_Signature_127",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Mismatched_Method_Signature_127_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0412]: cannot find type `TraitItemMethod` in crate `syn`\n   --> src\\main.rs:56:22\n    |\n56  |   ) -> Option<&'a syn::TraitItemMethod> {\n    |                        ^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `TraitItemMacro`\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\item.rs:678:1\n    |\n678 | / ast_struct! {\n679 | |     /// A macro invocation within the definition of a trait.\n680 | |     #[cfg_attr(docsrs, doc(cfg(feature = \"full\")))]\n681 | |     pub struct TraitItemMacro {\n...   |\n686 | | }\n    | |_- similarly named struct `TraitItemMacro` defined here\n\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:34:47\n   |\n34 |                         if let syn::ImplItem::Method(method) = impl_item {\n   |                                               ^^^^^^ variant or associated item not found in `ImplItem`\n\nerror[E0277]: can't compare `&proc_macro2::Ident` with `proc_macro2::Ident`\n  --> src\\main.rs:59:34\n   |\n59 |             if &trait_item.ident == path.segments.last().unwrap().ident {\n   |                                  ^^ no implementation for `&proc_macro2::Ident == proc_macro2::Ident`\n   |\n   = help: the trait `PartialEq<proc_macro2::Ident>` is not implemented for `&proc_macro2::Ident`\nhelp: consider removing the borrow\n   |\n59 -             if &trait_item.ident == path.segments.last().unwrap().ident {\n59 +             if trait_item.ident == path.segments.last().unwrap().ident {\n   |\n\nerror[E0599]: no variant or associated item named `Method` found for enum `TraitItem` in the current scope\n  --> src\\main.rs:61:44\n   |\n61 |                     if let syn::TraitItem::Method(method) = item {\n   |                                            ^^^^^^ variant or associated item not found in `TraitItem`\n\nSome errors have detailed explanations: E0277, E0412, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mismatched_Method_Signature_127_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0502]: cannot borrow `*file` as immutable because it is also borrowed as mutable\n  --> src\\main.rs:36:73\n   |\n30 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     mutable borrow occurs here\n   |                     mutable borrow later used here\n...\n36 |                             if let Some(trait_item) = find_trait_method(file, path, method_name) {\n   |                                                                         ^^^^ immutable borrow occurs here\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mismatched_Method_Signature_127_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0412]: cannot find type `HashMap` in this scope\n  --> src\\main.rs:53:47\n   |\n53 | fn collect_trait_methods(file: &syn::File) -> HashMap<(SynPath, Ident), syn::TraitItemFn> {\n   |                                               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing one of these structs\n   |\n1  + use crate::collections::HashMap;\n   |\n1  + use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n  --> src\\main.rs:54:29\n   |\n54 |     let mut trait_methods = HashMap::new();\n   |                             ^^^^^^^ use of undeclared type `HashMap`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use crate::collections::HashMap;\n   |\n1  + use std::collections::HashMap;\n   |\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mismatched_Method_Signature_127_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:57:21\n   |\n57 |     sig.inputs.push(parse_quote!(x: u32));\n   |                     ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:58:21\n   |\n58 |     sig.inputs.push(parse_quote!(y: u32));\n   |                     ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Mismatched_Method_Signature_127 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:12:20\n   |\n12 |             if let Item::Impl(ItemImpl { trait_, items, .. }) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `ItemImpl` in this scope\n  --> src\\main.rs:12:31\n   |\n12 |             if let Item::Impl(ItemImpl { trait_, items, .. }) = item {\n   |                               ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::ItemImpl;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `ImplItem`\n  --> src\\main.rs:15:32\n   |\n15 |                         if let ImplItem::Fn(method) = impl_item {\n   |                                ^^^^^^^^ use of undeclared type `ImplItem`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::ImplItem;\n   |\n\nerror[E0412]: cannot find type `SynPath` in this scope\n  --> src\\main.rs:33:56\n   |\n33 | fn collect_trait_methods(file: &syn::File) -> HashMap<(SynPath, Ident), syn::TraitItemFn> {\n   |                                                        ^^^^^^^ not found in this scope\n   |\nhelp: you might be missing a type parameter\n   |\n33 | fn collect_trait_methods<SynPath>(file: &syn::File) -> HashMap<(SynPath, Ident), syn::TraitItemFn> {\n   |                         +++++++++\n\nerror[E0412]: cannot find type `Ident` in this scope\n  --> src\\main.rs:33:65\n   |\n33 | fn collect_trait_methods(file: &syn::File) -> HashMap<(SynPath, Ident), syn::TraitItemFn> {\n   |                                                                 ^^^^^ not found in this scope\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:36:16\n   |\n36 |         if let Item::Trait(trait_item) = item {\n   |                ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `SynPath` in this scope\n  --> src\\main.rs:37:30\n   |\n37 |             let trait_path = SynPath {\n   |                              ^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Punctuated`\n  --> src\\main.rs:39:27\n   |\n39 |                 segments: Punctuated::from_iter(vec![trait_item.ident.clone().into()]),\n   |                           ^^^^^^^^^^ use of undeclared type `Punctuated`\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::punctuated::Punctuated;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TraitItem`\n  --> src\\main.rs:42:24\n   |\n42 |                 if let TraitItem::Fn(method) = item {\n   |                        ^^^^^^^^^ use of undeclared type `TraitItem`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TraitItem;\n   |\n\nerror[E0412]: cannot find type `Signature` in this scope\n  --> src\\main.rs:51:29\n   |\n51 | fn has_self_reference(sig: &Signature) -> bool {\n   |                             ^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::Signature;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `FnArg`\n  --> src\\main.rs:52:47\n   |\n52 |     sig.inputs.iter().any(|arg| matches!(arg, FnArg::Receiver(_)))\n   |                                               ^^^^^ use of undeclared type `FnArg`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::FnArg;\n   |\n\nerror[E0412]: cannot find type `Signature` in this scope\n  --> src\\main.rs:55:38\n   |\n55 | fn mutate_method_signature(sig: &mut Signature) {\n   |                                      ^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::Signature;\n   |\n\nSome errors have detailed explanations: E0405, E0412, E0422, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 15 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mismatched_Method_Signature_127_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0412]: cannot find type `Colon2` in module `syn::token`\n   --> src\\main.rs:37:86\n    |\n37  |   fn collect_trait_methods(file: &syn::File) -> HashMap<(Punctuated<Ident, syn::token::Colon2>, Ident), syn::TraitItemFn> {\n    |                                                                                        ^^^^^^ help: a struct with a similar name exists: `Colon`\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\token.rs:746:1\n    |\n746 | / define_punctuation! {\n747 | |     \"&\"           pub struct And/1        /// bitwise and logical AND, borrow, references, reference patterns\n748 | |     \"&&\"          pub struct AndAnd/2     /// lazy AND, borrow, references, reference patterns\n749 | |     \"&=\"          pub struct AndEq/2      /// bitwise AND assignment\n...   |\n792 | |     \"~\"           pub struct Tilde/1      /// unused since before Rust 1.0\n793 | | }\n    | |_- similarly named struct `Colon` defined here\n\nFor more information about this error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mismatched_Method_Signature_127_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:21:75\n   |\n21 | ...                   if let Some(trait_item) = trait_methods.get(&(path.clone(), method_name.clone())) {\n   |                                                                     ^^^^^^^^^^^^ expected `Punctuated<Ident, Colon>`, found `Path`\n   |\n   = note: expected struct `syn::punctuated::Punctuated<syn::Ident, syn::token::Colon>`\n              found struct `syn::Path`\n\nerror[E0283]: type annotations needed\n  --> src\\main.rs:41:30\n   |\n41 |             let trait_path = Punctuated::from_iter(vec![trait_item.ident.clone().into()]);\n   |                              ^^^^^^^^^^^^^^^^^^^^^ cannot infer type of the type parameter `T` declared on the associated function `from_iter`\n   |\n   = note: multiple `impl`s satisfying `syn::punctuated::Punctuated<syn::Ident, syn::token::Colon>: FromIterator<_>` found in the `syn` crate:\n           - impl<T, P> FromIterator<Pair<T, P>> for syn::punctuated::Punctuated<T, P>;\n           - impl<T, P> FromIterator<T> for syn::punctuated::Punctuated<T, P>\n             where P: std::default::Default;\nhelp: consider specifying the generic argument\n   |\n41 |             let trait_path = Punctuated::from_iter::<Vec<_>>(vec![trait_item.ident.clone().into()]);\n   |                                                   ++++++++++\n\nerror[E0283]: type annotations needed\n  --> src\\main.rs:41:30\n   |\n41 |             let trait_path = Punctuated::from_iter(vec![trait_item.ident.clone().into()]);\n   |                              ^^^^^^^^^^^^^^^^^^^^^                               ---- type must be known at this point\n   |                              |\n   |                              cannot infer type of the type parameter `T` declared on the associated function `from_iter`\n   |\n   = note: multiple `impl`s satisfying `_: From<syn::Ident>` found in the following crates: `proc_macro2`, `syn`:\n           - impl From<syn::Ident> for Member;\n           - impl From<syn::Ident> for TokenTree;\n           - impl From<syn::Ident> for TypeParam;\n   = note: required for `syn::Ident` to implement `Into<_>`\nhelp: consider specifying the generic argument\n   |\n41 |             let trait_path = Punctuated::from_iter::<Vec<_>>(vec![trait_item.ident.clone().into()]);\n   |                                                   ++++++++++\n\nSome errors have detailed explanations: E0283, E0308.\nFor more information about an error, try `rustc --explain E0283`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\mismatched_method_signature_127.rs"
    },
    {
        "mutator_name": "Missing_Lifetime_In_Trait_Implementation_90",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Missing_Lifetime_In_Trait_Implementation_90_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0502]: cannot borrow `*file` as immutable because it is also borrowed as mutable\n  --> src\\main.rs:35:72\n   |\n30 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     mutable borrow occurs here\n   |                     mutable borrow later used here\n...\n35 |                         if let Some(trait_def) = find_trait_definition(file, trait_name) {\n   |                                                                        ^^^^ immutable borrow occurs here\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Missing_Lifetime_In_Trait_Implementation_90_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0412]: cannot find type `ItemTrait` in this scope\n  --> src\\main.rs:10:37\n   |\n10 |         let trait_definitions: Vec<&ItemTrait> = file.items.iter().filter_map(|item| {\n   |                                     ^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::ItemTrait;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Trait(item_trait) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:19:20\n   |\n19 |             if let Item::Impl(item_impl) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Missing_Lifetime_In_Trait_Implementation_90_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Missing_Lifetime_In_Trait_Implementation_90 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Missing_Lifetime_In_Trait_Implementation_90_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0502]: cannot borrow `file.items` as mutable because it is also borrowed as immutable\n  --> src\\main.rs:19:21\n   |\n11 |         let trait_definitions: Vec<&ItemTrait> = file.items.iter().filter_map(|item| {\n   |                                                  ---------- immutable borrow occurs here\n...\n19 |         for item in &mut file.items {\n   |                     ^^^^^^^^^^^^^^^ mutable borrow occurs here\n...\n24 |                         if let Some(trait_def) = trait_definitions.iter().find(|&&trait_def| &trait_def.ident == trait_name) {\n   |                                                  ----------------- immutable borrow later used here\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\missing_lifetime_in_trait_implementation_90.rs"
    },
    {
        "mutator_name": "Modify_Array_Length_181",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Array_Length_181_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:37:73\n   |\n37 | ...                   if let Expr::Path(ExprPath { path, .. }) = &*type_array.len {\n   |                                                                   ^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:40:54\n   |\n40 |   ...                   type_array.len = Box::new(Expr::Path(ExprPath {\n   |  _______________________--------------___^\n   | |                       |\n   | |                       expected due to the type of this binding\n41 | | ...                       attrs: vec![],\n42 | | ...                       qself: None,\n43 | | ...                       path: SynPath::from(new_generic.clone()),\n44 | | ...                   }));\n   | |_________________________^ expected `Expr`, found `Box<Expr>`\n   |\n   = note: expected enum `syn::Expr`\n            found struct `std::boxed::Box<syn::Expr>`\nhelp: consider unboxing the value\n   |\n40 |                                     type_array.len = *Box::new(Expr::Path(ExprPath {\n   |                                                      +\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Array_Length_181_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:40:54\n   |\n40 |   ...                   type_array.len = Box::new(Expr::Path(ExprPath {\n   |  _______________________--------------___^\n   | |                       |\n   | |                       expected due to the type of this binding\n41 | | ...                       attrs: vec![],\n42 | | ...                       qself: None,\n43 | | ...                       path: SynPath::from(new_generic.clone()),\n44 | | ...                   }));\n   | |_________________________^ expected `Expr`, found `Box<Expr>`\n   |\n   = note: expected enum `syn::Expr`\n            found struct `std::boxed::Box<syn::Expr>`\nhelp: consider unboxing the value\n   |\n40 |                                     type_array.len = *Box::new(Expr::Path(ExprPath {\n   |                                                      +\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Array_Length_181_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0594]: cannot assign to `type_array.len`, which is behind a `&` reference\n  --> src\\main.rs:40:37\n   |\n40 | ...                   type_array.len = Expr::Path(ExprPath {\n   |                       ^^^^^^^^^^^^^^ `type_array` is a `&` reference, so the data it refers to cannot be written\n\nFor more information about this error, try `rustc --explain E0594`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Array_Length_181_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:40:54\n   |\n40 |   ...                   type_array.len = Box::new(Expr::Path(ExprPath {\n   |  _______________________--------------___^\n   | |                       |\n   | |                       expected due to the type of this binding\n41 | | ...                       attrs: vec![],\n42 | | ...                       qself: None,\n43 | | ...                       path: SynPath::from(new_generic.clone()),\n44 | | ...                   }));\n   | |_________________________^ expected `Expr`, found `Box<Expr>`\n   |\n   = note: expected enum `syn::Expr`\n            found struct `std::boxed::Box<syn::Expr>`\nhelp: consider unboxing the value\n   |\n40 |                                     type_array.len = *Box::new(Expr::Path(ExprPath {\n   |                                                      +\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Array_Length_181_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:37:73\n   |\n37 | ...                   if let Expr::Path(ExprPath { path, .. }) = &*type_array.len {\n   |                                                                   ^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:40:54\n   |\n40 |   ...                   type_array.len = Box::new(Expr::Path(ExprPath {\n   |  _______________________--------------___^\n   | |                       |\n   | |                       expected due to the type of this binding\n41 | | ...                       attrs: vec![],\n42 | | ...                       qself: None,\n43 | | ...                       path: SynPath::from(new_generic.clone()),\n44 | | ...                   }));\n   | |_________________________^ expected `Expr`, found `Box<Expr>`\n   |\n   = note: expected enum `syn::Expr`\n            found struct `std::boxed::Box<syn::Expr>`\nhelp: consider unboxing the value\n   |\n40 |                                     type_array.len = *Box::new(Expr::Path(ExprPath {\n   |                                                      +\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_array_length_181.rs"
    },
    {
        "mutator_name": "Modify_Array_Length_33",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Array_Length_33_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:35:55\n   |\n35 |                         if let Expr::Lit(expr_lit) = &*type_array.len {\n   |                                                       ^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:43:54\n   |\n43 |   ...                   type_array.len = Box::new(Expr::Lit(ExprLit {\n   |  _______________________--------------___^\n   | |                       |\n   | |                       expected due to the type of this binding\n44 | | ...                       attrs: Vec::new(),\n45 | | ...                       lit: syn::Lit::Int(syn::LitInt::new(\n46 | | ...                           &new_len.to_string(),\n47 | | ...                           Span::call_site(),\n48 | | ...                       )),\n49 | | ...                   }));\n   | |_________________________^ expected `Expr`, found `Box<Expr>`\n   |\n   = note: expected enum `syn::Expr`\n            found struct `std::boxed::Box<syn::Expr>`\nhelp: consider unboxing the value\n   |\n43 |                                     type_array.len = *Box::new(Expr::Lit(ExprLit {\n   |                                                      +\n\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:59:43\n   |\n59 |                     if let syn::ImplItem::Method(method) = item {\n   |                                           ^^^^^^ variant or associated item not found in `ImplItem`\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:61:47\n   |\n61 | ...                   if let Stmt::Expr(Expr::Struct(expr_struct)) = stmt {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n61 |                             if let Stmt::Expr(Expr::Struct(expr_struct), _) = stmt {\n   |                                                                        +++\n\nSome errors have detailed explanations: E0023, E0308, E0599, E0614.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Array_Length_33_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:65:52\n   |\n65 | ...                   if let Expr::Lit(expr_lit) = &expr_repeat.len {\n   |                              ^^^^^^^^^^^^^^^^^^^   ---------------- this expression has type `&std::boxed::Box<syn::Expr>`\n   |                              |\n   |                              expected `Box<Expr>`, found `Expr`\n   |\n   = note: expected struct `std::boxed::Box<syn::Expr>`\n                found enum `syn::Expr`\nhelp: consider dereferencing to access the inner value using the Deref trait\n   |\n65 |                                             if let Expr::Lit(expr_lit) = &*expr_repeat.len {\n   |                                                                           +\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:73:75\n   |\n73 |   ...                   expr_repeat.len = Expr::Lit(ExprLit {\n   |  _______________________---------------___^\n   | |                       |\n   | |                       expected due to the type of this binding\n74 | | ...                       attrs: Vec::new(),\n75 | | ...                       lit: syn::Lit::Int(syn::LitInt::new(\n76 | | ...                           &new_len.to_string(),\n77 | | ...                           Span::call_site(),\n78 | | ...                       )),\n79 | | ...                   });\n   | |________________________^ expected `Box<Expr>`, found `Expr`\n   |\n   = note: expected struct `std::boxed::Box<syn::Expr>`\n                found enum `syn::Expr`\n   = note: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\nhelp: store this in the heap by calling `Box::new`\n   |\n73 ~                                                         expr_repeat.len = Box::new(Expr::Lit(ExprLit {\n74 |                                                             attrs: Vec::new(),\n...\n78 |                                                             )),\n79 ~                                                         }));\n   |\nhelp: consider dereferencing here to assign to the mutably borrowed value\n   |\n73 |                                                         *expr_repeat.len = Expr::Lit(ExprLit {\n   |                                                         +\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Array_Length_33_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:12:20\n   |\n12 |             if let Item::Struct(item_struct) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:14:28\n   |\n14 |                     if let Type::Array(type_array) = &mut field.ty {\n   |                            ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:15:32\n   |\n15 |                         if let Expr::Lit(expr_lit) = &type_array.len {\n   |                                ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0425]: cannot find function `thread_rng` in this scope\n  --> src\\main.rs:18:54\n   |\n18 | ...                   let new_len = if thread_rng().gen_bool(0.5) {\n   |                                        ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  + use rand::thread_rng;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:23:54\n   |\n23 | ...                   type_array.len = Expr::Lit(ExprLit {\n   |                                        ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `ExprLit` in this scope\n  --> src\\main.rs:23:64\n   |\n23 | ...                   type_array.len = Expr::Lit(ExprLit {\n   |                                                  ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::ExprLit;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:27:45\n   |\n27 | ...                   Span::call_site(),\n   |                       ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:37:20\n   |\n37 |             if let Item::Impl(item_impl) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:41:36\n   |\n41 | ...                   if let Stmt::Expr(Expr::Struct(expr_struct)) = stmt {\n   |                              ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:41:47\n   |\n41 | ...                   if let Stmt::Expr(Expr::Struct(expr_struct)) = stmt {\n   |                                         ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:43:44\n   |\n43 | ...                   if let Expr::Array(expr_array) = &mut field.expr {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:44:48\n   |\n44 | ...                   if let Expr::Repeat(expr_repeat) = &mut expr_array.elems[0] {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:45:52\n   |\n45 | ...                   if let Expr::Lit(expr_lit) = &*expr_repeat.len {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0425]: cannot find function `thread_rng` in this scope\n  --> src\\main.rs:48:74\n   |\n48 | ...                   let new_len = if thread_rng().gen_bool(0.5) {\n   |                                        ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  + use rand::thread_rng;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:53:84\n   |\n53 | ...                   expr_repeat.len = Box::new(Expr::Lit(ExprLit {\n   |                                                  ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `ExprLit` in this scope\n  --> src\\main.rs:53:94\n   |\n53 | ...                   expr_repeat.len = Box::new(Expr::Lit(ExprLit {\n   |                                                            ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::ExprLit;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:57:65\n   |\n57 | ...                   Span::call_site(),\n   |                       ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nSome errors have detailed explanations: E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 17 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Array_Length_33_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:8:6\n  |\n8 | impl Mutator for Modify_Array_Length_33 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Array_Length_33_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:45:47\n   |\n45 | ...                   if let Stmt::Expr(Expr::Struct(expr_struct)) = stmt {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n45 |                             if let Stmt::Expr(Expr::Struct(expr_struct), _) = stmt {\n   |                                                                        +++\n\nFor more information about this error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_array_length_33.rs"
    },
    {
        "mutator_name": "Modify_Array_Size_In_Async_Functions_2",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Array_Size_In_Async_Functions_2_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:35:41\n   |\n35 | ...                   if let Some((_, expr)) = &local.init {\n   |                                   ^^^^^^^^^    ----------- this expression has type `&Option<LocalInit>`\n   |                                   |\n   |                                   expected `LocalInit`, found `(_, _)`\n   |\n   = note: expected struct `LocalInit`\n               found tuple `(_, _)`\n\nerror[E0609]: no field `0` on type `&LocalInit`\n  --> src\\main.rs:43:98\n   |\n43 | ...                   init: Some((local.init.as_ref().unwrap().0.clone(), Box::new(new_expr))),\n   |                                                                ^ unknown field\n   |\n   = note: available fields are: `eq_token`, `expr`, `diverge`\n\nSome errors have detailed explanations: E0308, E0609.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_array_size_in_async_functions_2.rs"
    },
    {
        "mutator_name": "Modify_Assignments_In_Match_Arms_115",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Assignments_In_Match_Arms_115_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:34:24\n   |\n34 |                 if let Some(Expr::Path(ExprPath { path, .. })) = expr_match.expr.as_ref() {\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ------------------------ this expression has type `&syn::Expr`\n   |                        |\n   |                        expected `Expr`, found `Option<_>`\n   |\n   = note: expected enum `syn::Expr`\n              found enum `Option<_>`\n\nerror[E0609]: no field `pat` on type `&PatTupleStruct`\n  --> src\\main.rs:39:91\n   |\n39 | ...                   if let Some(Pat::Ident(pat_ident)) = pat_tuple_struct.pat.elems.first() {\n   |                                                                             ^^^ unknown field\n   |\nhelp: a field with a similar name exists\n   |\n39 |                                     if let Some(Pat::Ident(pat_ident)) = pat_tuple_struct.path.elems.first() {\n   |                                                                                              +\n\nerror[E0609]: no field `stmts` on type `std::boxed::Box<syn::Expr>`\n  --> src\\main.rs:41:50\n   |\n41 | ...                   arm.body.stmts.insert(0, parse_quote! {\n   |                                ^^^^^ unknown field\n\nSome errors have detailed explanations: E0308, E0609.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_assignments_in_match_arms_115.rs"
    },
    {
        "mutator_name": "Modify_Associated_Const_Usage_155",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Associated_Const_Usage_155_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:41:52\n   |\n41 | ...                   if let Some((_, fields, _)) = &item_struct.fields {\n   |                              ^^^^^^^^^^^^^^^^^^^^   ------------------- this expression has type `&Fields`\n   |                              |\n   |                              expected `Fields`, found `Option<_>`\n   |\n   = note: expected enum `Fields`\n              found enum `Option<_>`\n\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:44:89\n   |\n44 | ...                   if let Expr::Path(expr_path) = &*type_array.len {\n   |                                                       ^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:52:69\n   |\n52 | ...                   *type_array.len = Box::new(new_expr);\n   |                       ^^^^^^^^^^^^^^^ can't be dereferenced\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Associated_Const_Usage_155_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:44:89\n   |\n44 | ...                   if let Expr::Path(expr_path) = &*type_array.len {\n   |                                                       ^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:52:86\n   |\n52 | ...                   type_array.len = Box::new(new_expr);\n   |                       --------------   ^^^^^^^^^^^^^^^^^^ expected `Expr`, found `Box<Expr>`\n   |                       |\n   |                       expected due to the type of this binding\n   |\n   = note: expected enum `syn::Expr`\n            found struct `std::boxed::Box<syn::Expr>`\nhelp: consider unboxing the value\n   |\n52 |                                                                     type_array.len = *Box::new(new_expr);\n   |                                                                                      +\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Associated_Const_Usage_155_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `as_ref` found for enum `syn::Expr` in the current scope\n  --> src\\main.rs:44:103\n   |\n44 | ...                   if let Expr::Path(expr_path) = type_array.len.as_ref() {\n   |                                                                     ^^^^^^ method not found in `syn::Expr`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:52:86\n   |\n52 | ...                   type_array.len = Box::new(new_expr);\n   |                       --------------   ^^^^^^^^^^^^^^^^^^ expected `Expr`, found `Box<Expr>`\n   |                       |\n   |                       expected due to the type of this binding\n   |\n   = note: expected enum `syn::Expr`\n            found struct `std::boxed::Box<syn::Expr>`\nhelp: consider unboxing the value\n   |\n52 |                                                                     type_array.len = *Box::new(new_expr);\n   |                                                                                      +\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Associated_Const_Usage_155_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:44:89\n   |\n44 | ...                   if let Expr::Path(expr_path) = &*type_array.len {\n   |                                                       ^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:52:86\n   |\n52 | ...                   type_array.len = Box::new(new_expr);\n   |                       --------------   ^^^^^^^^^^^^^^^^^^ expected `Expr`, found `Box<Expr>`\n   |                       |\n   |                       expected due to the type of this binding\n   |\n   = note: expected enum `syn::Expr`\n            found struct `std::boxed::Box<syn::Expr>`\nhelp: consider unboxing the value\n   |\n52 |                                                                     type_array.len = *Box::new(new_expr);\n   |                                                                                      +\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Associated_Const_Usage_155_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0499]: cannot borrow `file.items` as mutable more than once at a time\n  --> src\\main.rs:39:49\n   |\n30 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     first mutable borrow occurs here\n   |                     first borrow later used here\n...\n39 |                                     for item in &mut file.items {\n   |                                                 ^^^^^^^^^^^^^^^ second mutable borrow occurs here\n\nerror[E0594]: cannot assign to `type_array.len`, which is behind a `&` reference\n  --> src\\main.rs:52:69\n   |\n52 | ...                   type_array.len = new_expr;\n   |                       ^^^^^^^^^^^^^^ `type_array` is a `&` reference, so the data it refers to cannot be written\n\nSome errors have detailed explanations: E0499, E0594.\nFor more information about an error, try `rustc --explain E0499`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Associated_Const_Usage_155_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0502]: cannot borrow `file.items` as immutable because it is also borrowed as mutable\n  --> src\\main.rs:40:49\n   |\n31 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     mutable borrow occurs here\n   |                     mutable borrow later used here\n...\n40 |                                     for item in &file.items {\n   |                                                 ^^^^^^^^^^^ immutable borrow occurs here\n\nerror[E0596]: cannot borrow `field.ty` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:70:46\n   |\n69 |         for (field, new_expr) in new_items {\n   |                                  --------- this iterator yields `&` references\n70 |             if let Type::Array(type_array) = &mut field.ty {\n   |                                              ^^^^^^^^^^^^^ `field` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nSome errors have detailed explanations: E0502, E0596.\nFor more information about an error, try `rustc --explain E0502`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_associated_const_usage_155.rs"
    },
    {
        "mutator_name": "Modify_Associated_Type_Lifetimes_142",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Associated_Type_Lifetimes_142_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:29\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                             ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n31 -             if let Item::Fn(ref mut func) = item {\n31 +             if let Item::Fn(func) = item {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_associated_type_lifetimes_142.rs"
    },
    {
        "mutator_name": "Modify_Associated_Type_Lifetime_211",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Associated_Type_Lifetime_211_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `last_segment.arguments.0` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:37:70\n   |\n36 | ...                   if let Some(last_segment) = path.segments.last() {\n   |                                   ------------ consider changing this binding's type to be: `&mut PathSegment`\n37 | ...                       if let PathArguments::AngleBracketed(ref mut args) = last_segment.arguments {\n   |                                                                ^^^^^^^^^^^^ `last_segment` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Associated_Type_Lifetime_211_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:12:20\n   |\n12 |             if let Item::Impl(impl_block) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:15:32\n   |\n15 |                         if let Type::Path(TypePath { path, .. }) = &type_item.ty {\n   |                                ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypePath` in this scope\n  --> src\\main.rs:15:43\n   |\n15 |                         if let Type::Path(TypePath { path, .. }) = &type_item.ty {\n   |                                           ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypePath;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `PathArguments`\n  --> src\\main.rs:17:40\n   |\n17 | ...                   if let PathArguments::AngleBracketed(ref mut args) = last_segment.arguments {\n   |                              ^^^^^^^^^^^^^ use of undeclared type `PathArguments`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::PathArguments;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericArgument`\n  --> src\\main.rs:19:48\n   |\n19 | ...                   if let GenericArgument::Lifetime(lifetime) = arg {\n   |                              ^^^^^^^^^^^^^^^ use of undeclared type `GenericArgument`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericArgument;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:20:62\n   |\n20 | ...                   lifetime.ident = Ident::new(\"d\", lifetime.ident.span());\n   |                                        ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 6 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Associated_Type_Lifetime_211_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `mutate` found for struct `Modify_Associated_Type_Lifetime_211` in the current scope\n  --> src\\main.rs:59:49\n   |\n4  | pub struct Modify_Associated_Type_Lifetime_211;\n   | ---------------------------------------------- method `mutate` not found for this struct\n...\n59 |             Modify_Associated_Type_Lifetime_211.mutate(&mut file_ast);\n   |                                                 ^^^^^^ method not found in `Modify_Associated_Type_Lifetime_211`\n   |\n  ::: src\\mutator.rs:15:8\n   |\n15 |     fn mutate(&self, file: &mut syn::File);\n   |        ------ the method is available for `Modify_Associated_Type_Lifetime_211` here\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: trait `Mutator` which provides `mutate` is implemented but not in scope; perhaps you want to import it\n   |\n1  + use crate::mutator::Mutator;\n   |\n\nerror[E0596]: cannot borrow `path.segments` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:17:57\n   |\n17 | ...                   if let Some(last_segment) = path.segments.last_mut() {\n   |                                                   ^^^^^^^^^^^^^ `path` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nSome errors have detailed explanations: E0596, E0599.\nFor more information about an error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Associated_Type_Lifetime_211_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:21:62\n   |\n21 | ...                   lifetime.ident = Ident::new(\"d\", lifetime.ident.span());\n   |                                        ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nFor more information about this error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Associated_Type_Lifetime_211_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Modify_Associated_Type_Lifetime_211 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Associated_Type_Lifetime_211_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:21:62\n   |\n21 | ...                   lifetime.ident = Lifetime::new(\"'d\", lifetime.ident.span());\n   |                       --------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Ident`, found `Lifetime`\n   |                       |\n   |                       expected due to the type of this binding\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Associated_Type_Lifetime_211_compling_err_7.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.91s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:21:62:\n\"'d\" is not a valid Ident\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Associated_Type_Lifetime_211_compling_err_8.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.65s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:21:62:\n\"'d\" is not a valid Ident\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_associated_type_lifetime_211.rs"
    },
    {
        "mutator_name": "Modify_Async_Function_Signature_119",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Async_Function_Signature_119_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:33:43\n   |\n33 |                     if let syn::ImplItem::Method(method) = item {\n   |                                           ^^^^^^ variant or associated item not found in `ImplItem`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Async_Function_Signature_119_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.93s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:38:58:\nunexpected end of input, expected an expression\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_async_function_signature_119.rs"
    },
    {
        "mutator_name": "Modify_Closure_Capture_131",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Closure_Capture_131_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:34:43\n   |\n34 |                         if let Stmt::Expr(Expr::Closure(closure)) = stmt {\n   |                                           ^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n34 |                         if let Stmt::Expr(Expr::Closure(closure), _) = stmt {\n   |                                                                 +++\n\nerror[E0609]: no field `stmts` on type `&mut ExprBlock`\n  --> src\\main.rs:41:65\n   |\n41 | ...                   if let Some(first_stmt) = block.stmts.first_mut() {\n   |                                                       ^^^^^ unknown field\n   |\nhelp: one of the expressions' fields has a field of the same name\n   |\n41 |                                 if let Some(first_stmt) = block.block.stmts.first_mut() {\n   |                                                                 ++++++\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:43:53\n   |\n43 | ...                   if let Some((_, expr)) = &mut local.init {\n   |                                   ^^^^^^^^^    --------------- this expression has type `&mut Option<LocalInit>`\n   |                                   |\n   |                                   expected `LocalInit`, found `(_, _)`\n   |\n   = note: expected struct `LocalInit`\n               found tuple `(_, _)`\n\nSome errors have detailed explanations: E0023, E0308, E0609.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Closure_Capture_131_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:43:53\n   |\n43 | ...                   if let Some((_, expr)) = &mut local.init {\n   |                                   ^^^^^^^^^    --------------- this expression has type `&mut Option<LocalInit>`\n   |                                   |\n   |                                   expected `LocalInit`, found `(_, _)`\n   |\n   = note: expected struct `LocalInit`\n               found tuple `(_, _)`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Closure_Capture_131_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:34:43\n   |\n34 |                         if let Stmt::Expr(Expr::Closure(closure)) = stmt {\n   |                                           ^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n34 |                         if let Stmt::Expr(Expr::Closure(closure), _) = stmt {\n   |                                                                 +++\n\nerror[E0609]: no field `1` on type `&mut LocalInit`\n  --> src\\main.rs:44:50\n   |\n44 | ...                   init.1 = Box::new(parse_quote!(buffer));\n   |                            ^ unknown field\n   |\n   = note: available fields are: `eq_token`, `expr`, `diverge`\n\nSome errors have detailed explanations: E0023, E0609.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Closure_Capture_131_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0499]: cannot borrow `item_fn.block.stmts` as mutable more than once at a time\n  --> src\\main.rs:38:29\n   |\n33 |                     for stmt in &mut item_fn.block.stmts {\n   |                                 ------------------------\n   |                                 |\n   |                                 first mutable borrow occurs here\n   |                                 first borrow later used here\n...\n38 |                             item_fn.block.stmts.insert(0, new_var);\n   |                             ^^^^^^^^^^^^^^^^^^^ second mutable borrow occurs here\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Closure_Capture_131_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:13:41\n   |\n13 |                     let new_var: Stmt = parse_quote! {\n   |                                         ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:24:66\n   |\n24 | ...                   init.expr = Box::new(parse_quote!(buffer));\n   |                                            ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Fn(item_fn) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0412]: cannot find type `Stmt` in this scope\n  --> src\\main.rs:13:34\n   |\n13 |                     let new_var: Stmt = parse_quote! {\n   |                                  ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:19:32\n   |\n19 |                         if let Stmt::Expr(Expr::Closure(closure)) = stmt {\n   |                                ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:19:43\n   |\n19 |                         if let Stmt::Expr(Expr::Closure(closure)) = stmt {\n   |                                           ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:20:36\n   |\n20 | ...                   if let Expr::Block(block) = &mut *closure.body {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:22:44\n   |\n22 | ...                   if let Stmt::Local(local) = first_stmt {\n   |                              ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 8 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Closure_Capture_131_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Modify_Closure_Capture_131 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Closure_Capture_131_compling_err_7.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:20:43\n   |\n20 |                         if let Stmt::Expr(Expr::Closure(closure)) = stmt {\n   |                                           ^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n20 |                         if let Stmt::Expr(Expr::Closure(closure), _) = stmt {\n   |                                                                 +++\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:24:53\n   |\n24 | ...                   if let Some((_, init)) = &mut local.init {\n   |                                   ^^^^^^^^^    --------------- this expression has type `&mut Option<LocalInit>`\n   |                                   |\n   |                                   expected `LocalInit`, found `(_, _)`\n   |\n   = note: expected struct `LocalInit`\n               found tuple `(_, _)`\n\nSome errors have detailed explanations: E0023, E0308.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_closure_capture_131.rs"
    },
    {
        "mutator_name": "Modify_Const_Array_Type_37",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_const_array_type_37.rs"
    },
    {
        "mutator_name": "Modify_Const_Expressions_In_Generic_Constraints_65",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Expressions_In_Generic_Constraints_65_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:50:104\n   |\n50 | ...                   brace_token: syn::token::Brace { span: Span::call_site() },\n   |                                                              ^^^^^^^^^^^^^^^^^ expected `DelimSpan`, found `Span`\n\nerror[E0061]: this enum variant takes 2 arguments but 1 argument was supplied\n  --> src\\main.rs:51:77\n   |\n51 | ...                   stmts: vec![Stmt::Expr(new_expr)],\n   |                                   ^^^^^^^^^^---------- argument #2 of type `Option<Semi>` is missing\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:9\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |         ^^^^\nhelp: provide the argument\n   |\n51 |                                                                 stmts: vec![Stmt::Expr(new_expr, /* Option<Semi> */)],\n   |                                                                                                ++++++++++++++++++++\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_const_expressions_in_generic_constraints_65.rs"
    },
    {
        "mutator_name": "Modify_Const_Expr_In_Assoc_Type_217",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Expr_In_Assoc_Type_217_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0609]: no field `params` on type `&syn::Path`\n  --> src\\main.rs:33:33\n   |\n33 |                     if generics.params.iter().any(|param| matches!(param, GenericParam::Const(_))) {\n   |                                 ^^^^^^ unknown field\n   |\n   = note: available fields are: `leading_colon`, `segments`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:36:40\n   |\n36 | ...                   if let Some(expr) = &mut impl_type.ty {\n   |                              ^^^^^^^^^^   ----------------- this expression has type `&mut syn::Type`\n   |                              |\n   |                              expected `Type`, found `Option<_>`\n   |\n   = note: expected enum `syn::Type`\n              found enum `Option<_>`\n\nSome errors have detailed explanations: E0308, E0609.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_const_expr_in_assoc_type_217.rs"
    },
    {
        "mutator_name": "Modify_Const_Fn_Return_Type_98",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Fn_Return_Type_98_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:29\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                             ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n31 -             if let Item::Fn(ref mut func) = item {\n31 +             if let Item::Fn(func) = item {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:36:62\n   |\n36 | ...                   if let TypeParamBound::Trait(ref mut trait_bound) = bound {\n   |                                                    ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:36:40\n   |\n36 | ...                   if let TypeParamBound::Trait(ref mut trait_bound) = bound {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n36 -                                 if let TypeParamBound::Trait(ref mut trait_bound) = bound {\n36 +                                 if let TypeParamBound::Trait(trait_bound) = bound {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Fn_Return_Type_98_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Fn(func) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `ReturnType`\n  --> src\\main.rs:13:28\n   |\n13 |                     if let ReturnType::Type(_, ref mut ty) = func.sig.output {\n   |                            ^^^^^^^^^^ use of undeclared type `ReturnType`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::ReturnType;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:14:32\n   |\n14 |                         if let Type::ImplTrait(ref mut impl_trait) = **ty {\n   |                                ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TypeParamBound`\n  --> src\\main.rs:16:40\n   |\n16 | ...                   if let TypeParamBound::Trait(trait_bound) = bound {\n   |                              ^^^^^^^^^^^^^^ use of undeclared type `TypeParamBound`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TypeParamBound;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:18:54\n   |\n18 | ...                   path.ident = Ident::new(\"~const\", path.ident.span());\n   |                                    ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nFor more information about this error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 5 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Fn_Return_Type_98_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:6:6\n  |\n6 | impl Mutator for Modify_Const_Fn_Return_Type_98 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Fn_Return_Type_98_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.94s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:20:54:\n\"~const\" is not a valid Ident\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_const_fn_return_type_98.rs"
    },
    {
        "mutator_name": "Modify_Const_Function_In_Trait_Impl_128",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Function_In_Trait_Impl_128_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:33:43\n   |\n33 |                     if let syn::ImplItem::Method(method) = impl_item {\n   |                                           ^^^^^^ variant or associated item not found in `ImplItem`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Function_In_Trait_Impl_128_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0432]: unresolved import `syn::ImplItemMethod`\n --> src\\main.rs:1:21\n  |\n1 | use syn::{ImplItem, ImplItemMethod};\n  |                     ^^^^^^^^^^^^^^\n  |                     |\n  |                     no `ImplItemMethod` in the root\n  |                     help: a similar name exists in the module: `ImplItemMacro`\n\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Modify_Const_Function_In_Trait_Impl_128 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Impl(item_impl) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nSome errors have detailed explanations: E0405, E0432, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Function_In_Trait_Impl_128_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:13:38\n   |\n13 |                     if let ImplItem::Method(method) = impl_item {\n   |                                      ^^^^^^ variant or associated item not found in `ImplItem`\n\nerror[E0599]: no method named `mutate` found for struct `Modify_Const_Function_In_Trait_Impl_128` in the current scope\n  --> src\\main.rs:48:53\n   |\n3  | pub struct Modify_Const_Function_In_Trait_Impl_128;\n   | -------------------------------------------------- method `mutate` not found for this struct\n...\n48 |             Modify_Const_Function_In_Trait_Impl_128.mutate(&mut file_ast);\n   |                                                     ^^^^^^ method not found in `Modify_Const_Function_In_Trait_Impl_128`\n   |\n  ::: src\\mutator.rs:15:8\n   |\n15 |     fn mutate(&self, file: &mut syn::File);\n   |        ------ the method is available for `Modify_Const_Function_In_Trait_Impl_128` here\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: trait `Mutator` which provides `mutate` is implemented but not in scope; perhaps you want to import it\n   |\n1  + use crate::mutator::Mutator;\n   |\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Function_In_Trait_Impl_128_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `mutate` found for struct `Modify_Const_Function_In_Trait_Impl_128` in the current scope\n  --> src\\main.rs:48:53\n   |\n3  | pub struct Modify_Const_Function_In_Trait_Impl_128;\n   | -------------------------------------------------- method `mutate` not found for this struct\n...\n48 |             Modify_Const_Function_In_Trait_Impl_128.mutate(&mut file_ast);\n   |                                                     ^^^^^^ method not found in `Modify_Const_Function_In_Trait_Impl_128`\n   |\n  ::: src\\mutator.rs:15:8\n   |\n15 |     fn mutate(&self, file: &mut syn::File);\n   |        ------ the method is available for `Modify_Const_Function_In_Trait_Impl_128` here\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: trait `Mutator` which provides `mutate` is implemented but not in scope; perhaps you want to import it\n   |\n1  + use crate::mutator::Mutator;\n   |\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_const_function_in_trait_impl_128.rs"
    },
    {
        "mutator_name": "Modify_Const_Function_Param_153",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Function_Param_153_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0277]: the trait bound `FunctionVisitor<'a>: ToTokens` is not satisfied\n  --> src\\main.rs:48:60\n   |\n48 |   ...                   let new_const_expr: Expr = parse_quote! {\n   |  __________________________________________________^\n49 | | ...                       const #self.const_ident: usize = 2 * 2\n50 | | ...                   };\n   | |                       ^\n   | |                       |\n   | |_______________________the trait `ToTokens` is not implemented for `FunctionVisitor<'a>`\n   |                         required by a bound introduced by this call\n   |\n   = help: the following other types implement trait `ToTokens`:\n             &'a T\n             &'a mut T\n             Abstract\n             AndAnd\n             AndEq\n             AngleBracketedGenericArguments\n             Arm\n             As\n           and 306 others\n   = note: required for `&mut FunctionVisitor<'a>` to implement `ToTokens`\n   = note: this error originates in the macro `$crate::quote_token_with_context` which comes from the expansion of the macro `parse_quote` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the trait bound `FunctionVisitor<'a>: ToTokens` is not satisfied\n  --> src\\main.rs:51:47\n   |\n51 | ...                   new_args.push(parse_quote!(#self.const_ident));\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |                                     |\n   |                                     the trait `ToTokens` is not implemented for `FunctionVisitor<'a>`\n   |                                     required by a bound introduced by this call\n   |\n   = help: the following other types implement trait `ToTokens`:\n             &'a T\n             &'a mut T\n             Abstract\n             AndAnd\n             AndEq\n             AngleBracketedGenericArguments\n             Arm\n             As\n           and 306 others\n   = note: required for `&mut FunctionVisitor<'a>` to implement `ToTokens`\n   = note: this error originates in the macro `$crate::quote_token_with_context` which comes from the expansion of the macro `parse_quote` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Function_Param_153_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0277]: the trait bound `FunctionVisitor<'a>: ToTokens` is not satisfied\n  --> src\\main.rs:51:47\n   |\n51 | ...                   new_args.push(parse_quote!(#self.const_ident));\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |                                     |\n   |                                     the trait `ToTokens` is not implemented for `FunctionVisitor<'a>`\n   |                                     required by a bound introduced by this call\n   |\n   = help: the following other types implement trait `ToTokens`:\n             &'a T\n             &'a mut T\n             Abstract\n             AndAnd\n             AndEq\n             AngleBracketedGenericArguments\n             Arm\n             As\n           and 306 others\n   = note: required for `&mut FunctionVisitor<'a>` to implement `ToTokens`\n   = note: this error originates in the macro `$crate::quote_token_with_context` which comes from the expansion of the macro `parse_quote` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Function_Param_153_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.10s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:48:60:\nexpected `|`\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Function_Param_153_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.79s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:48:60:\nexpected `|`\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_const_function_param_153.rs"
    },
    {
        "mutator_name": "Modify_Const_Function_Return_Type_66",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Function_Return_Type_66_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.79s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:41:74:\n\"!Sized\" is not a valid Ident\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_const_function_return_type_66.rs"
    },
    {
        "mutator_name": "Modify_Const_Function_To_In_Line_Closure_45",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Function_To_In_Line_Closure_45_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n  --> src\\main.rs:30:32\n   |\n30 |         let mut const_fn_map = HashMap::new();\n   |                                ^^^^^^^ use of undeclared type `HashMap`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use crate::collections::HashMap;\n   |\n1  + use std::collections::HashMap;\n   |\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:48:37\n   |\n48 |                         if let Some((_, expr)) = &local.init {\n   |                                     ^^^^^^^^^    ----------- this expression has type `&Option<LocalInit>`\n   |                                     |\n   |                                     expected `LocalInit`, found `(_, _)`\n   |\n   = note: expected struct `LocalInit`\n               found tuple `(_, _)`\n\nerror[E0609]: no field `0` on type `&LocalInit`\n  --> src\\main.rs:55:90\n   |\n55 | ...                   init: Some((local.init.as_ref().unwrap().0.clone(), Box::new(Expr::Closure(closure.clone())))),\n   |                                                                ^ unknown field\n   |\n   = note: available fields are: `eq_token`, `expr`, `diverge`\n\nSome errors have detailed explanations: E0308, E0433, E0609.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Function_To_In_Line_Closure_45_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Modify_Const_Function_To_In_Line_Closure_45 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:13:20\n   |\n13 |             if let Item::Const(item_const) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:14:24\n   |\n14 |                 if let Type::Path(type_path) = &*item_const.ty {\n   |                        ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:16:32\n   |\n16 |                         if let Expr::Closure(closure) = &*item_const.expr {\n   |                                ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:25:20\n   |\n25 |             if let Item::Fn(item_fn) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:27:28\n   |\n27 |                     if let Stmt::Local(local) = stmt {\n   |                            ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:29:36\n   |\n29 | ...                   if let Expr::Reference(expr_ref) = &*init.expr {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:30:40\n   |\n30 | ...                   if let Expr::Path(expr_path) = &*expr_ref.expr {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:33:53\n   |\n33 | ...                   *stmt = Stmt::Local(Local {\n   |                               ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `Local` in this scope\n  --> src\\main.rs:33:65\n   |\n33 | ...                   *stmt = Stmt::Local(Local {\n   |                                           ^^^^^ not found in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Local;\n   |\n1  + use syn::Stmt::Local;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `LocalInit` in this scope\n  --> src\\main.rs:35:60\n   |\n35 | ...                   init: Some(LocalInit {\n   |                                  ^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::LocalInit;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:37:68\n   |\n37 | ...                   expr: Box::new(Expr::Closure(closure.clone())),\n   |                                      ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nSome errors have detailed explanations: E0405, E0422, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 12 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Function_To_In_Line_Closure_45_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n  --> src\\main.rs:11:32\n   |\n11 |         let mut const_fn_map = HashMap::new();\n   |                                ^^^^^^^ use of undeclared type `HashMap`\n   |\nhelp: consider importing this struct\n   |\n1  + use std::collections::HashMap;\n   |\n\nFor more information about this error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Function_To_In_Line_Closure_45_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Modify_Const_Function_To_In_Line_Closure_45 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:13:20\n   |\n13 |             if let Item::Const(item_const) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:14:24\n   |\n14 |                 if let Type::Path(type_path) = &*item_const.ty {\n   |                        ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:16:32\n   |\n16 |                         if let Expr::Closure(closure) = &*item_const.expr {\n   |                                ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:25:20\n   |\n25 |             if let Item::Fn(item_fn) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:27:28\n   |\n27 |                     if let Stmt::Local(local) = stmt {\n   |                            ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:29:36\n   |\n29 | ...                   if let Expr::Reference(expr_ref) = &*init.expr {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:30:40\n   |\n30 | ...                   if let Expr::Path(expr_path) = &*expr_ref.expr {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:33:53\n   |\n33 | ...                   *stmt = Stmt::Local(Local {\n   |                               ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `Local` in this scope\n  --> src\\main.rs:33:65\n   |\n33 | ...                   *stmt = Stmt::Local(Local {\n   |                                           ^^^^^ not found in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Local;\n   |\n1  + use syn::Stmt::Local;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `LocalInit` in this scope\n  --> src\\main.rs:35:60\n   |\n35 | ...                   init: Some(LocalInit {\n   |                                  ^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::LocalInit;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:37:68\n   |\n37 | ...                   expr: Box::new(Expr::Closure(closure.clone())),\n   |                                      ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nSome errors have detailed explanations: E0405, E0422, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 12 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Function_To_In_Line_Closure_45_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n  --> src\\main.rs:11:32\n   |\n11 |         let mut const_fn_map = HashMap::new();\n   |                                ^^^^^^^ use of undeclared type `HashMap`\n   |\nhelp: consider importing this struct\n   |\n1  + use std::collections::HashMap;\n   |\n\nFor more information about this error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Function_To_In_Line_Closure_45_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Modify_Const_Function_To_In_Line_Closure_45 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:13:20\n   |\n13 |             if let Item::Const(item_const) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:14:24\n   |\n14 |                 if let Type::Path(type_path) = &*item_const.ty {\n   |                        ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:16:32\n   |\n16 |                         if let Expr::Closure(closure) = &*item_const.expr {\n   |                                ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:25:20\n   |\n25 |             if let Item::Fn(item_fn) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:27:28\n   |\n27 |                     if let Stmt::Local(local) = stmt {\n   |                            ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:29:36\n   |\n29 | ...                   if let Expr::Reference(expr_ref) = &*init.expr {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:30:40\n   |\n30 | ...                   if let Expr::Path(expr_path) = &*expr_ref.expr {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:33:53\n   |\n33 | ...                   *stmt = Stmt::Local(Local {\n   |                               ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `Local` in this scope\n  --> src\\main.rs:33:65\n   |\n33 | ...                   *stmt = Stmt::Local(Local {\n   |                                           ^^^^^ not found in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Local;\n   |\n1  + use syn::Stmt::Local;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `LocalInit` in this scope\n  --> src\\main.rs:35:60\n   |\n35 | ...                   init: Some(LocalInit {\n   |                                  ^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::LocalInit;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:37:68\n   |\n37 | ...                   expr: Box::new(Expr::Closure(closure.clone())),\n   |                                      ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nSome errors have detailed explanations: E0405, E0422, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 12 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Function_To_In_Line_Closure_45_compling_err_7.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n  --> src\\main.rs:11:32\n   |\n11 |         let mut const_fn_map = HashMap::new();\n   |                                ^^^^^^^ use of undeclared type `HashMap`\n   |\nhelp: consider importing this struct\n   |\n1  + use std::collections::HashMap;\n   |\n\nFor more information about this error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Function_To_In_Line_Closure_45_compling_err_8.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Modify_Const_Function_To_In_Line_Closure_45 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:13:20\n   |\n13 |             if let Item::Const(item_const) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:14:24\n   |\n14 |                 if let Type::Path(type_path) = &*item_const.ty {\n   |                        ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:16:32\n   |\n16 |                         if let Expr::Closure(closure) = &*item_const.expr {\n   |                                ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:25:20\n   |\n25 |             if let Item::Fn(item_fn) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:27:28\n   |\n27 |                     if let Stmt::Local(local) = stmt {\n   |                            ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:29:36\n   |\n29 | ...                   if let Expr::Reference(expr_ref) = &*init.expr {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:30:40\n   |\n30 | ...                   if let Expr::Path(expr_path) = &*expr_ref.expr {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:33:53\n   |\n33 | ...                   *stmt = Stmt::Local(Local {\n   |                               ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `Local` in this scope\n  --> src\\main.rs:33:65\n   |\n33 | ...                   *stmt = Stmt::Local(Local {\n   |                                           ^^^^^ not found in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Local;\n   |\n1  + use syn::Stmt::Local;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `LocalInit` in this scope\n  --> src\\main.rs:35:60\n   |\n35 | ...                   init: Some(LocalInit {\n   |                                  ^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::LocalInit;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:37:68\n   |\n37 | ...                   expr: Box::new(Expr::Closure(closure.clone())),\n   |                                      ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nSome errors have detailed explanations: E0405, E0422, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 12 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Function_To_In_Line_Closure_45_compling_err_9.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n  --> src\\main.rs:11:32\n   |\n11 |         let mut const_fn_map = HashMap::new();\n   |                                ^^^^^^^ use of undeclared type `HashMap`\n   |\nhelp: consider importing this struct\n   |\n1  + use std::collections::HashMap;\n   |\n\nFor more information about this error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_const_function_to_in_line_closure_45.rs"
    },
    {
        "mutator_name": "Modify_Const_Generics_148",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generics_148_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:38:57\n   |\n38 | ...                   if item_impl.self_ty == &item_struct.ident {\n   |                          -----------------    ^^^^^^^^^^^^^^^^^^ expected `Box<Type>`, found `&Ident`\n   |                          |\n   |                          expected because this is `std::boxed::Box<syn::Type>`\n   |\n   = note: expected struct `std::boxed::Box<syn::Type>`\n           found reference `&proc_macro2::Ident`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:40:63\n   |\n40 | ...                   if let syn::ImplItem::Method(method) = item {\n   |                                             ^^^^^^ variant or associated item not found in `ImplItem`\n\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:42:93\n   |\n42 | ...                   if let Type::Path(TypePath { path, .. }) = &**ty {\n   |                                                                   ^^^^ can't be dereferenced\n\nSome errors have detailed explanations: E0308, E0599, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generics_148_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0499]: cannot borrow `file.items` as mutable more than once at a time\n  --> src\\main.rs:36:42\n   |\n32 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     first mutable borrow occurs here\n   |                     first borrow later used here\n...\n36 |                         for impl_item in &mut file.items {\n   |                                          ^^^^^^^^^^^^^^^ second mutable borrow occurs here\n\nerror[E0596]: cannot borrow `path.segments` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:44:76\n   |\n44 | ...                   let last_segment = path.segments.last_mut().unwrap();\n   |                                          ^^^^^^^^^^^^^ `path` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nSome errors have detailed explanations: E0499, E0596.\nFor more information about an error, try `rustc --explain E0499`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generics_148_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `path.segments` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:52:69\n   |\n52 | ...                   if let Some(last_segment) = path.segments.last_mut() {\n   |                                                   ^^^^^^^^^^^^^ `path` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generics_148_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0594]: cannot assign to `*expr`, which is behind a `&` reference\n  --> src\\main.rs:56:53\n   |\n56 | ...                   *expr = external_const;\n   |                       ^^^^^ `expr` is a `&` reference, so the data it refers to cannot be written\n\nFor more information about this error, try `rustc --explain E0594`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generics_148_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `last_segment.arguments` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:53:90\n   |\n52 | ...                   if let Some(last_segment) = path.segments.last() {\n   |                                   ------------ consider changing this binding's type to be: `&mut PathSegment`\n53 | ...                       if let PathArguments::AngleBracketed(args) = &mut last_segment.arguments {\n   |                                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^ `last_segment` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generics_148_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `path.segments` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:52:69\n   |\n52 | ...                   if let Some(last_segment) = path.segments.last_mut() {\n   |                                                   ^^^^^^^^^^^^^ `path` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_const_generics_148.rs"
    },
    {
        "mutator_name": "Modify_Const_Generics_151",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generics_151_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:33:24\n   |\n33 |                 if let Some((_, generics, _)) = &item_struct.generics.split_for_impl() {\n   |                        ^^^^^^^^^^^^^^^^^^^^^^   -------------------------------------- this expression has type `&(ImplGenerics<'_>, TypeGenerics<'_>, Option<&WhereClause>)`\n   |                        |\n   |                        expected `(ImplGenerics<'_>, ..., ...)`, found `Option<_>`\n   |\n   = note: expected tuple `(ImplGenerics<'_>, TypeGenerics<'_>, Option<&WhereClause>)`\n               found enum `Option<_>`\n\nerror[E0308]: mismatched types\n   --> src\\main.rs:46:63\n    |\n46  | ...                   modified_param.default = Some((token::Eq(Span::call_site()), new_default));\n    |                                                ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Expr`, found `(Eq, Expr)`\n    |                                                |\n    |                                                arguments to this enum variant are incorrect\n    |\n    = note: expected enum `syn::Expr`\n              found tuple `(syn::token::Eq, syn::Expr)`\nhelp: the type constructed contains `(syn::token::Eq, syn::Expr)` due to the type of the argument passed\n   --> src\\main.rs:46:58\n    |\n46  | ...                   modified_param.default = Some((token::Eq(Span::call_site()), new_default));\n    |                                                ^^^^^-------------------------------------------^\n    |                                                     |\n    |                                                     this argument influences the type of `Some`\nnote: tuple variant defined here\n   --> C:\\Users\\love\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\option.rs:597:5\n    |\n597 |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    |     ^^^^\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_const_generics_151.rs"
    },
    {
        "mutator_name": "Modify_Const_Generics_200",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generics_200_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:33:24\n   |\n33 |                   if let Some(generics) = &mut item_struct.generics.params.iter_mut().filter_map(|param| {\n   |  ________________________^^^^^^^^^^^^^^___-\n   | |                        |\n   | |                        expected `Vec<&mut ConstParam>`, found `Option<_>`\n34 | |                     if let GenericParam::Const(const_param) = param {\n35 | |                         Some(const_param)\n36 | |                     } else {\n...  |\n39 | |                 }).collect::<Vec<_>>() {\n   | |______________________________________- this expression has type `&mut Vec<&mut ConstParam>`\n   |\n   = note: expected struct `Vec<&mut ConstParam>`\n                found enum `Option<_>`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_const_generics_200.rs"
    },
    {
        "mutator_name": "Modify_Const_Generics_In_Function_Signature_74",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generics_In_Function_Signature_74_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:36:65\n   |\n36 | ...                   if let Expr::Path(expr_path) = &*type_array.len {\n   |                                                       ^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:40:62\n   |\n40 | ...                   type_array.len = Box::new(new_expr);\n   |                       --------------   ^^^^^^^^^^^^^^^^^^ expected `Expr`, found `Box<Expr>`\n   |                       |\n   |                       expected due to the type of this binding\n   |\n   = note: expected enum `syn::Expr`\n            found struct `std::boxed::Box<syn::Expr>`\nhelp: consider unboxing the value\n   |\n40 |                                             type_array.len = *Box::new(new_expr);\n   |                                                              +\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generics_In_Function_Signature_74_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0594]: cannot assign to `type_array.len`, which is behind a `&` reference\n  --> src\\main.rs:40:45\n   |\n40 | ...                   type_array.len = new_expr;\n   |                       ^^^^^^^^^^^^^^ `type_array` is a `&` reference, so the data it refers to cannot be written\n\nFor more information about this error, try `rustc --explain E0594`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generics_In_Function_Signature_74_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:40:62\n   |\n40 | ...                   type_array.len = Box::new(new_expr);\n   |                       --------------   ^^^^^^^^^^^^^^^^^^ expected `Expr`, found `Box<Expr>`\n   |                       |\n   |                       expected due to the type of this binding\n   |\n   = note: expected enum `syn::Expr`\n            found struct `std::boxed::Box<syn::Expr>`\nhelp: consider unboxing the value\n   |\n40 |                                             type_array.len = *Box::new(new_expr);\n   |                                                              +\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_const_generics_in_function_signature_74.rs"
    },
    {
        "mutator_name": "Modify_Const_Generics_With_Default_Values_166",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generics_With_Default_Values_166_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0499]: cannot borrow `file.items` as mutable more than once at a time\n  --> src\\main.rs:44:38\n   |\n30 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     first mutable borrow occurs here\n   |                     first borrow later used here\n...\n44 |                     for impl_item in &mut file.items {\n   |                                      ^^^^^^^^^^^^^^^ second mutable borrow occurs here\n\nerror[E0499]: cannot borrow `impl_block.generics.params` as mutable more than once at a time\n  --> src\\main.rs:52:49\n   |\n48 | ...                   for param in &mut impl_block.generics.params {\n   |                                    ------------------------------- first mutable borrow occurs here\n...\n52 | ...                               impl_block.generics.params.push(GenericParam::Const(syn::ConstParam {\n   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^ second mutable borrow occurs here\n...\n55 | ...                                   ident: const_param.ident.clone(),\n   |                                              ----------------- first borrow later used here\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generics_With_Default_Values_166_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0499]: cannot borrow `new_params` as mutable more than once at a time\n  --> src\\main.rs:60:37\n   |\n56 |                         for param in &mut new_params {\n   |                                      --------------- first mutable borrow occurs here\n...\n60 |                                     new_params.push(GenericParam::Const(syn::ConstParam {\n   |                                     ^^^^^^^^^^ second mutable borrow occurs here\n...\n63 |                                         ident: const_param.ident.clone(),\n   |                                                ----------------- first borrow later used here\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_const_generics_with_default_values_166.rs"
    },
    {
        "mutator_name": "Modify_Const_Generic_Arithmetic_50",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Arithmetic_50_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:41:51\n   |\n41 | ...                   if let syn::ImplItem::Method(method) = impl_item {\n   |                                             ^^^^^^ variant or associated item not found in `ImplItem`\n\nerror[E0277]: `&PathArguments` is not an iterator\n  --> src\\main.rs:46:56\n   |\n46 | ...                   for arg in &last_segment.arguments {\n   |                                  ^^^^^^^^^^^^^^^^^^^^^^^ `&PathArguments` is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented for `&PathArguments`\n   = note: required for `&PathArguments` to implement `IntoIterator`\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Arithmetic_50_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:58:64\n   |\n58 | ...                   *return_type = Type::Path(new_path);\n   |                       ------------   ^^^^^^^^^^^^^^^^^^^^ expected `Box<Type>`, found `Type`\n   |                       |\n   |                       expected due to the type of this binding\n   |\n   = note: expected struct `std::boxed::Box<syn::Type>`\n                found enum `syn::Type`\n   = note: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\nhelp: store this in the heap by calling `Box::new`\n   |\n58 |                                                 *return_type = Box::new(Type::Path(new_path));\n   |                                                                +++++++++                    +\nhelp: consider dereferencing here to assign to the mutably borrowed value\n   |\n58 |                                                 **return_type = Type::Path(new_path);\n   |                                                 +\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Arithmetic_50_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0282]: type annotations needed for `syn::punctuated::Punctuated<GenericArgument, _>`\n  --> src\\main.rs:46:53\n   |\n46 | ...                   let mut new_args = Punctuated::new();\n   |                           ^^^^^^^^^^^^   ----------------- type must be known at this point\n   |\nhelp: consider giving `new_args` an explicit type, where the type for type parameter `P` is specified\n   |\n46 |                                                 let mut new_args: syn::punctuated::Punctuated<_, P> = Punctuated::new();\n   |                                                                 +++++++++++++++++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Arithmetic_50_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0382]: use of moved value: `items`\n   --> src\\main.rs:40:42\n    |\n33  |                 items,\n    |                 -----\n    |                 |\n    |                 this reinitialization might get skipped\n    |                 move occurs because `items` has type `&mut Vec<ImplItem>`, which does not implement the `Copy` trait\n...\n37  |                 for generic in &generics.params {\n    |                 ------------------------------- inside of this loop\n...\n40  |                         for impl_item in items {\n    |                                          ^^^^^ `items` moved due to this implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote: `into_iter` takes ownership of the receiver `self`, which moves `items`\n   --> C:\\Users\\love\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\iter\\traits\\collect.rs:313:18\n    |\n313 |     fn into_iter(self) -> Self::IntoIter;\n    |                  ^^^^\nhelp: consider creating a fresh reborrow of `items` here\n    |\n40  |                         for impl_item in &mut *items {\n    |                                          ++++++\n\nFor more information about this error, try `rustc --explain E0382`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_const_generic_arithmetic_50.rs"
    },
    {
        "mutator_name": "Modify_Const_Generic_Bounds_67",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_const_generic_bounds_67.rs"
    },
    {
        "mutator_name": "Modify_Const_Generic_Expressions_209",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Expressions_209_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: the method `as_mut` exists for mutable reference `&mut Expr`, but its trait bounds were not satisfied\n   --> src\\main.rs:35:72\n    |\n35  |   ...                   if let Expr::Binary(expr_binary) = default.as_mut() {\n    |                                                                    ^^^^^^ method cannot be called on `&mut Expr` due to unsatisfied trait bounds\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\expr.rs:35:1\n    |\n35  | / ast_enum_of_structs! {\n36  | |     /// A Rust expression.\n37  | |     ///\n38  | |     /// *This type is available only if Syn is built with the `\"derive\"` or `\"full\"`\n...   |\n267 | | }\n    | |_- doesn't satisfy `syn::Expr: AsMut<_>`\n    |\n    = note: the following trait bounds were not satisfied:\n            `syn::Expr: AsMut<_>`\n            which is required by `&mut syn::Expr: AsMut<_>`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:38:44\n   |\n38 | ...                   *default = Box::new(new_condition);\n   |                       --------   ^^^^^^^^^^^^^^^^^^^^^^^ expected `Expr`, found `Box<Expr>`\n   |                       |\n   |                       expected due to the type of this binding\n   |\n   = note: expected enum `syn::Expr`\n            found struct `std::boxed::Box<syn::Expr>`\nhelp: consider unboxing the value\n   |\n38 |                                 *default = *Box::new(new_condition);\n   |                                            +\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_const_generic_expressions_209.rs"
    },
    {
        "mutator_name": "Modify_Const_Generic_Lifetimes_68",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Lifetimes_68_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `as_ref` found for enum `syn::Type` in the current scope\n  --> src\\main.rs:41:81\n   |\n41 |                         if let Some(Type::Reference(type_ref)) = const_param.ty.as_ref() {\n   |                                                                                 ^^^^^^ method not found in `syn::Type`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:48:50\n   |\n48 |   ...                   const_param.ty = Some(Type::Reference(TypeReference {\n   |  _______________________--------------___^\n   | |                       |\n   | |                       expected due to the type of this binding\n49 | | ...                       and_token: type_ref.and_token,\n50 | | ...                       lifetime: Some(new_lifetime),\n51 | | ...                       mutability: type_ref.mutability,\n52 | | ...                       elem: type_ref.elem.clone(),\n53 | | ...                   }));\n   | |_________________________^ expected `Type`, found `Option<Type>`\n   |\n   = note: expected enum `syn::Type`\n              found enum `Option<syn::Type>`\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Lifetimes_68_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0507]: cannot move out of a shared reference\n  --> src\\main.rs:43:75\n   |\n43 | ...                   let new_lifetime = lifetimes.iter().find(|&&lt| lt != *lifetime).cloned().unwrap_or_else(|| {\n   |                                                                 ^^--\n   |                                                                   |\n   |                                                                   data moved here\n   |                                                                   move occurs because `lt` has type `syn::Lifetime`, which does not implement the `Copy` trait\n   |\nhelp: consider removing the borrow\n   |\n43 -                                 let new_lifetime = lifetimes.iter().find(|&&lt| lt != *lifetime).cloned().unwrap_or_else(|| {\n43 +                                 let new_lifetime = lifetimes.iter().find(|&lt| lt != *lifetime).cloned().unwrap_or_else(|| {\n   |\n\nFor more information about this error, try `rustc --explain E0507`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_const_generic_lifetimes_68.rs"
    },
    {
        "mutator_name": "Modify_Const_Generic_Parameters_186",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Parameters_186_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:34:69\n   |\n34 |                         if let Type::Path(TypePath { path, .. }) = &*const_param.ty {\n   |                                                                     ^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:36:50\n   |\n36 | ...                   const_param.ty = Box::new(parse_quote!(usize));\n   |                       --------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Type`, found `Box<_>`\n   |                       |\n   |                       expected due to the type of this binding\n   |\n   = note: expected enum `syn::Type`\n            found struct `std::boxed::Box<_>`\nhelp: consider unboxing the value\n   |\n36 |                                 const_param.ty = *Box::new(parse_quote!(usize));\n   |                                                  +\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Parameters_186_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:16:50\n   |\n16 | ...                   const_param.ty = parse_quote!(usize);\n   |                                        ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Struct(ItemStruct { generics, .. }) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `ItemStruct` in this scope\n  --> src\\main.rs:11:33\n   |\n11 |             if let Item::Struct(ItemStruct { generics, .. }) = item {\n   |                                 ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::ItemStruct;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericParam`\n  --> src\\main.rs:13:28\n   |\n13 |                     if let GenericParam::Const(const_param) = param {\n   |                            ^^^^^^^^^^^^ use of undeclared type `GenericParam`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:14:32\n   |\n14 |                         if let Type::Path(TypePath { path, .. }) = const_param.ty.as_ref() {\n   |                                ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypePath` in this scope\n  --> src\\main.rs:14:43\n   |\n14 |                         if let Type::Path(TypePath { path, .. }) = const_param.ty.as_ref() {\n   |                                           ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypePath;\n   |\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 6 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Parameters_186_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Modify_Const_Generic_Parameters_186 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Parameters_186_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `as_ref` found for enum `syn::Type` in the current scope\n  --> src\\main.rs:15:83\n   |\n15 |                         if let Type::Path(TypePath { path, .. }) = const_param.ty.as_ref() {\n   |                                                                                   ^^^^^^ method not found in `syn::Type`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Parameters_186_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:15:69\n   |\n15 |                         if let Type::Path(TypePath { path, .. }) = &*const_param.ty {\n   |                                                                     ^^^^^^^^^^^^^^^ can't be dereferenced\n\nFor more information about this error, try `rustc --explain E0614`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_const_generic_parameters_186.rs"
    },
    {
        "mutator_name": "Modify_Const_Generic_Parameters_202",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_const_generic_parameters_202.rs"
    },
    {
        "mutator_name": "Modify_Const_Generic_Parameters_205",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Parameters_205_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0594]: cannot assign to `const_param.ident`, which is behind a `&` reference\n  --> src\\main.rs:35:25\n   |\n35 |                         const_param.ident = new_ident;\n   |                         ^^^^^^^^^^^^^^^^^ `const_param` is a `&` reference, so the data it refers to cannot be written\n\nerror[E0594]: cannot assign to `const_param.ty`, which is behind a `&` reference\n  --> src\\main.rs:36:25\n   |\n36 |                         const_param.ty = parse_quote!(bool);\n   |                         ^^^^^^^^^^^^^^ `const_param` is a `&` reference, so the data it refers to cannot be written\n\nFor more information about this error, try `rustc --explain E0594`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_const_generic_parameters_205.rs"
    },
    {
        "mutator_name": "Modify_Const_Generic_Parameters_60",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Parameters_60_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `segment.arguments` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:38:82\n   |\n36 | ...                   if let Some(segment) = type_path.path.segments.last() {\n   |                                   ------- consider changing this binding's type to be: `&mut PathSegment`\n37 | ...                       if segment.ident == \"TraitWAssocConst\" {\n38 | ...                           if let PathArguments::AngleBracketed(args) = &mut segment.arguments {\n   |                                                                            ^^^^^^^^^^^^^^^^^^^^^^ `segment` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Parameters_60_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `type_path.path.segments` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:36:52\n   |\n36 | ...                   if let Some(segment) = type_path.path.segments.last_mut() {\n   |                                              ^^^^^^^^^^^^^^^^^^^^^^^ `type_path` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_const_generic_parameters_60.rs"
    },
    {
        "mutator_name": "Modify_Const_Generic_Parameters_In_Async_Functions_244",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Parameters_In_Async_Functions_244_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:37:36\n   |\n37 | ...                   if let Some(const_type) = &const_param.ty {\n   |                              ^^^^^^^^^^^^^^^^   --------------- this expression has type `&syn::Type`\n   |                              |\n   |                              expected `Type`, found `Option<_>`\n   |\n   = note: expected enum `syn::Type`\n              found enum `Option<_>`\n\nerror[E0599]: no method named `remove` found for struct `syn::punctuated::Punctuated` in the current scope\n  --> src\\main.rs:49:53\n   |\n49 |                         item_fn.sig.generics.params.remove(index);\n   |                                                     ^^^^^^ method not found in `Punctuated<GenericParam, Comma>`\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_const_generic_parameters_in_async_functions_244.rs"
    },
    {
        "mutator_name": "Modify_Const_Generic_Params_114",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Params_114_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:32\n   |\n31 |             if let Item::Trait(ref mut trait_item) = item {\n   |                                ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Trait(ref mut trait_item) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n31 -             if let Item::Trait(ref mut trait_item) = item {\n31 +             if let Item::Trait(trait_item) = item {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:33:48\n   |\n33 |                     if let GenericParam::Const(ref mut const_param) = generics {\n   |                                                ^^^^^^^ binding modifier not allowed under `ref` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:33:28\n   |\n33 |                     if let GenericParam::Const(ref mut const_param) = generics {\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&_`\nhelp: make the implied reference patterns explicit\n   |\n33 |                     if let &mut &GenericParam::Const(ref mut const_param) = generics {\n   |                            ++++++\n\nerror[E0596]: cannot borrow `generics.0` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:33:48\n   |\n33 |                     if let GenericParam::Const(ref mut const_param) = generics {\n   |                                                ^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Params_114_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:13:38\n   |\n13 |                     const_param.ty = parse_quote!(i32);\n   |                                      ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:14:48\n   |\n14 |                     const_param.default = Some(parse_quote!(-1));\n   |                                                ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Trait(trait_item) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericParam`\n  --> src\\main.rs:12:29\n   |\n12 |                 if let Some(GenericParam::Const(const_param)) = trait_item.generics.params.first_mut() {\n   |                             ^^^^^^^^^^^^ use of undeclared type `GenericParam`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nFor more information about this error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Params_114_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:7:6\n  |\n7 | impl Mutator for Modify_Const_Generic_Params_114 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_const_generic_params_114.rs"
    },
    {
        "mutator_name": "Modify_Const_Generic_Params_162",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Params_162_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:34:37\n   |\n34 |                         if let Some((_, default_expr)) = &mut const_param.default {\n   |                                     ^^^^^^^^^^^^^^^^^    ------------------------ this expression has type `&mut Option<syn::Expr>`\n   |                                     |\n   |                                     expected `Expr`, found `(_, _)`\n   |\n   = note: expected enum `syn::Expr`\n             found tuple `(_, _)`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Params_162_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:17:54\n   |\n17 | ...                   let new_expr: Expr = parse_quote! { #ident + 1 };\n   |                                            ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Struct(ItemStruct { generics, .. }) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `ItemStruct` in this scope\n  --> src\\main.rs:11:33\n   |\n11 |             if let Item::Struct(ItemStruct { generics, .. }) = item {\n   |                                 ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::ItemStruct;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericParam`\n  --> src\\main.rs:13:28\n   |\n13 |                     if let GenericParam::Const(const_param) = param {\n   |                            ^^^^^^^^^^^^ use of undeclared type `GenericParam`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:15:36\n   |\n15 | ...                   if let Expr::Path(ExprPath { path, .. }) = &**default_expr {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `ExprPath` in this scope\n  --> src\\main.rs:15:47\n   |\n15 | ...                   if let Expr::Path(ExprPath { path, .. }) = &**default_expr {\n   |                                         ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::ExprPath;\n   |\n\nerror[E0412]: cannot find type `Expr` in this scope\n  --> src\\main.rs:17:47\n   |\n17 | ...                   let new_expr: Expr = parse_quote! { #ident + 1 };\n   |                                     ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nSome errors have detailed explanations: E0412, E0422, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 7 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Params_162_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n  --> src\\main.rs:10:6\n   |\n10 | impl Mutator for Modify_Const_Generic_Params_162 {\n   |      ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this trait\n   |\n1  + use crate::mutator::Mutator;\n   |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Params_162_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:15:83\n   |\n15 | ...                   if let syn::Expr::Path(syn::ExprPath { path, .. }) = &**default_expr {\n   |                                                                             ^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:18:49\n   |\n18 | ...                   *default_expr = Box::new(new_expr);\n   |                       -------------   ^^^^^^^^^^^^^^^^^^ expected `Expr`, found `Box<Expr>`\n   |                       |\n   |                       expected due to the type of this binding\n   |\n   = note: expected enum `syn::Expr`\n            found struct `std::boxed::Box<syn::Expr>`\nhelp: consider unboxing the value\n   |\n18 |                                 *default_expr = *Box::new(new_expr);\n   |                                                 +\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Params_162_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:15:83\n   |\n15 | ...                   if let syn::Expr::Path(syn::ExprPath { path, .. }) = &**default_expr {\n   |                                                                             ^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:18:49\n   |\n18 | ...                   *default_expr = Box::new(new_expr);\n   |                       -------------   ^^^^^^^^^^^^^^^^^^ expected `Expr`, found `Box<Expr>`\n   |                       |\n   |                       expected due to the type of this binding\n   |\n   = note: expected enum `syn::Expr`\n            found struct `std::boxed::Box<syn::Expr>`\nhelp: consider unboxing the value\n   |\n18 |                                 *default_expr = *Box::new(new_expr);\n   |                                                 +\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Params_162_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:15:83\n   |\n15 | ...                   if let syn::Expr::Path(syn::ExprPath { path, .. }) = &**default_expr {\n   |                                                                             ^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:18:49\n   |\n18 | ...                   *default_expr = Box::new(new_expr);\n   |                       -------------   ^^^^^^^^^^^^^^^^^^ expected `Expr`, found `Box<Expr>`\n   |                       |\n   |                       expected due to the type of this binding\n   |\n   = note: expected enum `syn::Expr`\n            found struct `std::boxed::Box<syn::Expr>`\nhelp: consider unboxing the value\n   |\n18 |                                 *default_expr = *Box::new(new_expr);\n   |                                                 +\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Params_162_compling_err_7.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:18:49\n   |\n18 | ...                   *default_expr = Box::new(new_expr);\n   |                       -------------   ^^^^^^^^^^^^^^^^^^ expected `Expr`, found `Box<Expr>`\n   |                       |\n   |                       expected due to the type of this binding\n   |\n   = note: expected enum `syn::Expr`\n            found struct `std::boxed::Box<syn::Expr>`\nhelp: consider unboxing the value\n   |\n18 |                                 *default_expr = *Box::new(new_expr);\n   |                                                 +\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Params_162_compling_err_8.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:15:83\n   |\n15 | ...                   if let syn::Expr::Path(syn::ExprPath { path, .. }) = &**default_expr {\n   |                                                                             ^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:18:33\n   |\n18 | ...                   **default_expr = new_expr;\n   |                       ^^^^^^^^^^^^^^ can't be dereferenced\n\nFor more information about this error, try `rustc --explain E0614`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Params_162_compling_err_9.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: the method `as_ref` exists for mutable reference `&mut Expr`, but its trait bounds were not satisfied\n   --> src\\main.rs:16:85\n    |\n16  |   ...                   if let Expr::Path(ExprPath { path, .. }) = default_expr.as_ref() {\n    |                                                                                 ^^^^^^ method cannot be called on `&mut Expr` due to unsatisfied trait bounds\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\expr.rs:35:1\n    |\n35  | / ast_enum_of_structs! {\n36  | |     /// A Rust expression.\n37  | |     ///\n38  | |     /// *This type is available only if Syn is built with the `\"derive\"` or `\"full\"`\n...   |\n267 | | }\n    | |_- doesn't satisfy `syn::Expr: AsRef<_>`\n    |\n    = note: the following trait bounds were not satisfied:\n            `syn::Expr: AsRef<_>`\n            which is required by `&mut syn::Expr: AsRef<_>`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_const_generic_params_162.rs"
    },
    {
        "mutator_name": "Modify_Const_Generic_Params_53",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Params_53_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:36:57\n   |\n36 |                         if let Type::Path(type_path) = &*const_param.ty {\n   |                                                         ^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:57:41\n   |\n57 | ...                   if let Some((_, expr)) = &local.init {\n   |                                   ^^^^^^^^^    ----------- this expression has type `&Option<LocalInit>`\n   |                                   |\n   |                                   expected `LocalInit`, found `(_, _)`\n   |\n   = note: expected struct `LocalInit`\n               found tuple `(_, _)`\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Params_53_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `LocalInit` cannot be dereferenced\n  --> src\\main.rs:58:65\n   |\n58 | ...                   if let Expr::Path(expr_path) = &**expr {\n   |                                                       ^^^^^^ can't be dereferenced\n\nFor more information about this error, try `rustc --explain E0614`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Params_53_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:57:41\n   |\n57 | ...                   if let Some((_, expr)) = &local.init {\n   |                                   ^^^^^^^^^    ----------- this expression has type `&Option<LocalInit>`\n   |                                   |\n   |                                   expected `LocalInit`, found `(_, _)`\n   |\n   = note: expected struct `LocalInit`\n               found tuple `(_, _)`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_const_generic_params_53.rs"
    },
    {
        "mutator_name": "Modify_Const_Generic_To_Unsupported_Type_201",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_To_Unsupported_Type_201_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:35:69\n   |\n35 |                         if let Type::Path(TypePath { path, .. }) = &*const_param.ty {\n   |                                                                     ^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:37:50\n   |\n37 | ...                   const_param.ty = Box::new(parse_quote!([[usize; 3]; 3]));\n   |                       --------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Type`, found `Box<_>`\n   |                       |\n   |                       expected due to the type of this binding\n   |\n   = note: expected enum `syn::Type`\n            found struct `std::boxed::Box<_>`\nhelp: consider unboxing the value\n   |\n37 |                                 const_param.ty = *Box::new(parse_quote!([[usize; 3]; 3]));\n   |                                                  +\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_To_Unsupported_Type_201_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `as_ref` found for enum `syn::Type` in the current scope\n  --> src\\main.rs:35:83\n   |\n35 |                         if let Type::Path(TypePath { path, .. }) = const_param.ty.as_ref() {\n   |                                                                                   ^^^^^^ method not found in `syn::Type`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_To_Unsupported_Type_201_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:35:69\n   |\n35 |                         if let Type::Path(TypePath { path, .. }) = &*const_param.ty {\n   |                                                                     ^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:37:50\n   |\n37 | ...                   const_param.ty = Box::new(parse_quote!([[usize; 3]; 3]));\n   |                       --------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Type`, found `Box<_>`\n   |                       |\n   |                       expected due to the type of this binding\n   |\n   = note: expected enum `syn::Type`\n            found struct `std::boxed::Box<_>`\nhelp: consider unboxing the value\n   |\n37 |                                 const_param.ty = *Box::new(parse_quote!([[usize; 3]; 3]));\n   |                                                  +\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_const_generic_to_unsupported_type_201.rs"
    },
    {
        "mutator_name": "Modify_Const_Generic_Type_29",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_const_generic_type_29.rs"
    },
    {
        "mutator_name": "Modify_Const_Generic_With_Lifetime_69",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_With_Lifetime_69_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:73:21\n   |\n73 |         if let Some(GenericArgument::Const(expr)) = expr_call.args.first_mut() {\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^    -------------------------- this expression has type `Option<&mut syn::Expr>`\n   |                     |\n   |                     expected `Expr`, found `GenericArgument`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_const_generic_with_lifetime_69.rs"
    },
    {
        "mutator_name": "Modify_Const_Init_With_Trait_Bound_Violation_27",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [],
        "label": "Negative",
        "file": ".\\mutators\\modify_const_init_with_trait_bound_violation_27.rs"
    },
    {
        "mutator_name": "Modify_Const_Trait_Implementation_134",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Trait_Implementation_134_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0412]: cannot find type `ImplItemMethod` in crate `syn`\n   --> src\\main.rs:56:42\n    |\n56  |                       let new_method: syn::ImplItemMethod = parse_quote! {\n    |                                            ^^^^^^^^^^^^^^ help: a struct with a similar name exists: `ImplItemMacro`\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\item.rs:780:1\n    |\n780 | / ast_struct! {\n781 | |     /// A macro invocation within an impl block.\n782 | |     #[cfg_attr(docsrs, doc(cfg(feature = \"full\")))]\n783 | |     pub struct ImplItemMacro {\n...   |\n788 | | }\n    | |_- similarly named struct `ImplItemMacro` defined here\n\nerror[E0615]: attempted to take value of method `path` on type `&Attribute`\n  --> src\\main.rs:33:61\n   |\n33 |                 if !trait_item.attrs.iter().any(|attr| attr.path.is_ident(\"const_trait\")) {\n   |                                                             ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n33 |                 if !trait_item.attrs.iter().any(|attr| attr.path().is_ident(\"const_trait\")) {\n   |                                                                 ++\n\nerror[E0609]: no field `constness` on type `&mut ItemImpl`\n  --> src\\main.rs:41:30\n   |\n41 |                 if impl_item.constness.is_some() {\n   |                              ^^^^^^^^^ unknown field\n   |\n   = note: available fields are: `attrs`, `defaultness`, `unsafety`, `impl_token`, `generics` ... and 4 others\n\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:43:47\n   |\n43 |                         if let syn::ImplItem::Method(method) = impl_item {\n   |                                               ^^^^^^ variant or associated item not found in `ImplItem`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:51:52\n   |\n51 |                         if let Some(syn::ImplItem::Method(method)) = impl_item.items.first_mut() {\n   |                                                    ^^^^^^ variant or associated item not found in `ImplItem`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:62:57\n   |\n62 |                     impl_item.items.push(syn::ImplItem::Method(new_method));\n   |                                                         ^^^^^^ variant or associated item not found in `ImplItem`\n\nSome errors have detailed explanations: E0412, E0599, E0609, E0615.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 6 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Trait_Implementation_134_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0609]: no field `constness` on type `Generics`\n  --> src\\main.rs:41:39\n   |\n41 |                 if impl_item.generics.constness.is_some() {\n   |                                       ^^^^^^^^^ unknown field\n   |\n   = note: available fields are: `lt_token`, `params`, `gt_token`, `where_clause`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Trait_Implementation_134_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:14:43\n   |\n14 |                     trait_item.attrs.push(parse_quote!(#[const_trait]));\n   |                                           ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:50:55\n   |\n50 |                     let new_method: syn::ImplItemFn = parse_quote! {\n   |                                                       ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:12:20\n   |\n12 |             if let Item::Trait(trait_item) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:20:20\n   |\n20 |             if let Item::Impl(impl_item) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericParam`\n  --> src\\main.rs:22:28\n   |\n22 |                     if let GenericParam::Type(type_param) = param {\n   |                            ^^^^^^^^^^^^ use of undeclared type `GenericParam`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TypeParamBound`\n  --> src\\main.rs:24:36\n   |\n24 | ...                   if let TypeParamBound::Trait(trait_bound) = bound {\n   |                              ^^^^^^^^^^^^^^ use of undeclared type `TypeParamBound`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TypeParamBound;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TraitBoundModifier`\n  --> src\\main.rs:25:57\n   |\n25 | ...                   trait_bound.modifier == TraitBoundModifier::MaybeConst\n   |                                               ^^^^^^^^^^^^^^^^^^ use of undeclared type `TraitBoundModifier`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TraitBoundModifier;\n   |\n\nFor more information about this error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 7 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Trait_Implementation_134_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Modify_Const_Trait_Implementation_134 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Trait_Implementation_134_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0615]: attempted to take value of method `path` on type `&Attribute`\n  --> src\\main.rs:14:61\n   |\n14 |                 if !trait_item.attrs.iter().any(|attr| attr.path.is_ident(\"const_trait\")) {\n   |                                                             ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n14 |                 if !trait_item.attrs.iter().any(|attr| attr.path().is_ident(\"const_trait\")) {\n   |                                                                 ++\n\nerror[E0599]: no variant or associated item named `MaybeConst` found for enum `TraitBoundModifier` in the current scope\n  --> src\\main.rs:26:77\n   |\n26 | ...                   trait_bound.modifier == TraitBoundModifier::MaybeConst\n   |                                                                   ^^^^^^^^^^ variant or associated item not found in `TraitBoundModifier`\n\nSome errors have detailed explanations: E0599, E0615.\nFor more information about an error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_const_trait_implementation_134.rs"
    },
    {
        "mutator_name": "Modify_Const_Trait_Impl_122",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Trait_Impl_122_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0026]: struct `ItemImpl` does not have a field named `constness`\n  --> src\\main.rs:32:42\n   |\n32 |             if let Item::Impl(ItemImpl { constness: Some(_), items, .. }) = item {\n   |                                          ^^^^^^^^^ struct `ItemImpl` does not have this field\n\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:34:43\n   |\n34 |                     if let syn::ImplItem::Method(method) = impl_item {\n   |                                           ^^^^^^ variant or associated item not found in `ImplItem`\n\nSome errors have detailed explanations: E0026, E0599.\nFor more information about an error, try `rustc --explain E0026`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_const_trait_impl_122.rs"
    },
    {
        "mutator_name": "Modify_Const_Trait_Usage_133",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Trait_Usage_133_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0615]: attempted to take value of method `path` on type `&Attribute`\n  --> src\\main.rs:32:60\n   |\n32 |                 if trait_item.attrs.iter().any(|attr| attr.path.is_ident(\"const_trait\")) {\n   |                                                            ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n32 |                 if trait_item.attrs.iter().any(|attr| attr.path().is_ident(\"const_trait\")) {\n   |                                                                ++\n\nerror[E0615]: attempted to take value of method `path` on type `&Attribute`\n  --> src\\main.rs:33:58\n   |\n33 |                     trait_item.attrs.retain(|attr| !attr.path.is_ident(\"const_trait\"));\n   |                                                          ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n33 |                     trait_item.attrs.retain(|attr| !attr.path().is_ident(\"const_trait\"));\n   |                                                              ++\n\nFor more information about this error, try `rustc --explain E0615`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_const_trait_usage_133.rs"
    },
    {
        "mutator_name": "Modify_Default_Const_Generics_56",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Default_Const_Generics_56_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:35:52\n   |\n35 | ...                   if let Expr::Path(_) = **default {\n   |                                              ^^^^^^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n   --> src\\main.rs:39:60\n    |\n39  | ...                   const_param.default = Some(Box::new(new_expr));\n    |                                             ---- ^^^^^^^^^^^^^^^^^^ expected `Expr`, found `Box<Expr>`\n    |                                             |\n    |                                             arguments to this enum variant are incorrect\n    |\n    = note: expected enum `syn::Expr`\n             found struct `std::boxed::Box<syn::Expr>`\nhelp: the type constructed contains `std::boxed::Box<syn::Expr>` due to the type of the argument passed\n   --> src\\main.rs:39:55\n    |\n39  | ...                   const_param.default = Some(Box::new(new_expr));\n    |                                             ^^^^^------------------^\n    |                                                  |\n    |                                                  this argument influences the type of `Some`\nnote: tuple variant defined here\n   --> C:\\Users\\love\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\option.rs:597:5\n    |\n597 |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    |     ^^^^\nhelp: consider unboxing the value\n    |\n39  |                                 const_param.default = Some(*Box::new(new_expr));\n    |                                                            +\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_default_const_generics_56.rs"
    },
    {
        "mutator_name": "Modify_Default_Type_Of_Const_Generic_Parameters_182",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Default_Type_Of_Const_Generic_Parameters_182_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: the method `as_ref` exists for reference `&syn::Expr`, but its trait bounds were not satisfied\n   --> src\\main.rs:36:80\n    |\n36  |   ...                   if let Expr::Path(ExprPath { path, .. }) = default.as_ref() {\n    |                                                                            ^^^^^^ method cannot be called on `&syn::Expr` due to unsatisfied trait bounds\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\expr.rs:35:1\n    |\n35  | / ast_enum_of_structs! {\n36  | |     /// A Rust expression.\n37  | |     ///\n38  | |     /// *This type is available only if Syn is built with the `\"derive\"` or `\"full\"`\n...   |\n267 | | }\n    | |_- doesn't satisfy `syn::Expr: AsRef<_>`\n    |\n    = note: the following trait bounds were not satisfied:\n            `syn::Expr: AsRef<_>`\n            which is required by `&syn::Expr: AsRef<_>`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_default_type_of_const_generic_parameters_182.rs"
    },
    {
        "mutator_name": "Modify_Enum_Variant_Patterns_78",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Enum_Variant_Patterns_78_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:33:39\n   |\n33 |                     if let Stmt::Expr(Expr::Match(expr_match)) = stmt {\n   |                                       ^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n33 |                     if let Stmt::Expr(Expr::Match(expr_match), _) = stmt {\n   |                                                              +++\n\nFor more information about this error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_enum_variant_patterns_78.rs"
    },
    {
        "mutator_name": "Modify_Existing_Lifetime_Annotations_105",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Existing_Lifetime_Annotations_105_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:32:29\n   |\n32 |                 if let Some((_, ref generics, _, _)) = &item_impl.trait_ {\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^    ----------------- this expression has type `&Option<(Option<syn::token::Not>, syn::Path, For)>`\n   |                             |\n   |                             expected a tuple with 3 elements, found one with 4 elements\n   |\n   = note: expected tuple `(Option<syn::token::Not>, syn::Path, For)`\n              found tuple `(_, _, _, _)`\n\nerror[E0433]: failed to resolve: use of undeclared type `LifetimeDef`\n  --> src\\main.rs:44:74\n   |\n44 |                         generics.params.insert(0, GenericParam::Lifetime(LifetimeDef::new(new_lifetime.clone())));\n   |                                                                          ^^^^^^^^^^^\n   |                                                                          |\n   |                                                                          use of undeclared type `LifetimeDef`\n   |                                                                          help: a struct with a similar name exists: `Lifetime`\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Existing_Lifetime_Annotations_105_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0609]: no field `params` on type `&syn::Path`\n  --> src\\main.rs:36:48\n   |\n36 |                     for param in &mut generics.params {\n   |                                                ^^^^^^ unknown field\n   |\n   = note: available fields are: `leading_colon`, `segments`\n\nerror[E0609]: no field `params` on type `&syn::Path`\n  --> src\\main.rs:44:34\n   |\n44 |                         generics.params.insert(0, GenericParam::Lifetime(LifetimeParam::new(new_lifetime.clone())));\n   |                                  ^^^^^^ unknown field\n   |\n   = note: available fields are: `leading_colon`, `segments`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_existing_lifetime_annotations_105.rs"
    },
    {
        "mutator_name": "Modify_Fn_Ptr_Const_Generics_207",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Fn_Ptr_Const_Generics_207_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:33:24\n   |\n33 |                 if let Some((_, ref mut generics, _)) = item_struct.generics.split_for_impl() {\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ------------------------------------- this expression has type `(ImplGenerics<'_>, TypeGenerics<'_>, Option<&WhereClause>)`\n   |                        |\n   |                        expected `(ImplGenerics<'_>, ..., ...)`, found `Option<_>`\n   |\n   = note: expected tuple `(ImplGenerics<'_>, TypeGenerics<'_>, Option<&WhereClause>)`\n               found enum `Option<_>`\n\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:35:95\n   |\n35 |                         if let Type::Path(TypePath { path: SynPath { segments, .. }, .. }) = &*const_param.ty {\n   |                                                                                               ^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:37:50\n   |\n37 |   ...                   const_param.ty = Box::new(Type::Path(TypePath {\n   |  _______________________--------------___^\n   | |                       |\n   | |                       expected due to the type of this binding\n38 | | ...                       path: parse_quote!(usize),\n39 | | ...                       qself: None,\n40 | | ...                   }));\n   | |_________________________^ expected `Type`, found `Box<Type>`\n   |\n   = note: expected enum `syn::Type`\n            found struct `std::boxed::Box<syn::Type>`\nhelp: consider unboxing the value\n   |\n37 |                                 const_param.ty = *Box::new(Type::Path(TypePath {\n   |                                                  +\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Fn_Ptr_Const_Generics_207_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:32:33\n   |\n32 |             if let Item::Struct(ref mut item_struct) = item {\n   |                                 ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:32:20\n   |\n32 |             if let Item::Struct(ref mut item_struct) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n32 -             if let Item::Struct(ref mut item_struct) = item {\n32 +             if let Item::Struct(item_struct) = item {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:34:49\n   |\n34 |                 if let Some(GenericParam::Const(ref mut const_param)) = generics.params.first_mut() {\n   |                                                 ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:34:29\n   |\n34 |                 if let Some(GenericParam::Const(ref mut const_param)) = generics.params.first_mut() {\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n34 -                 if let Some(GenericParam::Const(ref mut const_param)) = generics.params.first_mut() {\n34 +                 if let Some(GenericParam::Const(const_param)) = generics.params.first_mut() {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:48:31\n   |\n48 |             if let Item::Impl(ref mut item_impl) = item {\n   |                               ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:48:20\n   |\n48 |             if let Item::Impl(ref mut item_impl) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n48 -             if let Item::Impl(ref mut item_impl) = item {\n48 +             if let Item::Impl(item_impl) = item {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:53:68\n   |\n53 | ...                   if let Some(GenericArgument::Const(ref mut expr)) = args.args.first_mut() {\n   |                                                          ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:53:45\n   |\n53 | ...                   if let Some(GenericArgument::Const(ref mut expr)) = args.args.first_mut() {\n   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n53 -                                 if let Some(GenericArgument::Const(ref mut expr)) = args.args.first_mut() {\n53 +                                 if let Some(GenericArgument::Const(expr)) = args.args.first_mut() {\n   |\n\nerror[E0596]: cannot borrow `*segments` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:50:44\n   |\n50 |                     if let Some(segment) = segments.last_mut() {\n   |                                            ^^^^^^^^ `segments` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 5 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Fn_Ptr_Const_Generics_207_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:18:39\n   |\n18 | ...                   path: parse_quote!(usize),\n   |                             ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:34:45\n   |\n34 | ...                   *expr = parse_quote!(4);\n   |                               ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:12:20\n   |\n12 |             if let Item::Struct(item_struct) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericParam`\n  --> src\\main.rs:14:29\n   |\n14 |                 if let Some(GenericParam::Const(const_param)) = generics.params.first_mut() {\n   |                             ^^^^^^^^^^^^ use of undeclared type `GenericParam`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:15:28\n   |\n15 |                     if let Type::Path(TypePath { path: SynPath { segments, .. }, .. }) = &const_param.ty {\n   |                            ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypePath` in this scope\n  --> src\\main.rs:15:39\n   |\n15 |                     if let Type::Path(TypePath { path: SynPath { segments, .. }, .. }) = &const_param.ty {\n   |                                       ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypePath;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `SynPath` in this scope\n  --> src\\main.rs:15:56\n   |\n15 |                     if let Type::Path(TypePath { path: SynPath { segments, .. }, .. }) = &const_param.ty {\n   |                                                        ^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:17:46\n   |\n17 | ...                   const_param.ty = Type::Path(TypePath {\n   |                                        ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypePath` in this scope\n  --> src\\main.rs:17:57\n   |\n17 | ...                   const_param.ty = Type::Path(TypePath {\n   |                                                   ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypePath;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:28:20\n   |\n28 |             if let Item::Impl(item_impl) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:29:24\n   |\n29 |                 if let Type::Path(TypePath { path: SynPath { segments, .. }, .. }) = &*item_impl.self_ty {\n   |                        ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypePath` in this scope\n  --> src\\main.rs:29:35\n   |\n29 |                 if let Type::Path(TypePath { path: SynPath { segments, .. }, .. }) = &*item_impl.self_ty {\n   |                                   ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypePath;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `SynPath` in this scope\n  --> src\\main.rs:29:52\n   |\n29 |                 if let Type::Path(TypePath { path: SynPath { segments, .. }, .. }) = &*item_impl.self_ty {\n   |                                                    ^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `PathArguments`\n  --> src\\main.rs:32:36\n   |\n32 | ...                   if let PathArguments::AngleBracketed(args) = &mut segment.arguments {\n   |                              ^^^^^^^^^^^^^ use of undeclared type `PathArguments`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::PathArguments;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericArgument`\n  --> src\\main.rs:33:45\n   |\n33 | ...                   if let Some(GenericArgument::Const(expr)) = args.args.first_mut() {\n   |                                   ^^^^^^^^^^^^^^^ use of undeclared type `GenericArgument`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericArgument;\n   |\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 15 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Fn_Ptr_Const_Generics_207_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Modify_Fn_Ptr_Const_Generics_207 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Fn_Ptr_Const_Generics_207_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `segment.arguments` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:33:74\n   |\n31 |                     if let Some(segment) = path.segments.last() {\n   |                                 ------- consider changing this binding's type to be: `&mut PathSegment`\n32 |                         if segment.ident == \"Wrapper\" {\n33 |                             if let PathArguments::AngleBracketed(args) = &mut segment.arguments {\n   |                                                                          ^^^^^^^^^^^^^^^^^^^^^^ `segment` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Fn_Ptr_Const_Generics_207_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `path.segments` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:31:44\n   |\n31 |                     if let Some(segment) = path.segments.last_mut() {\n   |                                            ^^^^^^^^^^^^^ `path` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_fn_ptr_const_generics_207.rs"
    },
    {
        "mutator_name": "Modify_Fn_Signature_Inherent_Assoc_Types_222",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Fn_Signature_Inherent_Assoc_Types_222_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:32:29\n   |\n32 |             if let Item::Fn(ref mut item_fn) = item {\n   |                             ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:32:20\n   |\n32 |             if let Item::Fn(ref mut item_fn) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n32 -             if let Item::Fn(ref mut item_fn) = item {\n32 +             if let Item::Fn(item_fn) = item {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Fn_Signature_Inherent_Assoc_Types_222_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:19:57\n   |\n19 | ...                   let new_return_type: Type = parse_quote! {\n   |                                                   ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:12:20\n   |\n12 |             if let Item::Fn(item_fn) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `ReturnType`\n  --> src\\main.rs:13:24\n   |\n13 |                 if let ReturnType::Type(_, ref mut return_type) = item_fn.sig.output {\n   |                        ^^^^^^^^^^ use of undeclared type `ReturnType`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::ReturnType;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:14:28\n   |\n14 |                     if let Type::Reference(type_ref) = &**return_type {\n   |                            ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:16:47\n   |\n16 | ...                   let struct_name = Ident::new(\"S\", Span::call_site());\n   |                                         ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:16:63\n   |\n16 | ...                   let struct_name = Ident::new(\"S\", Span::call_site());\n   |                                                         ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:17:51\n   |\n17 | ...                   let associated_type = Ident::new(\"P\", Span::call_site());\n   |                                             ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:17:67\n   |\n17 | ...                   let associated_type = Ident::new(\"P\", Span::call_site());\n   |                                                             ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0412]: cannot find type `Type` in this scope\n  --> src\\main.rs:19:50\n   |\n19 | ...                   let new_return_type: Type = parse_quote! {\n   |                                            ^^^^ not found in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 9 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Fn_Signature_Inherent_Assoc_Types_222_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `mutate` found for struct `Modify_Fn_Signature_Inherent_Assoc_Types_222` in the current scope\n  --> src\\main.rs:58:58\n   |\n4  | pub struct Modify_Fn_Signature_Inherent_Assoc_Types_222;\n   | ------------------------------------------------------- method `mutate` not found for this struct\n...\n58 |             Modify_Fn_Signature_Inherent_Assoc_Types_222.mutate(&mut file_ast);\n   |                                                          ^^^^^^ method not found in `Modify_Fn_Signature_Inherent_Assoc_Types_222`\n   |\n  ::: src\\mutator.rs:15:8\n   |\n15 |     fn mutate(&self, file: &mut syn::File);\n   |        ------ the method is available for `Modify_Fn_Signature_Inherent_Assoc_Types_222` here\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: trait `Mutator` which provides `mutate` is implemented but not in scope; perhaps you want to import it\n   |\n1  + use crate::mutator::Mutator;\n   |\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_fn_signature_inherent_assoc_types_222.rs"
    },
    {
        "mutator_name": "Modify_Function_Keywords_126",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Function_Keywords_126_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:34:43\n   |\n34 |                     if let syn::ImplItem::Method(method) = impl_item {\n   |                                           ^^^^^^ variant or associated item not found in `ImplItem`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Function_Keywords_126_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0432]: unresolved import `syn::ImplItemMethod`\n --> src\\main.rs:1:21\n  |\n1 | use syn::{ImplItem, ImplItemMethod};\n  |                     ^^^^^^^^^^^^^^\n  |                     |\n  |                     no `ImplItemMethod` in the root\n  |                     help: a similar name exists in the module: `ImplItemMacro`\n\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Modify_Function_Keywords_126 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:12:20\n   |\n12 |             if let Item::Impl(item_impl) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0425]: cannot find function `thread_rng` in this scope\n  --> src\\main.rs:26:32\n   |\n26 | ...                   if thread_rng().gen_bool(0.5) {\n   |                          ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  + use rand::thread_rng;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `token`\n  --> src\\main.rs:27:61\n   |\n27 | ...                   method.sig.constness = Some(token::Const(Span::call_site()));\n   |                                                   ^^^^^ use of unresolved module or unlinked crate `token`\n   |\n   = help: if you wanted to use a crate named `token`, use `cargo add token` to add it to your `Cargo.toml`\nhelp: consider importing this module\n   |\n1  + use syn::token;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:27:74\n   |\n27 | ...                   method.sig.constness = Some(token::Const(Span::call_site()));\n   |                                                                ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `token`\n  --> src\\main.rs:28:61\n   |\n28 | ...                   method.sig.asyncness = Some(token::Async(Span::call_site()));\n   |                                                   ^^^^^ use of unresolved module or unlinked crate `token`\n   |\n   = help: if you wanted to use a crate named `token`, use `cargo add token` to add it to your `Cargo.toml`\nhelp: consider importing this module\n   |\n1  + use syn::token;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:28:74\n   |\n28 | ...                   method.sig.asyncness = Some(token::Async(Span::call_site()));\n   |                                                                ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `token`\n  --> src\\main.rs:30:61\n   |\n30 | ...                   method.sig.constness = Some(token::Const(Span::call_site()));\n   |                                                   ^^^^^ use of unresolved module or unlinked crate `token`\n   |\n   = help: if you wanted to use a crate named `token`, use `cargo add token` to add it to your `Cargo.toml`\nhelp: consider importing this module\n   |\n1  + use syn::token;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:30:74\n   |\n30 | ...                   method.sig.constness = Some(token::Const(Span::call_site()));\n   |                                                                ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0425]: cannot find function `thread_rng` in this scope\n  --> src\\main.rs:33:32\n   |\n33 | ...                   if thread_rng().gen_bool(0.5) {\n   |                          ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  + use rand::thread_rng;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `token`\n  --> src\\main.rs:34:61\n   |\n34 | ...                   method.sig.constness = Some(token::Const(Span::call_site()));\n   |                                                   ^^^^^ use of unresolved module or unlinked crate `token`\n   |\n   = help: if you wanted to use a crate named `token`, use `cargo add token` to add it to your `Cargo.toml`\nhelp: consider importing this module\n   |\n1  + use syn::token;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:34:74\n   |\n34 | ...                   method.sig.constness = Some(token::Const(Span::call_site()));\n   |                                                                ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `token`\n  --> src\\main.rs:35:60\n   |\n35 | ...                   method.sig.unsafety = Some(token::Unsafe(Span::call_site()));\n   |                                                  ^^^^^ use of unresolved module or unlinked crate `token`\n   |\n   = help: if you wanted to use a crate named `token`, use `cargo add token` to add it to your `Cargo.toml`\nhelp: consider importing this module\n   |\n1  + use syn::token;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:35:74\n   |\n35 | ...                   method.sig.unsafety = Some(token::Unsafe(Span::call_site()));\n   |                                                                ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `token`\n  --> src\\main.rs:37:61\n   |\n37 | ...                   method.sig.constness = Some(token::Const(Span::call_site()));\n   |                                                   ^^^^^ use of unresolved module or unlinked crate `token`\n   |\n   = help: if you wanted to use a crate named `token`, use `cargo add token` to add it to your `Cargo.toml`\nhelp: consider importing this module\n   |\n1  + use syn::token;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:37:74\n   |\n37 | ...                   method.sig.constness = Some(token::Const(Span::call_site()));\n   |                                                                ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nSome errors have detailed explanations: E0405, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 17 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Function_Keywords_126_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:19:38\n   |\n19 |                     if let ImplItem::Method(method) = impl_item {\n   |                                      ^^^^^^ variant or associated item not found in `ImplItem`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Function_Keywords_126_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0432]: unresolved import `syn::ImplItemMethod`\n --> src\\main.rs:1:27\n  |\n1 | use syn::{Item, ImplItem, ImplItemMethod};\n  |                           ^^^^^^^^^^^^^^\n  |                           |\n  |                           no `ImplItemMethod` in the root\n  |                           help: a similar name exists in the module: `ImplItemMacro`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:19:38\n   |\n19 |                     if let ImplItem::Method(method) = impl_item {\n   |                                      ^^^^^^ variant or associated item not found in `ImplItem`\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_function_keywords_126.rs"
    },
    {
        "mutator_name": "Modify_Function_Return_Type_234",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Function_Return_Type_234_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0106]: missing lifetime specifier\n  --> src\\main.rs:57:66\n   |\n57 | fn find_type_alias(items: &[Item], alias_name: &Ident) -> Option<&Type> {\n   |                           -------              ------            ^ expected named lifetime parameter\n   |\n   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `items` or `alias_name`\nhelp: consider introducing a named lifetime parameter\n   |\n57 | fn find_type_alias<'a>(items: &'a [Item], alias_name: &'a Ident) -> Option<&'a Type> {\n   |                   ++++         ++                      ++                   ++\n\nerror[E0277]: the trait bound `TypeImplTrait: std::default::Default` is not satisfied\n  --> src\\main.rs:41:47\n   |\n41 | ...                   ..Default::default()\n   |                         ^^^^^^^^^^^^^^^^^^ the trait `std::default::Default` is not implemented for `TypeImplTrait`\n\nSome errors have detailed explanations: E0106, E0277.\nFor more information about an error, try `rustc --explain E0106`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Function_Return_Type_234_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0063]: missing field `impl_token` in initializer of `TypeImplTrait`\n  --> src\\main.rs:39:81\n   |\n39 | ...                   *return_type = Box::new(Type::ImplTrait(TypeImplTrait {\n   |                                                               ^^^^^^^^^^^^^ missing `impl_token`\n\nFor more information about this error, try `rustc --explain E0063`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Function_Return_Type_234_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:29\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                             ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n31 -             if let Item::Fn(ref mut func) = item {\n31 +             if let Item::Fn(func) = item {\n   |\n\nerror[E0502]: cannot borrow `file.items` as immutable because it is also borrowed as mutable\n  --> src\\main.rs:37:75\n   |\n30 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     mutable borrow occurs here\n   |                     mutable borrow later used here\n...\n37 |                                 if let Some(alias_type) = find_type_alias(&file.items, &segment.ident) {\n   |                                                                           ^^^^^^^^^^^ immutable borrow occurs here\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Function_Return_Type_234_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:12:20\n   |\n12 |             if let Item::Fn(func) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `ReturnType`\n  --> src\\main.rs:13:24\n   |\n13 |                 if let ReturnType::Type(_, ref mut return_type) = func.sig.output {\n   |                        ^^^^^^^^^^ use of undeclared type `ReturnType`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::ReturnType;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:14:28\n   |\n14 |                     if let Type::Path(TypePath { path, .. }) = &**return_type {\n   |                            ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypePath` in this scope\n  --> src\\main.rs:14:39\n   |\n14 |                     if let Type::Path(TypePath { path, .. }) = &**return_type {\n   |                                       ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypePath;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:19:44\n   |\n19 | ...                   if let Type::ImplTrait(TypeImplTrait { bounds, .. }) = alias_type {\n   |                              ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypeImplTrait` in this scope\n  --> src\\main.rs:19:60\n   |\n19 | ...                   if let Type::ImplTrait(TypeImplTrait { bounds, .. }) = alias_type {\n   |                                              ^^^^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypeImplTrait;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:20:65\n   |\n20 | ...                   *return_type = Box::new(Type::ImplTrait(TypeImplTrait {\n   |                                               ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypeImplTrait` in this scope\n  --> src\\main.rs:20:81\n   |\n20 | ...                   *return_type = Box::new(Type::ImplTrait(TypeImplTrait {\n   |                                                               ^^^^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypeImplTrait;\n   |\n\nerror[E0412]: cannot find type `Item` in this scope\n  --> src\\main.rs:38:36\n   |\n38 | fn find_type_alias<'a>(items: &'a [Item], alias_name: &'a Ident) -> Option<&'a Type> {\n   |                                    ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0412]: cannot find type `Ident` in this scope\n  --> src\\main.rs:38:59\n   |\n38 | fn find_type_alias<'a>(items: &'a [Item], alias_name: &'a Ident) -> Option<&'a Type> {\n   |                                                           ^^^^^ not found in this scope\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nerror[E0412]: cannot find type `Type` in this scope\n  --> src\\main.rs:38:80\n   |\n38 | fn find_type_alias<'a>(items: &'a [Item], alias_name: &'a Ident) -> Option<&'a Type> {\n   |                                                                                ^^^^ not found in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:40:16\n   |\n40 |         if let Item::Type(type_item) = item {\n   |                ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nSome errors have detailed explanations: E0412, E0422, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 12 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_function_return_type_234.rs"
    },
    {
        "mutator_name": "Modify_Function_Return_Type_To_Const_Expr_191",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_function_return_type_to_const_expr_191.rs"
    },
    {
        "mutator_name": "Modify_Function_Return_Type_With_Complex_Trait_Bounds_84",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Function_Return_Type_With_Complex_Trait_Bounds_84_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:29\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                             ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n31 -             if let Item::Fn(ref mut func) = item {\n31 +             if let Item::Fn(func) = item {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_function_return_type_with_complex_trait_bounds_84.rs"
    },
    {
        "mutator_name": "Modify_Function_Signatures_With_Invalid_Self_Parameter_187",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Function_Signatures_With_Invalid_Self_Parameter_187_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0615]: attempted to take value of method `path` on type `&Attribute`\n  --> src\\main.rs:46:37\n   |\n46 |         if let Some(segment) = attr.path.segments.first() {\n   |                                     ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n46 |         if let Some(segment) = attr.path().segments.first() {\n   |                                         ++\n\nFor more information about this error, try `rustc --explain E0615`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_function_signatures_with_invalid_self_parameter_187.rs"
    },
    {
        "mutator_name": "Modify_Function_Signature_Introduce_Trait_Bounds_236",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_function_signature_introduce_trait_bounds_236.rs"
    },
    {
        "mutator_name": "Modify_Function_Type_Alias_24",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [],
        "label": "Negative",
        "file": ".\\mutators\\modify_function_type_alias_24.rs"
    },
    {
        "mutator_name": "Modify_Function_Usage_In_Const_Context_224",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [],
        "label": "Negative",
        "file": ".\\mutators\\modify_function_usage_in_const_context_224.rs"
    },
    {
        "mutator_name": "Modify_Future_Output_Type_8",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Future_Output_Type_8_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:32:24\n   |\n32 |                 if let Some((_, ref mut output_type)) = func.sig.output {\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   --------------- this expression has type `ReturnType`\n   |                        |\n   |                        expected `ReturnType`, found `Option<_>`\n   |\n   = note: expected enum `ReturnType`\n              found enum `Option<_>`\n\nerror[E0599]: no variant or associated item named `Binding` found for enum `GenericArgument` in the current scope\n  --> src\\main.rs:40:73\n   |\n40 | ...                   if let GenericArgument::Binding(ref mut binding) = arg {\n   |                                               ^^^^^^^ variant or associated item not found in `GenericArgument`\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Future_Output_Type_8_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0425]: cannot find value `output_type` in this scope\n  --> src\\main.rs:43:58\n   |\n43 | ...                   *output_type = ReturnType::Type(Default::default(), Box::new(parse_quote!(i32)));\n   |                        ^^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Future_Output_Type_8_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:29\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                             ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n31 -             if let Item::Fn(ref mut func) = item {\n31 +             if let Item::Fn(func) = item {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:35:71\n   |\n35 | ...                   if let TypeParamBound::Trait(TraitBound { ref mut path, .. }) = bound {\n   |                                                                 ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:35:36\n   |\n35 | ...                   if let TypeParamBound::Trait(TraitBound { ref mut path, .. }) = bound {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n35 -                             if let TypeParamBound::Trait(TraitBound { ref mut path, .. }) = bound {\n35 +                             if let TypeParamBound::Trait(TraitBound { path, .. }) = bound {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:39:74\n   |\n39 | ...                   if let GenericArgument::Type(ref mut ty) = arg {\n   |                                                    ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:39:52\n   |\n39 | ...                   if let GenericArgument::Type(ref mut ty) = arg {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n39 -                                             if let GenericArgument::Type(ref mut ty) = arg {\n39 +                                             if let GenericArgument::Type(ty) = arg {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:40:84\n   |\n40 | ...                   if let Type::Path(TypePath { path: ref mut inner_path, .. }) = ty {\n   |                                                          ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:40:56\n   |\n40 | ...                   if let Type::Path(TypePath { path: ref mut inner_path, .. }) = ty {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n40 -                                                 if let Type::Path(TypePath { path: ref mut inner_path, .. }) = ty {\n40 +                                                 if let Type::Path(TypePath { path: inner_path, .. }) = ty {\n   |\n\nerror[E0506]: cannot assign to `func.sig.output` because it is borrowed\n  --> src\\main.rs:43:57\n   |\n32 |                 if let ReturnType::Type(_, ref mut ty) = func.sig.output {\n   |                                            ---------- `func.sig.output` is borrowed here\n33 |                     if let Type::ImplTrait(ref mut impl_trait) = **ty {\n34 |                         for bound in &mut impl_trait.bounds {\n   |                                      ---------------------- borrow later used here\n...\n43 |                                                         func.sig.output = ReturnType::Type(Default::default(), Box::new(parse_quote!(i32)));\n   |                                                         ^^^^^^^^^^^^^^^ `func.sig.output` is assigned to here but it was already borrowed\n\nFor more information about this error, try `rustc --explain E0506`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 5 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Future_Output_Type_8_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:22:86\n   |\n22 | ...                   *arg = GenericArgument::Type(parse_quote!(i32));\n   |                                                    ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:23:121\n   |\n23 | ...                   func.sig.output = ReturnType::Type(Default::default(), Box::new(parse_quote!(i32)));\n   |                                                                                       ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:24:79\n   |\n24 | ...                   func.block = Box::new(parse_quote!({\n   |                                             ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Fn(func) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `ReturnType`\n  --> src\\main.rs:12:24\n   |\n12 |                 if let ReturnType::Type(_, ty) = &mut func.sig.output {\n   |                        ^^^^^^^^^^ use of undeclared type `ReturnType`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::ReturnType;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:13:28\n   |\n13 |                     if let Type::ImplTrait(impl_trait) = &mut **ty {\n   |                            ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TypeParamBound`\n  --> src\\main.rs:15:36\n   |\n15 | ...                   if let TypeParamBound::Trait(TraitBound { path, .. }) = bound {\n   |                              ^^^^^^^^^^^^^^ use of undeclared type `TypeParamBound`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TypeParamBound;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TraitBound` in this scope\n  --> src\\main.rs:15:58\n   |\n15 | ...                   if let TypeParamBound::Trait(TraitBound { path, .. }) = bound {\n   |                                                    ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TraitBound;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `PathArguments`\n  --> src\\main.rs:17:44\n   |\n17 | ...                   if let PathArguments::AngleBracketed(args) = &mut path.segments.last_mut().unwrap().arguments {\n   |                              ^^^^^^^^^^^^^ use of undeclared type `PathArguments`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::PathArguments;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericArgument`\n  --> src\\main.rs:19:52\n   |\n19 | ...                   if let GenericArgument::Type(ty) = arg {\n   |                              ^^^^^^^^^^^^^^^ use of undeclared type `GenericArgument`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericArgument;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:20:56\n   |\n20 | ...                   if let Type::Path(TypePath { path: inner_path, .. }) = ty {\n   |                              ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypePath` in this scope\n  --> src\\main.rs:20:67\n   |\n20 | ...                   if let Type::Path(TypePath { path: inner_path, .. }) = ty {\n   |                                         ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypePath;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericArgument`\n  --> src\\main.rs:22:64\n   |\n22 | ...                   *arg = GenericArgument::Type(parse_quote!(i32));\n   |                              ^^^^^^^^^^^^^^^ use of undeclared type `GenericArgument`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericArgument;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `ReturnType`\n  --> src\\main.rs:23:75\n   |\n23 | ...                   func.sig.output = ReturnType::Type(Default::default(), Box::new(parse_quote!(i32)));\n   |                                         ^^^^^^^^^^ use of undeclared type `ReturnType`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::ReturnType;\n   |\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 14 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Future_Output_Type_8_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:8:6\n  |\n8 | impl Mutator for Modify_Future_Output_Type_8 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Future_Output_Type_8_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0506]: cannot assign to `func.sig.output` because it is borrowed\n  --> src\\main.rs:27:57\n   |\n16 |                 if let ReturnType::Type(_, ty) = &mut func.sig.output {\n   |                                                  -------------------- `func.sig.output` is borrowed here\n17 |                     if let Type::ImplTrait(impl_trait) = &mut **ty {\n18 |                         for bound in &mut impl_trait.bounds {\n   |                                      ---------------------- borrow later used here\n...\n27 |                                                         func.sig.output = ReturnType::Type(Default::default(), Box::new(parse_quote!(i32)));\n   |                                                         ^^^^^^^^^^^^^^^ `func.sig.output` is assigned to here but it was already borrowed\n\nFor more information about this error, try `rustc --explain E0506`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_future_output_type_8.rs"
    },
    {
        "mutator_name": "Modify_Generic_Constant_Expressions_144",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Generic_Constant_Expressions_144_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:42\n   |\n31 |             if let Item::Impl(ItemImpl { ref mut generics, ref mut trait_, .. }) = item {\n   |                                          ^^^^^^^           ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |                                          |\n   |                                          binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Impl(ItemImpl { ref mut generics, ref mut trait_, .. }) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifiers\n   |\n31 -             if let Item::Impl(ItemImpl { ref mut generics, ref mut trait_, .. }) = item {\n31 +             if let Item::Impl(ItemImpl { generics, trait_, .. }) = item {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_generic_constant_expressions_144.rs"
    },
    {
        "mutator_name": "Modify_Generic_Constant_Expression_In_Struct_Array_158",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Generic_Constant_Expression_In_Struct_Array_158_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:39:101\n   |\n39 | ...                   if let Expr::Path(ExprPath { path: array_path, .. }) = &*type_array.len {\n   |                                                                               ^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:42:70\n   |\n42 | ...                   type_array.len = Box::new(new_expr);\n   |                       --------------   ^^^^^^^^^^^^^^^^^^ expected `Expr`, found `Box<Expr>`\n   |                       |\n   |                       expected due to the type of this binding\n   |\n   = note: expected enum `syn::Expr`\n            found struct `std::boxed::Box<syn::Expr>`\nhelp: consider unboxing the value\n   |\n42 |                                                     type_array.len = *Box::new(new_expr);\n   |                                                                      +\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_generic_constant_expression_in_struct_array_158.rs"
    },
    {
        "mutator_name": "Modify_Generic_Const_Expressions_17",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_generic_const_expressions_17.rs"
    },
    {
        "mutator_name": "Modify_Generic_Const_Expressions_171",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_generic_const_expressions_171.rs"
    },
    {
        "mutator_name": "Modify_Generic_Const_Expressions_188",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Generic_Const_Expressions_188_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:44:83\n   |\n44 | ...                   if let Stmt::Expr(Expr::Binary(expr_binary)) = stmt {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n44 |                                                                 if let Stmt::Expr(Expr::Binary(expr_binary), _) = stmt {\n   |                                                                                                            +++\n\nerror[E0061]: this enum variant takes 2 arguments but 1 argument was supplied\n  --> src\\main.rs:49:85\n   |\n49 | ...                   *stmt = Stmt::Expr(new_expr);\n   |                               ^^^^^^^^^^---------- argument #2 of type `Option<Semi>` is missing\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:9\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |         ^^^^\nhelp: provide the argument\n   |\n49 |                                                                             *stmt = Stmt::Expr(new_expr, /* Option<Semi> */);\n   |                                                                                                        ++++++++++++++++++++\n\nSome errors have detailed explanations: E0023, E0061.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Generic_Const_Expressions_188_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:28:98\n   |\n28 | ...                   let new_expr: Expr = parse_quote! { #ident * 2 };\n   |                                            ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Fn(ref mut func) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `PathArguments`\n  --> src\\main.rs:19:52\n   |\n19 | ...                   if let PathArguments::AngleBracketed(ref mut args) = segment.arguments {\n   |                              ^^^^^^^^^^^^^ use of undeclared type `PathArguments`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::PathArguments;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericArgument`\n  --> src\\main.rs:21:60\n   |\n21 | ...                   if let GenericArgument::Const(expr) = arg {\n   |                              ^^^^^^^^^^^^^^^ use of undeclared type `GenericArgument`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericArgument;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:22:64\n   |\n22 | ...                   if let Expr::Block(expr_block) = expr {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:24:72\n   |\n24 | ...                   if let Stmt::Expr(Expr::Binary(expr_binary), _) = stmt {\n   |                              ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:24:83\n   |\n24 | ...                   if let Stmt::Expr(Expr::Binary(expr_binary), _) = stmt {\n   |                                         ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:25:76\n   |\n25 | ...                   if let Expr::Path(ref expr_path) = *expr_binary.left {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0412]: cannot find type `Expr` in this scope\n  --> src\\main.rs:28:91\n   |\n28 | ...                   let new_expr: Expr = parse_quote! { #ident * 2 };\n   |                                     ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:29:85\n   |\n29 | ...                   *stmt = Stmt::Expr(new_expr, None);\n   |                               ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 10 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Generic_Const_Expressions_188_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:24:83\n   |\n24 | ...                   if let Stmt::Expr(Expr::Binary(expr_binary)) = stmt {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n24 |                                                                 if let Stmt::Expr(Expr::Binary(expr_binary), _) = stmt {\n   |                                                                                                            +++\n\nerror[E0061]: this enum variant takes 2 arguments but 1 argument was supplied\n  --> src\\main.rs:29:85\n   |\n29 | ...                   *stmt = Stmt::Expr(new_expr);\n   |                               ^^^^^^^^^^---------- argument #2 of type `Option<Semi>` is missing\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:9\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |         ^^^^\nhelp: provide the argument\n   |\n29 |                                                                             *stmt = Stmt::Expr(new_expr, /* Option<Semi> */);\n   |                                                                                                        ++++++++++++++++++++\n\nerror[E0599]: no method named `mutate` found for struct `Modify_Generic_Const_Expressions_188` in the current scope\n  --> src\\main.rs:74:50\n   |\n3  | pub struct Modify_Generic_Const_Expressions_188;\n   | ----------------------------------------------- method `mutate` not found for this struct\n...\n74 |             Modify_Generic_Const_Expressions_188.mutate(&mut file_ast);\n   |                                                  ^^^^^^ method not found in `Modify_Generic_Const_Expressions_188`\n   |\n  ::: src\\mutator.rs:15:8\n   |\n15 |     fn mutate(&self, file: &mut syn::File);\n   |        ------ the method is available for `Modify_Generic_Const_Expressions_188` here\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: trait `Mutator` which provides `mutate` is implemented but not in scope; perhaps you want to import it\n   |\n1  + use crate::mutator::Mutator;\n   |\n\nSome errors have detailed explanations: E0023, E0061, E0599.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Generic_Const_Expressions_188_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:12:29\n   |\n12 |             if let Item::Fn(ref mut func) = item {\n   |                             ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:12:20\n   |\n12 |             if let Item::Fn(ref mut func) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n12 -             if let Item::Fn(ref mut func) = item {\n12 +             if let Item::Fn(func) = item {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Generic_Const_Expressions_188_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:25:83\n   |\n25 | ...                   if let Stmt::Expr(Expr::Binary(expr_binary)) = stmt {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n25 |                                                                 if let Stmt::Expr(Expr::Binary(expr_binary), _) = stmt {\n   |                                                                                                            +++\n\nerror[E0061]: this enum variant takes 2 arguments but 1 argument was supplied\n  --> src\\main.rs:30:85\n   |\n30 | ...                   *stmt = Stmt::Expr(new_expr);\n   |                               ^^^^^^^^^^---------- argument #2 of type `Option<Semi>` is missing\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:9\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |         ^^^^\nhelp: provide the argument\n   |\n30 |                                                                             *stmt = Stmt::Expr(new_expr, /* Option<Semi> */);\n   |                                                                                                        ++++++++++++++++++++\n\nSome errors have detailed explanations: E0023, E0061.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_generic_const_expressions_188.rs"
    },
    {
        "mutator_name": "Modify_Generic_Const_Expression_192",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_generic_const_expression_192.rs"
    },
    {
        "mutator_name": "Modify_Generic_Const_Expr_208",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Generic_Const_Expr_208_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0609]: no field `params` on type `&syn::Path`\n  --> src\\main.rs:33:44\n   |\n33 |                     for param in &generics.params {\n   |                                            ^^^^^^ unknown field\n   |\n   = note: available fields are: `leading_colon`, `segments`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Generic_Const_Expr_208_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0594]: cannot assign to `type_array.len`, which is behind a `&` reference\n  --> src\\main.rs:43:57\n   |\n43 | ...                   type_array.len = new_expr;\n   |                       ^^^^^^^^^^^^^^ `type_array` is a `&` reference, so the data it refers to cannot be written\n\nFor more information about this error, try `rustc --explain E0594`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_generic_const_expr_208.rs"
    },
    {
        "mutator_name": "Modify_Generic_Parameter_Constraints_58",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [],
        "label": "Negative",
        "file": ".\\mutators\\modify_generic_parameter_constraints_58.rs"
    },
    {
        "mutator_name": "Modify_Generic_Parameter_Defaults_149",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_generic_parameter_defaults_149.rs"
    },
    {
        "mutator_name": "Modify_Generic_Parameter_Defaults_51",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_generic_parameter_defaults_51.rs"
    },
    {
        "mutator_name": "Modify_Impl_Trait_Return_Types_87",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Impl_Trait_Return_Types_87_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `type_impl_trait.bounds` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:34:38\n   |\n34 |                         for bound in &mut type_impl_trait.bounds {\n   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^ `type_impl_trait` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_impl_trait_return_types_87.rs"
    },
    {
        "mutator_name": "Modify_Inherent_Associated_Types_213",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Inherent_Associated_Types_213_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0499]: cannot borrow `item_impl.items` as mutable more than once at a time\n  --> src\\main.rs:45:41\n   |\n36 |                         for item in &mut item_impl.items {\n   |                                     --------------------\n   |                                     |\n   |                                     first mutable borrow occurs here\n   |                                     first borrow later used here\n...\n45 |                                         item_impl.items.push(new_function);\n   |                                         ^^^^^^^^^^^^^^^ second mutable borrow occurs here\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_inherent_associated_types_213.rs"
    },
    {
        "mutator_name": "Modify_Inherent_Associated_Types_214",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [],
        "label": "Negative",
        "file": ".\\mutators\\modify_inherent_associated_types_214.rs"
    },
    {
        "mutator_name": "Modify_Inherent_Associated_Type_220",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Inherent_Associated_Type_220_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:36:73\n   |\n36 | ...                   if let Type::Reference(type_ref) = &mut *impl_type.ty {\n   |                                                               ^^^^^^^^^^^^^ can't be dereferenced\n\nFor more information about this error, try `rustc --explain E0614`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_inherent_associated_type_220.rs"
    },
    {
        "mutator_name": "Modify_Lifetime_Annotations_165",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_lifetime_annotations_165.rs"
    },
    {
        "mutator_name": "Modify_Lifetime_Annotations_88",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Lifetime_Annotations_88_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `TraitItem` in the current scope\n  --> src\\main.rs:33:44\n   |\n33 |                     if let syn::TraitItem::Method(method) = trait_item {\n   |                                            ^^^^^^ variant or associated item not found in `TraitItem`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Lifetime_Annotations_88_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0432]: unresolved import `syn::TraitItemMethod`\n  --> src\\main.rs:19:27\n   |\n19 |     ItemTrait, TraitItem, TraitItemMethod,\n   |                           ^^^^^^^^^^^^^^^\n   |                           |\n   |                           no `TraitItemMethod` in the root\n   |                           help: a similar name exists in the module: `TraitItemMacro`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `TraitItem` in the current scope\n  --> src\\main.rs:34:39\n   |\n34 |                     if let TraitItem::Method(method) = trait_item {\n   |                                       ^^^^^^ variant or associated item not found in `TraitItem`\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Lifetime_Annotations_88_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0502]: cannot borrow `method.sig.generics.params` as immutable because it is also borrowed as mutable\n  --> src\\main.rs:42:53\n   |\n35 |                         if let Some(sig) = &mut method.sig.generics.params.iter_mut().find_map(|param| {\n   |                                                 -------------------------- mutable borrow occurs here\n...\n42 |                             let lifetimes: Vec<_> = method.sig.generics.params.iter().filter_map(|param| {\n   |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ immutable borrow occurs here\n...\n53 |                                 sig.colon_token = None;\n   |                                 ---------------------- mutable borrow later used here\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Lifetime_Annotations_88_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Trait(trait_item) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TraitItem`\n  --> src\\main.rs:13:28\n   |\n13 |                     if let TraitItem::Fn(method) = trait_item {\n   |                            ^^^^^^^^^ use of undeclared type `TraitItem`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TraitItem;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericParam`\n  --> src\\main.rs:15:36\n   |\n15 | ...                   if let GenericParam::Lifetime(lifetime) = param {\n   |                              ^^^^^^^^^^^^ use of undeclared type `GenericParam`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericParam`\n  --> src\\main.rs:24:40\n   |\n24 | ...                   if let GenericParam::Lifetime(lifetime) = param {\n   |                              ^^^^^^^^^^^^ use of undeclared type `GenericParam`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nFor more information about this error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Lifetime_Annotations_88_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Modify_Lifetime_Annotations_88 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_lifetime_annotations_88.rs"
    },
    {
        "mutator_name": "Modify_Lifetime_Annotations_89",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Lifetime_Annotations_89_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0609]: no field `params` on type `&mut syn::Path`\n  --> src\\main.rs:40:84\n   |\n40 |                     if let Some(GenericParam::Lifetime(lifetime_param)) = generics.params.first_mut() {\n   |                                                                                    ^^^^^^ unknown field\n   |\n   = note: available fields are: `leading_colon`, `segments`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_lifetime_annotations_89.rs"
    },
    {
        "mutator_name": "Modify_Lifetime_Annotations_92",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Lifetime_Annotations_92_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `segment.arguments` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:56:74\n   |\n56 | ...                   if let PathArguments::AngleBracketed(args) = &mut segment.arguments {\n   |                                                                    ^^^^^^^^^^^^^^^^^^^^^^ `segment` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n   |\nhelp: consider changing this to be a mutable reference\n   |\n40 |                         let segment = &mut path.segments[0];\n   |                                        +++\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Lifetime_Annotations_92_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:12:20\n   |\n12 |             if let Item::Impl(ItemImpl {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `ItemImpl` in this scope\n  --> src\\main.rs:12:31\n   |\n12 |             if let Item::Impl(ItemImpl {\n   |                               ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::ItemImpl;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericParam`\n  --> src\\main.rs:24:40\n   |\n24 | ...                   if let GenericParam::Lifetime(_) = param {\n   |                              ^^^^^^^^^^^^ use of undeclared type `GenericParam`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Lifetime`\n  --> src\\main.rs:25:56\n   |\n25 | ...                   let new_lifetime = Lifetime::new(&format!(\"'c{}\", i), Span::call_site());\n   |                                          ^^^^^^^^ use of undeclared type `Lifetime`\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::Lifetime;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:25:91\n   |\n25 | ...                   let new_lifetime = Lifetime::new(&format!(\"'c{}\", i), Span::call_site());\n   |                                                                             ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericParam`\n  --> src\\main.rs:31:40\n   |\n31 | ...                   if let GenericParam::Lifetime(lifetime_param) = param {\n   |                              ^^^^^^^^^^^^ use of undeclared type `GenericParam`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `PathArguments`\n  --> src\\main.rs:36:36\n   |\n36 | ...                   if let PathArguments::AngleBracketed(args) = &mut segment.arguments {\n   |                              ^^^^^^^^^^^^^ use of undeclared type `PathArguments`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::PathArguments;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericArgument`\n  --> src\\main.rs:38:44\n   |\n38 | ...                   if let GenericArgument::Lifetime(lifetime) = arg {\n   |                              ^^^^^^^^^^^^^^^ use of undeclared type `GenericArgument`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericArgument;\n   |\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 8 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Lifetime_Annotations_92_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:6:6\n  |\n6 | impl Mutator for Modify_Lifetime_Annotations_92 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_lifetime_annotations_92.rs"
    },
    {
        "mutator_name": "Modify_Lifetime_Associated_Types_86",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Lifetime_Associated_Types_86_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:40:36\n   |\n40 | ...                   if let Some((_, ref mut generics, _)) = &mut node.generics.split_for_impl() {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ----------------------------------- this expression has type `&mut (ImplGenerics<'_>, TypeGenerics<'_>, Option<&WhereClause>)`\n   |                              |\n   |                              expected `(ImplGenerics<'_>, ..., ...)`, found `Option<_>`\n   |\n   = note: expected tuple `(ImplGenerics<'_>, TypeGenerics<'_>, Option<&WhereClause>)`\n               found enum `Option<_>`\n\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:57:108\n   |\n57 | ...                   if let Type::Path(TypePath { path: ref mut type_path, .. }) = &mut *impl_type.ty {\n   |                                                                                          ^^^^^^^^^^^^^ can't be dereferenced\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Lifetime_Associated_Types_86_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0609]: no field `params` on type `ImplGenerics<'_>`\n  --> src\\main.rs:41:57\n   |\n41 | ...                   for param in &impl_generics.params {\n   |                                                   ^^^^^^ unknown field\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Lifetime_Associated_Types_86_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:37:33\n   |\n37 |                 if let Some((_, ref path, _)) = &node.trait_ {\n   |                                 ^^^ binding modifier not allowed under `ref` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:37:24\n   |\n37 |                 if let Some((_, ref path, _)) = &node.trait_ {\n   |                        ^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&_`\nhelp: remove the unnecessary binding modifier\n   |\n37 -                 if let Some((_, ref path, _)) = &node.trait_ {\n37 +                 if let Some((_, path, _)) = &node.trait_ {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:53:55\n   |\n53 | ...                   if let ImplItem::Type(ref mut impl_type) = item {\n   |                                             ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:53:40\n   |\n53 | ...                   if let ImplItem::Type(ref mut impl_type) = item {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n53 -                                 if let ImplItem::Type(ref mut impl_type) = item {\n53 +                                 if let ImplItem::Type(impl_type) = item {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:55:76\n   |\n55 | ...                   if let Type::Path(TypePath { path: ref mut type_path, .. }) = &mut impl_type.ty {\n   |                                                          ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:55:48\n   |\n55 | ...                   if let Type::Path(TypePath { path: ref mut type_path, .. }) = &mut impl_type.ty {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n55 -                                         if let Type::Path(TypePath { path: ref mut type_path, .. }) = &mut impl_type.ty {\n55 +                                         if let Type::Path(TypePath { path: type_path, .. }) = &mut impl_type.ty {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:59:90\n   |\n59 | ...                   if let GenericArgument::Lifetime(ref mut lifetime) = arg {\n   |                                                        ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:59:64\n   |\n59 | ...                   if let GenericArgument::Lifetime(ref mut lifetime) = arg {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n59 -                                                         if let GenericArgument::Lifetime(ref mut lifetime) = arg {\n59 +                                                         if let GenericArgument::Lifetime(lifetime) = arg {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_lifetime_associated_types_86.rs"
    },
    {
        "mutator_name": "Modify_Lifetime_Constraints_81",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_lifetime_constraints_81.rs"
    },
    {
        "mutator_name": "Modify_Loop_In_Const_Context_39",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Loop_In_Const_Context_39_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:45:63\n   |\n45 |                         if let Stmt::Local(Local { init: Some((_, expr)), .. }) = stmt {\n   |                                                               ^^^^^^^^^           ---- this expression has type `&mut Stmt`\n   |                                                               |\n   |                                                               expected `LocalInit`, found `(_, _)`\n   |\n   = note: expected struct `LocalInit`\n               found tuple `(_, _)`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Loop_In_Const_Context_39_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0594]: cannot assign to `expr_loop.body.stmts`, which is behind a `&` reference\n  --> src\\main.rs:40:21\n   |\n40 |                     expr_loop.body.stmts = new_stmts;\n   |                     ^^^^^^^^^^^^^^^^^^^^ `expr_loop` is a `&` reference, so the data it refers to cannot be written\n\nerror[E0594]: cannot assign to `expr_loop.body.stmts`, which is behind a `&` reference\n  --> src\\main.rs:54:33\n   |\n54 | ...                   expr_loop.body.stmts = new_stmts;\n   |                       ^^^^^^^^^^^^^^^^^^^^ `expr_loop` is a `&` reference, so the data it refers to cannot be written\n\nFor more information about this error, try `rustc --explain E0594`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_loop_in_const_context_39.rs"
    },
    {
        "mutator_name": "Modify_Macro_Inside_Async_Closure_99",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Macro_Inside_Async_Closure_99_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Semi` found for enum `Stmt` in the current scope\n  --> src\\main.rs:49:34\n   |\n49 |                     if let Stmt::Semi(Expr::Macro(ref mut mac), _) = stmt {\n   |                                  ^^^^ variant or associated item not found in `Stmt`\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:29\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                             ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n31 -             if let Item::Fn(ref mut func) = item {\n31 +             if let Item::Fn(func) = item {\n   |\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Macro_Inside_Async_Closure_99_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:49:39\n   |\n49 |                     if let Stmt::Expr(Expr::Macro(ref mut mac)) = stmt {\n   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n49 |                     if let Stmt::Expr(Expr::Macro(ref mut mac), _) = stmt {\n   |                                                               +++\n\nFor more information about this error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Macro_Inside_Async_Closure_99_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:49:51\n   |\n49 |                     if let Stmt::Expr(Expr::Macro(ref mut mac), _) = stmt {\n   |                                                   ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:49:28\n   |\n49 |                     if let Stmt::Expr(Expr::Macro(ref mut mac), _) = stmt {\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n49 -                     if let Stmt::Expr(Expr::Macro(ref mut mac), _) = stmt {\n49 +                     if let Stmt::Expr(Expr::Macro(mac), _) = stmt {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_macro_inside_async_closure_99.rs"
    },
    {
        "mutator_name": "Modify_Macro_Invocation_With_Expression_Inside_Path_97",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_macro_invocation_with_expression_inside_path_97.rs"
    },
    {
        "mutator_name": "Modify_Match_Arms_20",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Match_Arms_20_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:33:39\n   |\n33 |                     if let Stmt::Expr(Expr::Match(expr_match)) = stmt {\n   |                                       ^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n33 |                     if let Stmt::Expr(Expr::Match(expr_match), _) = stmt {\n   |                                                              +++\n\nerror[E0277]: the trait bound `std::boxed::Box<syn::Expr>: AsRef<str>` is not satisfied\n  --> src\\main.rs:37:52\n   |\n37 | ...                   if pat_ident.ident == matched_expr_type {\n   |                                          ^^ the trait `AsRef<str>` is not implemented for `std::boxed::Box<syn::Expr>`\n   |\n   = help: the trait `AsRef<str>` is not implemented for `std::boxed::Box<syn::Expr>`\n           but trait `AsRef<syn::Expr>` is implemented for it\n   = help: for that trait implementation, expected `syn::Expr`, found `str`\n   = note: required for `&std::boxed::Box<syn::Expr>` to implement `AsRef<str>`\n   = note: required for `proc_macro2::Ident` to implement `PartialEq<&std::boxed::Box<syn::Expr>>`\n\nSome errors have detailed explanations: E0023, E0277.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_match_arms_20.rs"
    },
    {
        "mutator_name": "Modify_Non_Valtree_Compatible_Type_19",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Non_Valtree_Compatible_Type_19_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:35:54\n   |\n35 | ...                   if let Expr::Block(_) = &**default {\n   |                                                ^^^^^^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n   --> src\\main.rs:38:60\n    |\n38  | ...                   const_param.default = Some(Box::new(parse_quote!(1)));\n    |                                             ---- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Expr`, found `Box<_>`\n    |                                             |\n    |                                             arguments to this enum variant are incorrect\n    |\n    = note: expected enum `syn::Expr`\n             found struct `std::boxed::Box<_>`\nhelp: the type constructed contains `std::boxed::Box<_>` due to the type of the argument passed\n   --> src\\main.rs:38:55\n    |\n38  | ...                   const_param.default = Some(Box::new(parse_quote!(1)));\n    |                                             ^^^^^-------------------------^\n    |                                                  |\n    |                                                  this argument influences the type of `Some`\nnote: tuple variant defined here\n   --> C:\\Users\\love\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\option.rs:597:5\n    |\n597 |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    |     ^^^^\nhelp: consider unboxing the value\n    |\n38  |                                 const_param.default = Some(*Box::new(parse_quote!(1)));\n    |                                                            +\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Non_Valtree_Compatible_Type_19_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: the method `as_ref` exists for reference `&syn::Expr`, but its trait bounds were not satisfied\n   --> src\\main.rs:35:61\n    |\n35  |   ...                   if let Expr::Block(_) = default.as_ref() {\n    |                                                         ^^^^^^ method cannot be called on `&syn::Expr` due to unsatisfied trait bounds\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\expr.rs:35:1\n    |\n35  | / ast_enum_of_structs! {\n36  | |     /// A Rust expression.\n37  | |     ///\n38  | |     /// *This type is available only if Syn is built with the `\"derive\"` or `\"full\"`\n...   |\n267 | | }\n    | |_- doesn't satisfy `syn::Expr: AsRef<_>`\n    |\n    = note: the following trait bounds were not satisfied:\n            `syn::Expr: AsRef<_>`\n            which is required by `&syn::Expr: AsRef<_>`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_non_valtree_compatible_type_19.rs"
    },
    {
        "mutator_name": "Modify_Opaque_Return_Types_79",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Opaque_Return_Types_79_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:32:29\n   |\n32 |             if let Item::Fn(ref mut func) = item {\n   |                             ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:32:20\n   |\n32 |             if let Item::Fn(ref mut func) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n32 -             if let Item::Fn(ref mut func) = item {\n32 +             if let Item::Fn(func) = item {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_opaque_return_types_79.rs"
    },
    {
        "mutator_name": "Modify_Return_Path_231",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Return_Path_231_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:35:47\n   |\n35 | ...                   if let Stmt::Expr(Expr::If(ref mut if_expr)) = stmt {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n35 |                             if let Stmt::Expr(Expr::If(ref mut if_expr), _) = stmt {\n   |                                                                        +++\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:38:59\n   |\n38 | ...                   if let Stmt::Expr(ref mut expr) = last_expr {\n   |                                         ^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n38 |                                         if let Stmt::Expr(ref mut expr, _) = last_expr {\n   |                                                                       +++\n\nFor more information about this error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Return_Path_231_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:29\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                             ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n31 -             if let Item::Fn(ref mut func) = item {\n31 +             if let Item::Fn(func) = item {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:35:56\n   |\n35 | ...                   if let Stmt::Expr(Expr::If(ref mut if_expr), _) = stmt {\n   |                                                  ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:35:36\n   |\n35 | ...                   if let Stmt::Expr(Expr::If(ref mut if_expr), _) = stmt {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n35 -                             if let Stmt::Expr(Expr::If(ref mut if_expr), _) = stmt {\n35 +                             if let Stmt::Expr(Expr::If(if_expr), _) = stmt {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:38:59\n   |\n38 | ...                   if let Stmt::Expr(ref mut expr, _) = last_expr {\n   |                                         ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:38:48\n   |\n38 | ...                   if let Stmt::Expr(ref mut expr, _) = last_expr {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n38 -                                         if let Stmt::Expr(ref mut expr, _) = last_expr {\n38 +                                         if let Stmt::Expr(expr, _) = last_expr {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Return_Path_231_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:19:53\n   |\n19 | ...                   *expr = parse_quote! { Box::new(#expr) };\n   |                               ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Fn(func) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `ReturnType`\n  --> src\\main.rs:12:24\n   |\n12 |                 if let ReturnType::Type(_, ref return_type) = func.sig.output {\n   |                        ^^^^^^^^^^ use of undeclared type `ReturnType`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::ReturnType;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:13:28\n   |\n13 |                     if let Type::ImplTrait(_) = **return_type {\n   |                            ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:15:36\n   |\n15 | ...                   if let Stmt::Expr(Expr::If(if_expr), _) = stmt {\n   |                              ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:15:47\n   |\n15 | ...                   if let Stmt::Expr(Expr::If(if_expr), _) = stmt {\n   |                                         ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:16:40\n   |\n16 | ...                   if let Expr::Block(ref mut else_block) = *if_expr.else_branch.as_mut().unwrap().1 {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:18:48\n   |\n18 | ...                   if let Stmt::Expr(expr, _) = last_expr {\n   |                              ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nFor more information about this error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 8 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Return_Path_231_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Modify_Return_Path_231 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Return_Path_231_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:16:47\n   |\n16 | ...                   if let Stmt::Expr(Expr::If(if_expr)) = stmt {\n   |                                         ^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n16 |                             if let Stmt::Expr(Expr::If(if_expr), _) = stmt {\n   |                                                                +++\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:20:63\n   |\n20 | ...                   if let Stmt::Expr(expr) = last_expr {\n   |                                         ^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n20 |                                             if let Stmt::Expr(expr, _) = last_expr {\n   |                                                                   +++\n\nFor more information about this error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_return_path_231.rs"
    },
    {
        "mutator_name": "Modify_Slice_Indexing_157",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Slice_Indexing_157_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:47:29\n   |\n47 |             if let Item::Fn(ref mut item_fn) = item {\n   |                             ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:47:20\n   |\n47 |             if let Item::Fn(ref mut item_fn) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n47 -             if let Item::Fn(ref mut item_fn) = item {\n47 +             if let Item::Fn(item_fn) = item {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_slice_indexing_157.rs"
    },
    {
        "mutator_name": "Modify_Slice_Indexing_Out_Of_Bounds_61",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_slice_indexing_out_of_bounds_61.rs"
    },
    {
        "mutator_name": "Modify_Static_Lifetime_Bound_48",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_static_lifetime_bound_48.rs"
    },
    {
        "mutator_name": "Modify_Static_Variable_Initialization_35",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Static_Variable_Initialization_35_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:33\n   |\n31 |             if let Item::Static(ref mut static_item) = item {\n   |                                 ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Static(ref mut static_item) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n31 -             if let Item::Static(ref mut static_item) = item {\n31 +             if let Item::Static(static_item) = item {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Static_Variable_Initialization_35_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Static(static_item) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:12:24\n   |\n12 |                 if let Type::Path(TypePath { path: ref type_path, .. }) = *static_item.ty {\n   |                        ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypePath` in this scope\n  --> src\\main.rs:12:35\n   |\n12 |                 if let Type::Path(TypePath { path: ref type_path, .. }) = *static_item.ty {\n   |                                   ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypePath;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:14:32\n   |\n14 |                         if let Expr::Call(ref mut expr_call) = *static_item.expr {\n   |                                ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:15:41\n   |\n15 | ...                   if let Some(Expr::Lit(expr_lit)) = expr_call.args.first_mut() {\n   |                                   ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 5 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Static_Variable_Initialization_35_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Modify_Static_Variable_Initialization_35 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Static_Variable_Initialization_35_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:16:75\n   |\n16 | ...                   if let Some(Expr::Lit(ExprLit { lit: Lit::Int(ref mut lit_int), .. })) = expr_call.args.first_mut() {\n   |                                                                     ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:16:41\n   |\n16 | ...                   if let Some(Expr::Lit(ExprLit { lit: Lit::Int(ref mut lit_int), .. })) = expr_call.args.first_mut() {\n   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n16 -                             if let Some(Expr::Lit(ExprLit { lit: Lit::Int(ref mut lit_int), .. })) = expr_call.args.first_mut() {\n16 +                             if let Some(Expr::Lit(ExprLit { lit: Lit::Int(lit_int), .. })) = expr_call.args.first_mut() {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_static_variable_initialization_35.rs"
    },
    {
        "mutator_name": "Modify_Static_Var_233",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Static_Var_233_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:34:32\n   |\n34 |                         if let Some(init_expr) = &static_item.expr {\n   |                                ^^^^^^^^^^^^^^^   ----------------- this expression has type `&std::boxed::Box<syn::Expr>`\n   |                                |\n   |                                expected `Box<Expr>`, found `Option<_>`\n   |\n   = note: expected struct `std::boxed::Box<syn::Expr>`\n                found enum `Option<_>`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Static_Var_233_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:34:32\n   |\n34 |                         if let Some(_) = static_item.expr.as_ref() {\n   |                                ^^^^^^^   ------------------------- this expression has type `&syn::Expr`\n   |                                |\n   |                                expected `Expr`, found `Option<_>`\n   |\n   = note: expected enum `syn::Expr`\n              found enum `Option<_>`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Static_Var_233_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `is_some` found for struct `std::boxed::Box<syn::Expr>` in the current scope\n  --> src\\main.rs:34:45\n   |\n34 |                         if static_item.expr.is_some() {\n   |                                             ^^^^^^^ method not found in `Box<Expr>`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Static_Var_233_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:34:32\n   |\n34 |                         if let Some(_) = static_item.expr {\n   |                                ^^^^^^^   ---------------- this expression has type `std::boxed::Box<syn::Expr>`\n   |                                |\n   |                                expected `Box<Expr>`, found `Option<_>`\n   |\n   = note: expected struct `std::boxed::Box<syn::Expr>`\n                found enum `Option<_>`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Static_Var_233_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:33\n   |\n31 |             if let Item::Static(ref mut static_item) = item {\n   |                                 ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Static(ref mut static_item) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n31 -             if let Item::Static(ref mut static_item) = item {\n31 +             if let Item::Static(static_item) = item {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_static_var_233.rs"
    },
    {
        "mutator_name": "Modify_Struct_Array_Size_40",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Struct_Array_Size_40_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:34:42\n   |\n34 |                         type_array.len = Box::new(parse_quote!(usize::MAX >> 1));\n   |                         --------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Expr`, found `Box<_>`\n   |                         |\n   |                         expected due to the type of this binding\n   |\n   = note: expected enum `syn::Expr`\n            found struct `std::boxed::Box<_>`\nhelp: consider unboxing the value\n   |\n34 |                         type_array.len = *Box::new(parse_quote!(usize::MAX >> 1));\n   |                                          +\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_struct_array_size_40.rs"
    },
    {
        "mutator_name": "Add_Const_Generics_57",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Add_Const_Generics_57_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:56:76\n   |\n56 | ...                   if let syn::Type::Array(type_array) = &mut *predicate_type.bounded_ty {\n   |                                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^ can't be dereferenced\n\nFor more information about this error, try `rustc --explain E0614`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Add_Const_Generics_57_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `as_ref` found for enum `syn::Type` in the current scope\n  --> src\\main.rs:56:97\n   |\n56 | ...                   if let syn::Type::Array(type_array) = predicate_type.bounded_ty.as_ref() {\n   |                                                                                       ^^^^^^ method not found in `syn::Type`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Add_Const_Generics_57_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `type_array.len` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:57:73\n   |\n57 | ...                   if let syn::Expr::Path(expr_path) = &mut type_array.len {\n   |                                                           ^^^^^^^^^^^^^^^^^^^ `type_array` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Add_Const_Generics_57_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:59:54\n   |\n59 | ...                   *expr_path = new_expr;\n   |                       ----------   ^^^^^^^^ expected `ExprPath`, found `Expr`\n   |                       |\n   |                       expected due to the type of this binding\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Add_Const_Generics_57_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `type_array.len` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:57:73\n   |\n57 | ...                   if let syn::Expr::Path(expr_path) = &mut type_array.len {\n   |                                                           ^^^^^^^^^^^^^^^^^^^ `type_array` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Add_Const_Generics_57_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:64:50\n   |\n64 | ...                   len: Box::new(new_len),\n   |                            ^^^^^^^^^^^^^^^^^ expected `Expr`, found `Box<Expr>`\n   |\n   = note: expected enum `syn::Expr`\n            found struct `std::boxed::Box<syn::Expr>`\nhelp: consider unboxing the value\n   |\n64 |                                             len: *Box::new(new_len),\n   |                                                  +\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Add_Const_Generics_57_compling_err_7.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.01s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:58:66:\nunexpected token\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\add_const_generics_57.rs"
    },
    {
        "mutator_name": "Add_Const_Generic_To_Array_170",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Add_Const_Generic_To_Array_170_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:39:68\n   |\n39 | ...                   if let Expr::Path(ref expr_path) = *type_array.len {\n   |                                                          ^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:54:53\n   |\n54 |   ...                   ty: Box::new(Type::Path(TypePath {\n   |  ___________________________^\n55 | | ...                       qself: None,\n56 | | ...                       path: parse_quote!(usize),\n57 | | ...                   })),\n   | |_________________________^ expected `Type`, found `Box<Type>`\n   |\n   = note: expected enum `syn::Type`\n            found struct `std::boxed::Box<syn::Type>`\nhelp: consider unboxing the value\n   |\n54 |                                                 ty: *Box::new(Type::Path(TypePath {\n   |                                                     +\n\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:61:45\n   |\n61 | ...                   *type_array.len = Expr::Path(ExprPath {\n   |                       ^^^^^^^^^^^^^^^ can't be dereferenced\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Add_Const_Generic_To_Array_170_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `as_ref` found for enum `syn::Expr` in the current scope\n  --> src\\main.rs:39:83\n   |\n39 | ...                   if let Expr::Path(ref expr_path) = type_array.len.as_ref() {\n   |                                                                         ^^^^^^ method not found in `syn::Expr`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:61:62\n   |\n61 |   ...                   type_array.len = Box::new(Expr::Path(ExprPath {\n   |  _______________________--------------___^\n   | |                       |\n   | |                       expected due to the type of this binding\n62 | | ...                       attrs: Vec::new(),\n63 | | ...                       qself: None,\n64 | | ...                       path: SynPath::from(generic_ident.clone()),\n65 | | ...                   }));\n   | |_________________________^ expected `Expr`, found `Box<Expr>`\n   |\n   = note: expected enum `syn::Expr`\n            found struct `std::boxed::Box<syn::Expr>`\nhelp: consider unboxing the value\n   |\n61 |                                             type_array.len = *Box::new(Expr::Path(ExprPath {\n   |                                                              +\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Add_Const_Generic_To_Array_170_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:39:68\n   |\n39 | ...                   if let Expr::Path(ref expr_path) = *type_array.len {\n   |                                                          ^^^^^^^^^^^^^^^ can't be dereferenced\n\nFor more information about this error, try `rustc --explain E0614`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Add_Const_Generic_To_Array_170_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:29\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                             ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n31 -             if let Item::Fn(ref mut func) = item {\n31 +             if let Item::Fn(func) = item {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:43:72\n   |\n43 | ...                   if let GenericParam::Const(ref const_param) = param {\n   |                                                  ^^^ binding modifier not allowed under `ref` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:43:52\n   |\n43 | ...                   if let GenericParam::Const(ref const_param) = param {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&_`\nhelp: remove the unnecessary binding modifier\n   |\n43 -                                             if let GenericParam::Const(ref const_param) = param {\n43 +                                             if let GenericParam::Const(const_param) = param {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\add_const_generic_to_array_170.rs"
    },
    {
        "mutator_name": "Align_Const_Types_195",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Align_Const_Types_195_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:50:77\n   |\n50 | ...                   if let Expr::Binary(expr_binary) = &*type_array.len {\n   |                                                           ^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:54:45\n   |\n54 | ...                   *type_array.len = new_expr;\n   |                       ^^^^^^^^^^^^^^^ can't be dereferenced\n\nFor more information about this error, try `rustc --explain E0614`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Align_Const_Types_195_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:54:62\n   |\n54 | ...                   type_array.len = Box::new(new_expr);\n   |                       --------------   ^^^^^^^^^^^^^^^^^^ expected `Expr`, found `Box<Expr>`\n   |                       |\n   |                       expected due to the type of this binding\n   |\n   = note: expected enum `syn::Expr`\n            found struct `std::boxed::Box<syn::Expr>`\nhelp: consider unboxing the value\n   |\n54 |                                             type_array.len = *Box::new(new_expr);\n   |                                                              +\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Align_Const_Types_195_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `into_inner` found for struct `std::boxed::Box<syn::Expr>` in the current scope\n  --> src\\main.rs:54:81\n   |\n54 | ...                   type_array.len = Box::new(new_expr).into_inner();\n   |                                        -------------------^^^^^^^^^^--\n   |                                        |                  |\n   |                                        |                  this is an associated function, not a method\n   |                                        help: use associated function syntax instead: `std::boxed::Box::<syn::Expr>::into_inner(Box::new(new_expr))`\n   |\n   = note: found the following associated functions; to be used as methods, functions must have a `self` parameter\n   = note: the candidate is defined in an impl for the type `std::boxed::Box<T, A>`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Align_Const_Types_195_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:54:62\n   |\n54 | ...                   type_array.len = Box::new(new_expr);\n   |                       --------------   ^^^^^^^^^^^^^^^^^^ expected `Expr`, found `Box<Expr>`\n   |                       |\n   |                       expected due to the type of this binding\n   |\n   = note: expected enum `syn::Expr`\n            found struct `std::boxed::Box<syn::Expr>`\nhelp: consider unboxing the value\n   |\n54 |                                             type_array.len = *Box::new(new_expr);\n   |                                                              +\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Align_Const_Types_195_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:50:77\n   |\n50 | ...                   if let Expr::Binary(expr_binary) = &*type_array.len {\n   |                                                           ^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:54:62\n   |\n54 | ...                   type_array.len = Box::new(new_expr);\n   |                       --------------   ^^^^^^^^^^^^^^^^^^ expected `Expr`, found `Box<Expr>`\n   |                       |\n   |                       expected due to the type of this binding\n   |\n   = note: expected enum `syn::Expr`\n            found struct `std::boxed::Box<syn::Expr>`\nhelp: consider unboxing the value\n   |\n54 |                                             type_array.len = *Box::new(new_expr);\n   |                                                              +\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Align_Const_Types_195_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0499]: cannot borrow `file.items` as mutable more than once at a time\n  --> src\\main.rs:36:43\n   |\n30 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     first mutable borrow occurs here\n   |                     first borrow later used here\n...\n36 |                         for impl_block in &mut file.items {\n   |                                           ^^^^^^^^^^^^^^^ second mutable borrow occurs here\n\nerror[E0594]: cannot assign to `type_array.len`, which is behind a `&` reference\n  --> src\\main.rs:54:45\n   |\n54 | ...                   type_array.len = new_expr;\n   |                       ^^^^^^^^^^^^^^ `type_array` is a `&` reference, so the data it refers to cannot be written\n\nSome errors have detailed explanations: E0499, E0594.\nFor more information about an error, try `rustc --explain E0499`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Align_Const_Types_195_compling_err_7.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:52:58\n   |\n52 | ...                   impl_items.push((const_name.clone(), parse_quote! {\n   |                                        ^^^^^^^^^^^^^^^^^^ expected `&TypeArray`, found `Ident`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:66:20\n   |\n66 |             if let Type::Array(type_array) = type_array {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^   ---------- this expression has type `&TypeArray`\n   |                    |\n   |                    expected `TypeArray`, found `Type`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:68:27\n   |\n68 |             } else if let syn::ImplItem::Verbatim(item) = new_expr {\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   -------- this expression has type `syn::Expr`\n   |                           |\n   |                           expected `Expr`, found `ImplItem`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Align_Const_Types_195_compling_err_8.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:52:58\n   |\n52 |   ...                   impl_items.push((Type::Verbatim(parse_quote! {\n   |  ________________________________________^\n53 | | ...                       fn dummy_arithmetic() {\n54 | | ...                           let _ = #const_name + (#const_name * 2) as i64;\n55 | | ...                       }\n56 | | ...                   }), Expr::Verbatim(parse_quote! {})));\n   | |________________________^ expected `TypeArray`, found `Type`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:66:20\n   |\n66 |             if let Type::Array(mut type_array) = type_array {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^   ---------- this expression has type `TypeArray`\n   |                    |\n   |                    expected `TypeArray`, found `Type`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:68:27\n   |\n68 |             } else if let Type::Verbatim(item) = type_array {\n   |                           ^^^^^^^^^^^^^^^^^^^^   ---------- this expression has type `TypeArray`\n   |                           |\n   |                           expected `TypeArray`, found `Type`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Align_Const_Types_195_compling_err_9.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0502]: cannot borrow `file.items` as immutable because it is also borrowed as mutable\n  --> src\\main.rs:36:43\n   |\n31 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     mutable borrow occurs here\n   |                     mutable borrow later used here\n...\n36 |                         for impl_block in &file.items {\n   |                                           ^^^^^^^^^^^ immutable borrow occurs here\n\nerror[E0596]: cannot borrow `item_impl.generics.where_clause` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:40:69\n   |\n40 | ...                   for where_predicate in &mut item_impl.generics.where_clause.as_mut().unwrap().predicates {\n   |                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `item_impl` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nSome errors have detailed explanations: E0502, E0596.\nFor more information about an error, try `rustc --explain E0502`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\align_const_types_195.rs"
    },
    {
        "mutator_name": "Alter_Static_Mutability_44",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Alter_Static_Mutability_44_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:35:21\n   |\n34 |                 let involves_unsafe = match &item_static.expr {\n   |                                             ----------------- this expression has type `&std::boxed::Box<syn::Expr>`\n35 |                     Expr::Unsafe(_) => true,\n   |                     ^^^^^^^^^^^^^^^ expected `Box<Expr>`, found `Expr`\n   |\n   = note: expected struct `std::boxed::Box<syn::Expr>`\n                found enum `syn::Expr`\nhelp: consider dereferencing to access the inner value using the Deref trait\n   |\n34 |                 let involves_unsafe = match &*item_static.expr {\n   |                                              +\n\nerror[E0599]: no method named `is_none` found for enum `StaticMutability` in the current scope\n  --> src\\main.rs:40:47\n   |\n40 |                     if item_static.mutability.is_none() {\n   |                                               ^^^^^^^ method not found in `StaticMutability`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:41:50\n   |\n41 |                         item_static.mutability = Some(token::Mut::default());\n   |                         ----------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `StaticMutability`, found `Option<Mut>`\n   |                         |\n   |                         expected due to the type of this binding\n   |\n   = note: expected enum `StaticMutability`\n              found enum `Option<syn::token::Mut>`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:43:50\n   |\n43 |                         item_static.mutability = None;\n   |                         ----------------------   ^^^^ expected `StaticMutability`, found `Option<_>`\n   |                         |\n   |                         expected due to the type of this binding\n   |\n   = note: expected enum `StaticMutability`\n              found enum `Option<_>`\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Static_Mutability_44_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0004]: non-exhaustive patterns: `_` not covered\n   --> src\\main.rs:40:27\n    |\n40  |                     match item_static.mutability {\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ pattern `_` not covered\n    |\nnote: `syn::StaticMutability` defined here\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\item.rs:878:1\n    |\n878 | / ast_enum! {\n879 | |     /// The mutability of an `Item::Static` or `ForeignItem::Static`.\n880 | |     #[cfg_attr(docsrs, doc(cfg(feature = \"full\")))]\n881 | |     #[non_exhaustive]\n...   |\n886 | | }\n    | |_^\n    = note: the matched value is of type `syn::StaticMutability`\n    = note: `syn::StaticMutability` is marked as non-exhaustive, so a wildcard `_` is necessary to match exhaustively\n    = note: this error originates in the macro `ast_enum` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n42  ~                         StaticMutability::None => item_static.mutability = StaticMutability::Mut(token::Mut::default()),\n43  ~                         _ => todo!(),\n    |\n\nFor more information about this error, try `rustc --explain E0004`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\alter_static_mutability_44.rs"
    },
    {
        "mutator_name": "Enum_Destructuring_Async_16",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Enum_Destructuring_Async_16_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:47:43\n   |\n47 |                         if let Stmt::Expr(Expr::Async(expr_async)) = stmt {\n   |                                           ^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n47 |                         if let Stmt::Expr(Expr::Async(expr_async), _) = stmt {\n   |                                                                  +++\n\nerror[E0614]: type `Pat` cannot be dereferenced\n  --> src\\main.rs:50:75\n   |\n50 | ...                   if let Pat::Struct(pat_struct) = &mut *local.pat {\n   |                                                             ^^^^^^^^^^ can't be dereferenced\n\nSome errors have detailed explanations: E0023, E0614.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\enum_destructuring_async_16.rs"
    },
    {
        "mutator_name": "Function_Return_Type_Variation_189",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Function_Return_Type_Variation_189_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0594]: cannot assign to `type_impl_trait.bounds`, which is behind a `&` reference\n  --> src\\main.rs:41:25\n   |\n41 |                         type_impl_trait.bounds = new_bounds;\n   |                         ^^^^^^^^^^^^^^^^^^^^^^ `type_impl_trait` is a `&` reference, so the data it refers to cannot be written\n\nFor more information about this error, try `rustc --explain E0594`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Function_Return_Type_Variation_189_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0282]: type annotations needed for `syn::punctuated::Punctuated<TypeParamBound, _>`\n  --> src\\main.rs:34:29\n   |\n34 |                         let mut new_bounds = Punctuated::new();\n   |                             ^^^^^^^^^^^^^^   ----------------- type must be known at this point\n   |\nhelp: consider giving `new_bounds` an explicit type, where the type for type parameter `P` is specified\n   |\n34 |                         let mut new_bounds: syn::punctuated::Punctuated<_, P> = Punctuated::new();\n   |                                           +++++++++++++++++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Function_Return_Type_Variation_189_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.86s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:37:67:\nexpected identifier, found keyword `impl`\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Function_Return_Type_Variation_189_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.64s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:37:67:\nexpected identifier, found keyword `dyn`\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\function_return_type_variation_189.rs"
    },
    {
        "mutator_name": "Invalid_Method_Call_On_Non_Adt_21",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Invalid_Method_Call_On_Non_Adt_21_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:35:37\n   |\n35 |                         if let Some((_, ref mut expr)) = local.init {\n   |                                     ^^^^^^^^^^^^^^^^^    ---------- this expression has type `Option<LocalInit>`\n   |                                     |\n   |                                     expected `LocalInit`, found `(_, _)`\n   |\n   = note: expected struct `LocalInit`\n               found tuple `(_, _)`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Invalid_Method_Call_On_Non_Adt_21_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:32:29\n   |\n32 |             if let Item::Fn(ref mut func) = item {\n   |                             ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:32:20\n   |\n32 |             if let Item::Fn(ref mut func) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n32 -             if let Item::Fn(ref mut func) = item {\n32 +             if let Item::Fn(func) = item {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:34:40\n   |\n34 |                     if let Stmt::Local(ref mut local) = stmt {\n   |                                        ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:34:28\n   |\n34 |                     if let Stmt::Local(ref mut local) = stmt {\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n34 -                     if let Stmt::Local(ref mut local) = stmt {\n34 +                     if let Stmt::Local(local) = stmt {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Invalid_Method_Call_On_Non_Adt_21_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:17:58\n   |\n17 | ...                   let invalid_call: Expr = parse_quote! {\n   |                                                ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `quote` in this scope\n  --> src\\main.rs:20:63\n   |\n20 | ...                   let new_expr = Expr::Verbatim(quote! { #expr #invalid_call });\n   |                                                     ^^^^^\n   |\n   = note: `quote` is in scope, but it is a crate, not a macro\nhelp: consider importing this macro\n   |\n1  + use quote::quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:12:20\n   |\n12 |             if let Item::Fn(func) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:14:28\n   |\n14 |                     if let Stmt::Local(local) = stmt {\n   |                            ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `LocalInit` in this scope\n  --> src\\main.rs:15:37\n   |\n15 |                         if let Some(LocalInit { ref mut expr, .. }) = local.init {\n   |                                     ^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::LocalInit;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:16:36\n   |\n16 | ...                   if let Expr::Array(_) | Expr::Tuple(_) = **expr {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:16:53\n   |\n16 | ...                   if let Expr::Array(_) | Expr::Tuple(_) = **expr {\n   |                                               ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0412]: cannot find type `Expr` in this scope\n  --> src\\main.rs:17:51\n   |\n17 | ...                   let invalid_call: Expr = parse_quote! {\n   |                                         ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:20:48\n   |\n20 | ...                   let new_expr = Expr::Verbatim(quote! { #expr #invalid_call });\n   |                                      ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nSome errors have detailed explanations: E0412, E0422, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 9 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Invalid_Method_Call_On_Non_Adt_21_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:6:6\n  |\n6 | impl Mutator for Invalid_Method_Call_On_Non_Adt_21 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Invalid_Method_Call_On_Non_Adt_21_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.84s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:19:58:\nexpected an expression\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\invalid_method_call_on_non_adt_21.rs"
    },
    {
        "mutator_name": "Modify_Array_Size_In_Struct_Definition_47",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Array_Size_In_Struct_Definition_47_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:35:59\n   |\n35 |                         if let Expr::Lit(expr_lit) = &mut *type_array.len {\n   |                                                           ^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:42:54\n   |\n42 | ...                   type_array.len = Box::new(new_expr);\n   |                       --------------   ^^^^^^^^^^^^^^^^^^ expected `Expr`, found `Box<Expr>`\n   |                       |\n   |                       expected due to the type of this binding\n   |\n   = note: expected enum `syn::Expr`\n            found struct `std::boxed::Box<syn::Expr>`\nhelp: consider unboxing the value\n   |\n42 |                                     type_array.len = *Box::new(new_expr);\n   |                                                      +\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Array_Size_In_Struct_Definition_47_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:42:37\n   |\n42 | ...                   *type_array.len = new_expr;\n   |                       ^^^^^^^^^^^^^^^ can't be dereferenced\n\nFor more information about this error, try `rustc --explain E0614`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Array_Size_In_Struct_Definition_47_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:35:59\n   |\n35 |                         if let Expr::Lit(expr_lit) = &mut *type_array.len {\n   |                                                           ^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:42:37\n   |\n42 | ...                   *type_array.len = Box::new(new_expr);\n   |                       ^^^^^^^^^^^^^^^ can't be dereferenced\n\nFor more information about this error, try `rustc --explain E0614`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Array_Size_In_Struct_Definition_47_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:42:54\n   |\n42 | ...                   type_array.len = Box::new(new_expr);\n   |                       --------------   ^^^^^^^^^^^^^^^^^^ expected `Expr`, found `Box<Expr>`\n   |                       |\n   |                       expected due to the type of this binding\n   |\n   = note: expected enum `syn::Expr`\n            found struct `std::boxed::Box<syn::Expr>`\nhelp: consider unboxing the value\n   |\n42 |                                     type_array.len = *Box::new(new_expr);\n   |                                                      +\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_array_size_in_struct_definition_47.rs"
    },
    {
        "mutator_name": "Modify_Closure_Capture_And_Type_Context_14",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Closure_Capture_And_Type_Context_14_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0658]: box pattern syntax is experimental\n  --> src\\main.rs:35:41\n   |\n35 |                         if let Some((_, box Expr::Closure(closure))) = &local.init {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: see issue #29641 <https://github.com/rust-lang/rust/issues/29641> for more information\n   = help: add `#![feature(box_patterns)]` to the crate attributes to enable\n   = note: this compiler was built on 2025-05-16; consider upgrading it if it is out of date\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:35:37\n   |\n35 |                         if let Some((_, box Expr::Closure(closure))) = &local.init {\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    ----------- this expression has type `&Option<LocalInit>`\n   |                                     |\n   |                                     expected `LocalInit`, found `(_, _)`\n   |\n   = note: expected struct `LocalInit`\n               found tuple `(_, _)`\n\nerror[E0609]: no field `stmts` on type `std::boxed::Box<syn::Expr>`\n  --> src\\main.rs:45:42\n   |\n45 | ...                   closure.body.stmts.push(new_capture);\n   |                                    ^^^^^ unknown field\n\nSome errors have detailed explanations: E0308, E0609, E0658.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Closure_Capture_And_Type_Context_14_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:35:37\n   |\n35 |                         if let Some((_, init_expr)) = &local.init {\n   |                                     ^^^^^^^^^^^^^^    ----------- this expression has type `&Option<LocalInit>`\n   |                                     |\n   |                                     expected `LocalInit`, found `(_, _)`\n   |\n   = note: expected struct `LocalInit`\n               found tuple `(_, _)`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Closure_Capture_And_Type_Context_14_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0499]: cannot borrow `item_fn.block.stmts` as mutable more than once at a time\n  --> src\\main.rs:43:33\n   |\n33 |                 for stmt in &mut item_fn.block.stmts {\n   |                             ------------------------ first mutable borrow occurs here\n...\n43 |                                 item_fn.block.stmts.insert(0, new_var_stmt);\n   |                                 ^^^^^^^^^^^^^^^^^^^ second mutable borrow occurs here\n...\n46 |                                 if let Expr::Block(ref mut block) = *closure.body {\n   |                                                                     ------------- first borrow later used here\n\nerror[E0596]: cannot borrow `closure.body.0` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:46:52\n   |\n46 | ...                   if let Expr::Block(ref mut block) = *closure.body {\n   |                                          ^^^^^^^^^^^^^ `closure` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nSome errors have detailed explanations: E0499, E0596.\nFor more information about an error, try `rustc --explain E0499`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Closure_Capture_And_Type_Context_14_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:21:58\n   |\n21 | ...                   let new_var_type: Type = parse_quote!(bool);\n   |                                                ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:22:58\n   |\n22 | ...                   let new_var_expr: Expr = parse_quote!(true);\n   |                                                ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:24:53\n   |\n24 | ...                   new_var_stmt = Some(parse_quote!(let #new_var_ident: #new_var_type = #new_var_expr;));\n   |                                           ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:26:52\n   |\n26 | ...                   new_capture = Some(parse_quote!(if #new_var_ident { println!(\"Boolean captured!\"); }));\n   |                                          ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:29:60\n   |\n29 | ...                   block.block.stmts.push(parse_quote!(#new_capture));\n   |                                              ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Fn(item_fn) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:16:28\n   |\n16 |                     if let Stmt::Local(local) = stmt {\n   |                            ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `LocalInit` in this scope\n  --> src\\main.rs:17:37\n   |\n17 |                         if let Some(LocalInit { expr: init_expr, .. }) = &local.init {\n   |                                     ^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::LocalInit;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:18:36\n   |\n18 | ...                   if let Expr::Closure(closure) = &**init_expr {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:20:53\n   |\n20 | ...                   let new_var_ident = Ident::new(\"y\", Span::call_site());\n   |                                           ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:20:69\n   |\n20 | ...                   let new_var_ident = Ident::new(\"y\", Span::call_site());\n   |                                                           ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0412]: cannot find type `Type` in this scope\n  --> src\\main.rs:21:51\n   |\n21 | ...                   let new_var_type: Type = parse_quote!(bool);\n   |                                         ^^^^ not found in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0412]: cannot find type `Expr` in this scope\n  --> src\\main.rs:22:51\n   |\n22 | ...                   let new_var_expr: Expr = parse_quote!(true);\n   |                                         ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:28:40\n   |\n28 | ...                   if let Expr::Block(ref mut block) = *closure.body.clone() {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nSome errors have detailed explanations: E0412, E0422, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 14 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Closure_Capture_And_Type_Context_14_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:6:6\n  |\n6 | impl Mutator for Modify_Closure_Capture_And_Type_Context_14 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_closure_capture_and_type_context_14.rs"
    },
    {
        "mutator_name": "Modify_Const_Generic_Default_Values_154",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Default_Values_154_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: the method `as_ref` exists for reference `&syn::Expr`, but its trait bounds were not satisfied\n   --> src\\main.rs:35:80\n    |\n35  |   ...                   if let Expr::Path(ExprPath { path, .. }) = default.as_ref() {\n    |                                                                            ^^^^^^ method cannot be called on `&syn::Expr` due to unsatisfied trait bounds\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\expr.rs:35:1\n    |\n35  | / ast_enum_of_structs! {\n36  | |     /// A Rust expression.\n37  | |     ///\n38  | |     /// *This type is available only if Syn is built with the `\"derive\"` or `\"full\"`\n...   |\n267 | | }\n    | |_- doesn't satisfy `syn::Expr: AsRef<_>`\n    |\n    = note: the following trait bounds were not satisfied:\n            `syn::Expr: AsRef<_>`\n            which is required by `&syn::Expr: AsRef<_>`\n\nerror[E0308]: mismatched types\n   --> src\\main.rs:37:60\n    |\n37  | ...                   const_param.default = Some(Box::new(new_expr));\n    |                                             ---- ^^^^^^^^^^^^^^^^^^ expected `Expr`, found `Box<Expr>`\n    |                                             |\n    |                                             arguments to this enum variant are incorrect\n    |\n    = note: expected enum `syn::Expr`\n             found struct `std::boxed::Box<syn::Expr>`\nhelp: the type constructed contains `std::boxed::Box<syn::Expr>` due to the type of the argument passed\n   --> src\\main.rs:37:55\n    |\n37  | ...                   const_param.default = Some(Box::new(new_expr));\n    |                                             ^^^^^------------------^\n    |                                                  |\n    |                                                  this argument influences the type of `Some`\nnote: tuple variant defined here\n   --> C:\\Users\\love\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\option.rs:597:5\n    |\n597 |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    |     ^^^^\nhelp: consider unboxing the value\n    |\n37  |                                 const_param.default = Some(*Box::new(new_expr));\n    |                                                            +\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Default_Values_154_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:35:72\n   |\n35 | ...                   if let Expr::Path(ExprPath { path, .. }) = **default {\n   |                                                                  ^^^^^^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n   --> src\\main.rs:37:60\n    |\n37  | ...                   const_param.default = Some(Box::new(new_expr));\n    |                                             ---- ^^^^^^^^^^^^^^^^^^ expected `Expr`, found `Box<Expr>`\n    |                                             |\n    |                                             arguments to this enum variant are incorrect\n    |\n    = note: expected enum `syn::Expr`\n             found struct `std::boxed::Box<syn::Expr>`\nhelp: the type constructed contains `std::boxed::Box<syn::Expr>` due to the type of the argument passed\n   --> src\\main.rs:37:55\n    |\n37  | ...                   const_param.default = Some(Box::new(new_expr));\n    |                                             ^^^^^------------------^\n    |                                                  |\n    |                                                  this argument influences the type of `Some`\nnote: tuple variant defined here\n   --> C:\\Users\\love\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\option.rs:597:5\n    |\n597 |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    |     ^^^^\nhelp: consider unboxing the value\n    |\n37  |                                 const_param.default = Some(*Box::new(new_expr));\n    |                                                            +\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Default_Values_154_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: the method `as_ref` exists for reference `&syn::Expr`, but its trait bounds were not satisfied\n   --> src\\main.rs:35:80\n    |\n35  |   ...                   if let Expr::Path(ExprPath { path, .. }) = default.as_ref() {\n    |                                                                            ^^^^^^ method cannot be called on `&syn::Expr` due to unsatisfied trait bounds\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\expr.rs:35:1\n    |\n35  | / ast_enum_of_structs! {\n36  | |     /// A Rust expression.\n37  | |     ///\n38  | |     /// *This type is available only if Syn is built with the `\"derive\"` or `\"full\"`\n...   |\n267 | | }\n    | |_- doesn't satisfy `syn::Expr: AsRef<_>`\n    |\n    = note: the following trait bounds were not satisfied:\n            `syn::Expr: AsRef<_>`\n            which is required by `&syn::Expr: AsRef<_>`\n\nerror[E0308]: mismatched types\n   --> src\\main.rs:37:60\n    |\n37  | ...                   const_param.default = Some(Box::new(new_expr));\n    |                                             ---- ^^^^^^^^^^^^^^^^^^ expected `Expr`, found `Box<Expr>`\n    |                                             |\n    |                                             arguments to this enum variant are incorrect\n    |\n    = note: expected enum `syn::Expr`\n             found struct `std::boxed::Box<syn::Expr>`\nhelp: the type constructed contains `std::boxed::Box<syn::Expr>` due to the type of the argument passed\n   --> src\\main.rs:37:55\n    |\n37  | ...                   const_param.default = Some(Box::new(new_expr));\n    |                                             ^^^^^------------------^\n    |                                                  |\n    |                                                  this argument influences the type of `Some`\nnote: tuple variant defined here\n   --> C:\\Users\\love\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\option.rs:597:5\n    |\n597 |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    |     ^^^^\nhelp: consider unboxing the value\n    |\n37  |                                 const_param.default = Some(*Box::new(new_expr));\n    |                                                            +\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_const_generic_default_values_154.rs"
    },
    {
        "mutator_name": "Modify_Const_Generic_Params_55",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Params_55_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:44:73\n   |\n44 | ...                   if let GenericArgument::Const(Expr::Lit(ref mut lit)) = arg {\n   |                                                               ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:44:40\n   |\n44 | ...                   if let GenericArgument::Const(Expr::Lit(ref mut lit)) = arg {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n44 -                                 if let GenericArgument::Const(Expr::Lit(ref mut lit)) = arg {\n44 +                                 if let GenericArgument::Const(Expr::Lit(lit)) = arg {\n   |\n\nerror[E0596]: cannot borrow `segment.arguments.0` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:42:62\n   |\n41 |                     if let Some(segment) = path.segments.last() {\n   |                                 ------- consider changing this binding's type to be: `&mut PathSegment`\n42 |                         if let PathArguments::AngleBracketed(ref mut args) = segment.arguments {\n   |                                                              ^^^^^^^^^^^^ `segment` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Params_55_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `path.segments` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:41:44\n   |\n41 |                     if let Some(segment) = path.segments.last_mut() {\n   |                                            ^^^^^^^^^^^^^ `path` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Params_55_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `segment.arguments.0` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:42:62\n   |\n41 |                     if let Some(segment) = path.segments.last() {\n   |                                 ------- consider changing this binding's type to be: `&mut PathSegment`\n42 |                         if let PathArguments::AngleBracketed(ref mut args) = segment.arguments {\n   |                                                              ^^^^^^^^^^^^ `segment` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Params_55_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `path.segments` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:41:44\n   |\n41 |                     if let Some(segment) = path.segments.last_mut() {\n   |                                            ^^^^^^^^^^^^^ `path` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Params_55_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `segment.arguments.0` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:42:62\n   |\n41 |                     if let Some(segment) = path.segments.last() {\n   |                                 ------- consider changing this binding's type to be: `&mut PathSegment`\n42 |                         if let PathArguments::AngleBracketed(ref mut args) = segment.arguments {\n   |                                                              ^^^^^^^^^^^^ `segment` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Params_55_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `path.segments` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:41:44\n   |\n41 |                     if let Some(segment) = path.segments.last_mut() {\n   |                                            ^^^^^^^^^^^^^ `path` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_const_generic_params_55.rs"
    },
    {
        "mutator_name": "Modify_Struct_Const_Invalid_Default_176",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Struct_Const_Invalid_Default_176_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `Option<syn::Expr>` cannot be dereferenced\n  --> src\\main.rs:36:29\n   |\n36 | ...                   *const_param.default = Some(invalid_expr);\n   |                       ^^^^^^^^^^^^^^^^^^^^ can't be dereferenced\n\nFor more information about this error, try `rustc --explain E0614`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Struct_Const_Invalid_Default_176_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:15:54\n   |\n15 | ...                   let invalid_expr: Expr = parse_quote! { \"invalid\" };\n   |                                                ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Struct(ItemStruct { generics, .. }) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `ItemStruct` in this scope\n  --> src\\main.rs:11:33\n   |\n11 |             if let Item::Struct(ItemStruct { generics, .. }) = item {\n   |                                 ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::ItemStruct;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericParam`\n  --> src\\main.rs:13:28\n   |\n13 |                     if let GenericParam::Const(const_param) = param {\n   |                            ^^^^^^^^^^^^ use of undeclared type `GenericParam`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nerror[E0412]: cannot find type `Expr` in this scope\n  --> src\\main.rs:15:47\n   |\n15 | ...                   let invalid_expr: Expr = parse_quote! { \"invalid\" };\n   |                                         ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nSome errors have detailed explanations: E0412, E0422, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 5 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Struct_Const_Invalid_Default_176_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Modify_Struct_Const_Invalid_Default_176 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_struct_const_invalid_default_176.rs"
    },
    {
        "mutator_name": "Modify_Struct_Field_To_Tuple_36",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_struct_field_to_tuple_36.rs"
    },
    {
        "mutator_name": "Modify_Struct_Implementation_221",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Struct_Implementation_221_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `is_some` found for enum `PathArguments` in the current scope\n  --> src\\main.rs:33:64\n   |\n33 |                     if segments.iter().any(|seg| seg.arguments.is_some()) {\n   |                                                                ^^^^^^^\n   |\nhelp: there is a method `is_none` with a similar name\n   |\n33 -                     if segments.iter().any(|seg| seg.arguments.is_some()) {\n33 +                     if segments.iter().any(|seg| seg.arguments.is_none()) {\n   |\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_struct_implementation_221.rs"
    },
    {
        "mutator_name": "Modify_Struct_With_Generic_Const_Parameters_62",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Struct_With_Generic_Const_Parameters_62_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:32:24\n   |\n32 |                 if let Some((_, generics, _)) = &item_struct.generics.split_for_impl() {\n   |                        ^^^^^^^^^^^^^^^^^^^^^^   -------------------------------------- this expression has type `&(ImplGenerics<'_>, TypeGenerics<'_>, Option<&WhereClause>)`\n   |                        |\n   |                        expected `(ImplGenerics<'_>, ..., ...)`, found `Option<_>`\n   |\n   = note: expected tuple `(ImplGenerics<'_>, TypeGenerics<'_>, Option<&WhereClause>)`\n               found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:34:32\n   |\n34 |                         if let Some(Type::Path(TypePath { path, .. })) = &const_param.ty {\n   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   --------------- this expression has type `&syn::Type`\n   |                                |\n   |                                expected `Type`, found `Option<_>`\n   |\n   = note: expected enum `syn::Type`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:38:50\n   |\n38 | ...                   const_param.ty = Box::new(new_type);\n   |                       --------------   ^^^^^^^^^^^^^^^^^^ expected `Type`, found `Box<_>`\n   |                       |\n   |                       expected due to the type of this binding\n   |\n   = note: expected enum `syn::Type`\n            found struct `std::boxed::Box<_>`\nhelp: consider unboxing the value\n   |\n38 |                                 const_param.ty = *Box::new(new_type);\n   |                                                  +\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Struct_With_Generic_Const_Parameters_62_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:17:50\n   |\n17 | ...                   let new_type: Type = parse_quote! { SomeType<'static> };\n   |                                            ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Struct(item_struct) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericParam`\n  --> src\\main.rs:13:117\n   |\n13 | ...arams.iter().find(|param| matches!(param, GenericParam::Const(_))) {\n   |                                              ^^^^^^^^^^^^ use of undeclared type `GenericParam`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericParam`\n  --> src\\main.rs:13:29\n   |\n13 | ...   if let Some(GenericParam::Const(const_param)) = generics.params.iter().find(|param| matches!(param, GenericParam::Const(_))) {\n   |                   ^^^^^^^^^^^^ use of undeclared type `GenericParam`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:14:28\n   |\n14 |                     if let Type::Path(TypePath { path, .. }) = &*const_param.ty {\n   |                            ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypePath` in this scope\n  --> src\\main.rs:14:39\n   |\n14 |                     if let Type::Path(TypePath { path, .. }) = &*const_param.ty {\n   |                                       ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypePath;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Lifetime`\n  --> src\\main.rs:16:48\n   |\n16 | ...                   let new_lifetime = Lifetime::new(\"'static\", Span::call_site());\n   |                                          ^^^^^^^^ use of undeclared type `Lifetime`\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::Lifetime;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:16:73\n   |\n16 | ...                   let new_lifetime = Lifetime::new(\"'static\", Span::call_site());\n   |                                                                   ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0412]: cannot find type `Type` in this scope\n  --> src\\main.rs:17:43\n   |\n17 | ...                   let new_type: Type = parse_quote! { SomeType<'static> };\n   |                                     ^^^^ not found in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nSome errors have detailed explanations: E0412, E0422, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 9 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Struct_With_Generic_Const_Parameters_62_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:6:6\n  |\n6 | impl Mutator for Modify_Struct_With_Generic_Const_Parameters_62 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Struct_With_Generic_Const_Parameters_62_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:16:65\n   |\n16 |                     if let Type::Path(TypePath { path, .. }) = &*const_param.ty {\n   |                                                                 ^^^^^^^^^^^^^^^ can't be dereferenced\n\nFor more information about this error, try `rustc --explain E0614`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Struct_With_Generic_Const_Parameters_62_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0594]: cannot assign to `const_param.ty`, which is behind a `&` reference\n  --> src\\main.rs:20:29\n   |\n20 | ...                   const_param.ty = new_type;\n   |                       ^^^^^^^^^^^^^^ `const_param` is a `&` reference, so the data it refers to cannot be written\n\nFor more information about this error, try `rustc --explain E0594`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_struct_with_generic_const_parameters_62.rs"
    },
    {
        "mutator_name": "Modify_Trait_Alias_In_Const_Generics_64",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Alias_In_Const_Generics_64_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: the method `as_ref` exists for reference `&syn::Expr`, but its trait bounds were not satisfied\n   --> src\\main.rs:35:72\n    |\n35  |   ...                   if let Expr::Binary(expr_binary) = default.as_ref() {\n    |                                                                    ^^^^^^ method cannot be called on `&syn::Expr` due to unsatisfied trait bounds\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\expr.rs:35:1\n    |\n35  | / ast_enum_of_structs! {\n36  | |     /// A Rust expression.\n37  | |     ///\n38  | |     /// *This type is available only if Syn is built with the `\"derive\"` or `\"full\"`\n...   |\n267 | | }\n    | |_- doesn't satisfy `syn::Expr: AsRef<_>`\n    |\n    = note: the following trait bounds were not satisfied:\n            `syn::Expr: AsRef<_>`\n            which is required by `&syn::Expr: AsRef<_>`\n\nerror[E0614]: type `ExprBinary` cannot be dereferenced\n  --> src\\main.rs:37:33\n   |\n37 | ...                   *expr_binary = new_expr;\n   |                       ^^^^^^^^^^^^ can't be dereferenced\n\nSome errors have detailed explanations: E0599, E0614.\nFor more information about an error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Alias_In_Const_Generics_64_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0594]: cannot assign to `*default`, which is behind a `&` reference\n  --> src\\main.rs:36:29\n   |\n36 | ...                   *default = new_expr;\n   |                       ^^^^^^^^ `default` is a `&` reference, so the data it refers to cannot be written\n\nFor more information about this error, try `rustc --explain E0594`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Alias_In_Const_Generics_64_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:15:50\n   |\n15 | ...                   let new_expr: Expr = parse_quote! { 6 / 2 };\n   |                                            ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::TraitAlias(trait_alias) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericParam`\n  --> src\\main.rs:12:29\n   |\n12 |                 if let Some(GenericParam::Const(const_param)) = trait_alias.generics.params.first_mut() {\n   |                             ^^^^^^^^^^^^ use of undeclared type `GenericParam`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:14:32\n   |\n14 |                         if let Expr::Binary(_) = default.as_mut() {\n   |                                ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0412]: cannot find type `Expr` in this scope\n  --> src\\main.rs:15:43\n   |\n15 | ...                   let new_expr: Expr = parse_quote! { 6 / 2 };\n   |                                     ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 5 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Alias_In_Const_Generics_64_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Modify_Trait_Alias_In_Const_Generics_64 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Alias_In_Const_Generics_64_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: the method `as_mut` exists for mutable reference `&mut Expr`, but its trait bounds were not satisfied\n   --> src\\main.rs:15:58\n    |\n15  |                           if let Expr::Binary(_) = default.as_mut() {\n    |                                                            ^^^^^^ method cannot be called on `&mut Expr` due to unsatisfied trait bounds\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\expr.rs:35:1\n    |\n35  | / ast_enum_of_structs! {\n36  | |     /// A Rust expression.\n37  | |     ///\n38  | |     /// *This type is available only if Syn is built with the `\"derive\"` or `\"full\"`\n...   |\n267 | | }\n    | |_- doesn't satisfy `syn::Expr: AsMut<_>`\n    |\n    = note: the following trait bounds were not satisfied:\n            `syn::Expr: AsMut<_>`\n            which is required by `&mut syn::Expr: AsMut<_>`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_trait_alias_in_const_generics_64.rs"
    },
    {
        "mutator_name": "Modify_Trait_Associated_Type_With_Lifetime_Constraints_246",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Associated_Type_With_Lifetime_Constraints_246_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:32:32\n   |\n32 |             if let Item::Trait(ref mut trait_item) = item {\n   |                                ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:32:20\n   |\n32 |             if let Item::Trait(ref mut trait_item) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n32 -             if let Item::Trait(ref mut trait_item) = item {\n32 +             if let Item::Trait(trait_item) = item {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:34:49\n   |\n34 |                     if let syn::TraitItem::Type(ref mut type_item) = item {\n   |                                                 ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:34:28\n   |\n34 |                     if let syn::TraitItem::Type(ref mut type_item) = item {\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n34 -                     if let syn::TraitItem::Type(ref mut type_item) = item {\n34 +                     if let syn::TraitItem::Type(type_item) = item {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Associated_Type_With_Lifetime_Constraints_246_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:16:63\n   |\n16 | ...                   let new_lifetime: LifetimeParam = parse_quote!('newlt);\n   |                                                         ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:21:41\n   |\n21 | ...                   bounds.push(parse_quote!(Iterator));\n   |                                   ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:12:20\n   |\n12 |             if let Item::Trait(trait_item) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0412]: cannot find type `LifetimeParam` in this scope\n  --> src\\main.rs:16:47\n   |\n16 | ...                   let new_lifetime: LifetimeParam = parse_quote!('newlt);\n   |                                         ^^^^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::LifetimeParam;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericParam`\n  --> src\\main.rs:17:60\n   |\n17 | ...                   type_item.generics.params.push(GenericParam::Lifetime(new_lifetime.clone()));\n   |                                                      ^^^^^^^^^^^^ use of undeclared type `GenericParam`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TypeParamBound`\n  --> src\\main.rs:20:41\n   |\n20 | ...                   bounds.push(TypeParamBound::Lifetime(new_lifetime.lifetime.clone()));\n   |                                   ^^^^^^^^^^^^^^ use of undeclared type `TypeParamBound`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TypeParamBound;\n   |\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 6 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Associated_Type_With_Lifetime_Constraints_246_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Modify_Trait_Associated_Type_With_Lifetime_Constraints_246 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Associated_Type_With_Lifetime_Constraints_246_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:16:63\n   |\n16 | ...                   let new_lifetime: LifetimeParam = parse_quote!('newlt);\n   |                                                         ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:21:41\n   |\n21 | ...                   bounds.push(parse_quote!(Iterator));\n   |                                   ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:12:20\n   |\n12 |             if let Item::Trait(trait_item) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0412]: cannot find type `LifetimeParam` in this scope\n  --> src\\main.rs:16:47\n   |\n16 | ...                   let new_lifetime: LifetimeParam = parse_quote!('newlt);\n   |                                         ^^^^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::LifetimeParam;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericParam`\n  --> src\\main.rs:17:60\n   |\n17 | ...                   type_item.generics.params.push(GenericParam::Lifetime(new_lifetime.clone()));\n   |                                                      ^^^^^^^^^^^^ use of undeclared type `GenericParam`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TypeParamBound`\n  --> src\\main.rs:20:41\n   |\n20 | ...                   bounds.push(TypeParamBound::Lifetime(new_lifetime.lifetime.clone()));\n   |                                   ^^^^^^^^^^^^^^ use of undeclared type `TypeParamBound`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TypeParamBound;\n   |\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 6 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Associated_Type_With_Lifetime_Constraints_246_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Modify_Trait_Associated_Type_With_Lifetime_Constraints_246 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Associated_Type_With_Lifetime_Constraints_246_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:16:63\n   |\n16 | ...                   let new_lifetime: LifetimeParam = parse_quote!('newlt);\n   |                                                         ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:21:41\n   |\n21 | ...                   bounds.push(parse_quote!(Iterator));\n   |                                   ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:12:20\n   |\n12 |             if let Item::Trait(trait_item) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0412]: cannot find type `LifetimeParam` in this scope\n  --> src\\main.rs:16:47\n   |\n16 | ...                   let new_lifetime: LifetimeParam = parse_quote!('newlt);\n   |                                         ^^^^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::LifetimeParam;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericParam`\n  --> src\\main.rs:17:60\n   |\n17 | ...                   type_item.generics.params.push(GenericParam::Lifetime(new_lifetime.clone()));\n   |                                                      ^^^^^^^^^^^^ use of undeclared type `GenericParam`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TypeParamBound`\n  --> src\\main.rs:20:41\n   |\n20 | ...                   bounds.push(TypeParamBound::Lifetime(new_lifetime.lifetime.clone()));\n   |                                   ^^^^^^^^^^^^^^ use of undeclared type `TypeParamBound`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TypeParamBound;\n   |\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 6 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Associated_Type_With_Lifetime_Constraints_246_compling_err_7.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Modify_Trait_Associated_Type_With_Lifetime_Constraints_246 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_associated_type_with_lifetime_constraints_246.rs"
    },
    {
        "mutator_name": "Modify_Trait_Async_Function_Signature_230",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Async_Function_Signature_230_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `syn::TraitItem` in the current scope\n  --> src\\main.rs:34:39\n   |\n34 |                     if let TraitItem::Method(method) = item {\n   |                                       ^^^^^^ variant or associated item not found in `TraitItem`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Async_Function_Signature_230_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0432]: unresolved import `syn::TraitItemMethod`\n --> src\\main.rs:1:33\n  |\n1 | use syn::{ItemTrait, TraitItem, TraitItemMethod};\n  |                                 ^^^^^^^^^^^^^^^\n  |                                 |\n  |                                 no `TraitItemMethod` in the root\n  |                                 help: a similar name exists in the module: `TraitItemMacro`\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:17:48\n   |\n17 | ...                   *ty = Box::new(parse_quote! { impl Future<Output = #ty> });\n   |                                      ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Modify_Trait_Async_Function_Signature_230 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:12:20\n   |\n12 |             if let Item::Trait(trait_item) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `ReturnType`\n  --> src\\main.rs:16:36\n   |\n16 | ...                   if let ReturnType::Type(_, ref mut ty) = method.sig.output {\n   |                              ^^^^^^^^^^ use of undeclared type `ReturnType`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::ReturnType;\n   |\n\nSome errors have detailed explanations: E0405, E0432, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 5 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Async_Function_Signature_230_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `TraitItem` in the current scope\n  --> src\\main.rs:15:39\n   |\n15 |                     if let TraitItem::Method(method) = item {\n   |                                       ^^^^^^ variant or associated item not found in `TraitItem`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Async_Function_Signature_230_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0432]: unresolved import `syn::TraitItemMethod`\n --> src\\main.rs:1:64\n  |\n1 | use syn::{ItemTrait, TraitItem, Item, ReturnType, parse_quote, TraitItemMethod};\n  |                                                                ^^^^^^^^^^^^^^^\n  |                                                                |\n  |                                                                no `TraitItemMethod` in the root\n  |                                                                help: a similar name exists in the module: `TraitItemMacro`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `TraitItem` in the current scope\n  --> src\\main.rs:15:39\n   |\n15 |                     if let TraitItem::Method(method) = item {\n   |                                       ^^^^^^ variant or associated item not found in `TraitItem`\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_async_function_signature_230.rs"
    },
    {
        "mutator_name": "Modify_Trait_Bounds_103",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [],
        "label": "Negative",
        "file": ".\\mutators\\modify_trait_bounds_103.rs"
    },
    {
        "mutator_name": "Modify_Trait_Bounds_49",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_bounds_49.rs"
    },
    {
        "mutator_name": "Modify_Trait_Bounds_54",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bounds_54_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0422]: cannot find struct, variant or union type `ImplItemMethod` in crate `syn`\n   --> src\\main.rs:43:73\n    |\n43  |   ...                   let new_method = syn::ImplItem::Method(syn::ImplItemMethod {\n    |                                                                     ^^^^^^^^^^^^^^ help: a struct with a similar name exists: `ImplItemMacro`\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\item.rs:780:1\n    |\n780 | / ast_struct! {\n781 | |     /// A macro invocation within an impl block.\n782 | |     #[cfg_attr(docsrs, doc(cfg(feature = \"full\")))]\n783 | |     pub struct ImplItemMacro {\n...   |\n788 | | }\n    | |_- similarly named struct `ImplItemMacro` defined here\n\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:34:43\n   |\n34 |                     if let syn::ImplItem::Method(method) = item {\n   |                                           ^^^^^^ variant or associated item not found in `ImplItem`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:43:61\n   |\n43 | ...                   let new_method = syn::ImplItem::Method(syn::ImplItemMethod {\n   |                                                       ^^^^^^ variant or associated item not found in `ImplItem`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:60:65\n   |\n60 | ...                   item_impl.items.push(syn::ImplItem::Method(new_method));\n   |                                                           ^^^^^^ variant or associated item not found in `ImplItem`\n\nSome errors have detailed explanations: E0422, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bounds_54_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n   --> src\\main.rs:60:68\n    |\n60  | ...                   item_impl.items.push(syn::ImplItem::Fn(new_method));\n    |                                            ----------------- ^^^^^^^^^^ expected `ImplItemFn`, found `ImplItem`\n    |                                            |\n    |                                            arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\item.rs:703:9\n    |\n703 |         Fn(ImplItemFn),\n    |         ^^\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bounds_54_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n   --> src\\main.rs:61:62\n    |\n61  | ...                   new_items.push(syn::ImplItem::Fn(new_method));\n    |                                      ----------------- ^^^^^^^^^^ expected `ImplItemFn`, found `ImplItem`\n    |                                      |\n    |                                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\item.rs:703:9\n    |\n703 |         Fn(ImplItemFn),\n    |         ^^\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bounds_54_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n   --> src\\main.rs:61:62\n    |\n61  | ...                   new_items.push(syn::ImplItem::Fn(new_method));\n    |                                      ----------------- ^^^^^^^^^^ expected `ImplItemFn`, found `ImplItem`\n    |                                      |\n    |                                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\item.rs:703:9\n    |\n703 |         Fn(ImplItemFn),\n    |         ^^\n\nerror[E0631]: type mismatch in function arguments\n   --> src\\main.rs:65:66\n    |\n65  |                 item_impl.items.extend(new_items.into_iter().map(syn::ImplItem::Fn));\n    |                                                              --- ^^^^^^^^^^^^^^^^^\n    |                                                              |   |\n    |                                                              |   expected due to this\n    |                                                              |   found signature defined here\n    |                                                              required by a bound introduced by this call\n    |\n    = note: expected function signature `fn(ImplItem) -> _`\n               found function signature `fn(ImplItemFn) -> _`\nnote: required by a bound in `std::iter::Iterator::map`\n   --> C:\\Users\\love\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\iter\\traits\\iterator.rs:749:12\n    |\n746 |     fn map<B, F>(self, f: F) -> Map<Self, F>\n    |        --- required by a bound in this associated function\n...\n749 |         F: FnMut(Self::Item) -> B,\n    |            ^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Iterator::map`\nhelp: consider wrapping the function in a closure\n    |\n65  |                 item_impl.items.extend(new_items.into_iter().map(|arg0: ImplItem| syn::ImplItem::Fn(/* ImplItemFn */)));\n    |                                                                  ++++++++++++++++                  ++++++++++++++++++\n\nerror[E0631]: type mismatch in function arguments\n   --> src\\main.rs:65:40\n    |\n65  |                 item_impl.items.extend(new_items.into_iter().map(syn::ImplItem::Fn));\n    |                                 ------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                                 |      |\n    |                                 |      expected due to this\n    |                                 |      found signature defined here\n    |                                 required by a bound introduced by this call\n    |\n    = note: expected function signature `fn(ImplItem) -> _`\n               found function signature `fn(ImplItemFn) -> _`\n    = note: required for `Map<std::vec::IntoIter<ImplItem>, fn(ImplItemFn) -> ImplItem {syn::ImplItem::Fn}>` to implement `Iterator`\nnote: required by a bound in `extend`\n   --> C:\\Users\\love\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\iter\\traits\\collect.rs:416:31\n    |\n416 |     fn extend<T: IntoIterator<Item = A>>(&mut self, iter: T);\n    |                               ^^^^^^^^ required by this bound in `Extend::extend`\n\nSome errors have detailed explanations: E0308, E0631.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bounds_54_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:17:67\n   |\n17 | ...                   let new_trait_bound: TypeParamBound = parse_quote!(+ AnotherTrait<M>);\n   |                                                             ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:12:20\n   |\n12 |             if let Item::Impl(item_impl) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0412]: cannot find type `TypeParamBound` in this scope\n  --> src\\main.rs:17:50\n   |\n17 | ...                   let new_trait_bound: TypeParamBound = parse_quote!(+ AnotherTrait<M>);\n   |                                            ^^^^^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TypeParamBound;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:29:44\n   |\n29 | ...                   ident: Ident::new(\n   |                              ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nerror[E0308]: mismatched types\n   --> src\\main.rs:41:62\n    |\n41  | ...                   new_items.push(syn::ImplItem::Fn(new_method));\n    |                                      ----------------- ^^^^^^^^^^ expected `ImplItemFn`, found `ImplItem`\n    |                                      |\n    |                                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\item.rs:703:9\n    |\n703 |         Fn(ImplItemFn),\n    |         ^^\n\nerror[E0308]: mismatched types\n   --> src\\main.rs:45:91\n    |\n45  |                 item_impl.items.extend(new_items.into_iter().map(|item| syn::ImplItem::Fn(item)));\n    |                                                                         ----------------- ^^^^ expected `ImplItemFn`, found `ImplItem`\n    |                                                                         |\n    |                                                                         arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\item.rs:703:9\n    |\n703 |         Fn(ImplItemFn),\n    |         ^^\n\nSome errors have detailed explanations: E0308, E0412, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 6 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bounds_54_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:8:6\n  |\n8 | impl Mutator for Modify_Trait_Bounds_54 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_bounds_54.rs"
    },
    {
        "mutator_name": "Modify_Trait_Bound_Expressions_59",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bound_Expressions_59_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0609]: no field `where_clause` on type `&syn::Path`\n  --> src\\main.rs:33:52\n   |\n33 |                     for predicate in &mut generics.where_clause.as_mut().unwrap().predicates {\n   |                                                    ^^^^^^^^^^^^ unknown field\n   |\n   = note: available fields are: `leading_colon`, `segments`\n\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:36:65\n   |\n36 | ...                   if let Expr::Call(expr_call) = &*type_array.len {\n   |                                                       ^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:40:45\n   |\n40 | ...                   *type_array.len = Box::new(new_expr);\n   |                       ^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0599]: no method named `retain` found for struct `syn::punctuated::Punctuated` in the current scope\n  --> src\\main.rs:45:51\n   |\n45 | ...                   predicate_type.bounds.retain(|bound| {\n   |                       ----------------------^^^^^^ method not found in `Punctuated<TypeParamBound, Plus>`\n\nSome errors have detailed explanations: E0599, E0609, E0614.\nFor more information about an error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bound_Expressions_59_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0609]: no field `where_clause` on type `&syn::Path`\n  --> src\\main.rs:33:63\n   |\n33 |                     if let Some(where_clause) = &mut generics.where_clause {\n   |                                                               ^^^^^^^^^^^^ unknown field\n   |\n   = note: available fields are: `leading_colon`, `segments`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:38:48\n   |\n38 | ...                   if let Expr::Path(expr_path) = &expr_call.func {\n   |                              ^^^^^^^^^^^^^^^^^^^^^   --------------- this expression has type `&std::boxed::Box<syn::Expr>`\n   |                              |\n   |                              expected `Box<Expr>`, found `Expr`\n   |\n   = note: expected struct `std::boxed::Box<syn::Expr>`\n                found enum `syn::Expr`\nhelp: consider dereferencing to access the inner value using the Deref trait\n   |\n38 |                                         if let Expr::Path(expr_path) = &*expr_call.func {\n   |                                                                         +\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:41:66\n   |\n41 | ...                   type_array.len = Box::new(new_expr);\n   |                       --------------   ^^^^^^^^^^^^^^^^^^ expected `Expr`, found `Box<Expr>`\n   |                       |\n   |                       expected due to the type of this binding\n   |\n   = note: expected enum `syn::Expr`\n            found struct `std::boxed::Box<syn::Expr>`\nhelp: consider unboxing the value\n   |\n41 |                                                 type_array.len = *Box::new(new_expr);\n   |                                                                  +\n\nSome errors have detailed explanations: E0308, E0609.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bound_Expressions_59_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:37:69\n   |\n37 | ...                   if let Expr::Call(expr_call) = &*type_array.len {\n   |                                                       ^^^^^^^^^^^^^^^ can't be dereferenced\n\nFor more information about this error, try `rustc --explain E0614`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bound_Expressions_59_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:20:70\n   |\n20 | ...                   let new_expr: Expr = parse_quote! { size_of::<T>() + 1 };\n   |                                            ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Impl(item_impl) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:16:40\n   |\n16 | ...                   if let Type::Array(type_array) = &predicate_type.bounded_ty {\n   |                              ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:17:44\n   |\n17 | ...                   if let Expr::Call(expr_call) = &type_array.len {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:18:48\n   |\n18 | ...                   if let Expr::Path(expr_path) = &expr_call.func {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0412]: cannot find type `Expr` in this scope\n  --> src\\main.rs:20:63\n   |\n20 | ...                   let new_expr: Expr = parse_quote! { size_of::<T>() + 1 };\n   |                                     ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TypeParamBound`\n  --> src\\main.rs:27:44\n   |\n27 | ...                   if let TypeParamBound::Trait(trait_bound) = bound {\n   |                              ^^^^^^^^^^^^^^ use of undeclared type `TypeParamBound`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TypeParamBound;\n   |\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 7 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bound_Expressions_59_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Modify_Trait_Bound_Expressions_59 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bound_Expressions_59_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:22:66\n   |\n22 | ...                   type_array.len = Box::new(new_expr);\n   |                       --------------   ^^^^^^^^^^^^^^^^^^ expected `Expr`, found `Box<Expr>`\n   |                       |\n   |                       expected due to the type of this binding\n   |\n   = note: expected enum `syn::Expr`\n            found struct `std::boxed::Box<syn::Expr>`\nhelp: consider unboxing the value\n   |\n22 |                                                 type_array.len = *Box::new(new_expr);\n   |                                                                  +\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bound_Expressions_59_compling_err_7.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0594]: cannot assign to `type_array.len`, which is behind a `&` reference\n  --> src\\main.rs:22:49\n   |\n22 | ...                   type_array.len = new_expr;\n   |                       ^^^^^^^^^^^^^^ `type_array` is a `&` reference, so the data it refers to cannot be written\n\nFor more information about this error, try `rustc --explain E0594`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_bound_expressions_59.rs"
    },
    {
        "mutator_name": "Modify_Trait_Bound_In_Structs_108",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_bound_in_structs_108.rs"
    },
    {
        "mutator_name": "Modify_Trait_Bound_With_Const_Expression_156",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bound_With_Const_Expression_156_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:36:77\n   |\n36 | ...                   if let Expr::Call(ExprCall { func, .. }) = &*type_array.len {\n   |                                                                   ^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:37:81\n   |\n37 | ...                   if let Expr::Path(ExprPath { path, .. }) = &**func {\n   |                                                                   ^^^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:40:62\n   |\n40 | ...                   type_array.len = Box::new(new_expr);\n   |                       --------------   ^^^^^^^^^^^^^^^^^^ expected `Expr`, found `Box<Expr>`\n   |                       |\n   |                       expected due to the type of this binding\n   |\n   = note: expected enum `syn::Expr`\n            found struct `std::boxed::Box<syn::Expr>`\nhelp: consider unboxing the value\n   |\n40 |                                             type_array.len = *Box::new(new_expr);\n   |                                                              +\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_bound_with_const_expression_156.rs"
    },
    {
        "mutator_name": "Modify_Trait_Bound_With_Const_Trait_Implementation_196",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bound_With_Const_Trait_Implementation_196_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `MaybeConst` found for enum `TraitBoundModifier` in the current scope\n  --> src\\main.rs:41:100\n   |\n41 | ...                   if trait_bound.modifier == TraitBoundModifier::MaybeConst {\n   |                                                                      ^^^^^^^^^^ variant or associated item not found in `TraitBoundModifier`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bound_With_Const_Trait_Implementation_196_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `constraint.bounds` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:39:58\n   |\n39 | ...                   for bound in &mut constraint.bounds {\n   |                                    ^^^^^^^^^^^^^^^^^^^^^^ `constraint` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bound_With_Const_Trait_Implementation_196_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0594]: cannot assign to `constraint.bounds`, which is behind a `&` reference\n  --> src\\main.rs:49:45\n   |\n49 | ...                   constraint.bounds = new_bounds;\n   |                       ^^^^^^^^^^^^^^^^^ `constraint` is a `&` reference, so the data it refers to cannot be written\n\nFor more information about this error, try `rustc --explain E0594`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bound_With_Const_Trait_Implementation_196_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `args.args` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:37:48\n   |\n37 | ...                   for arg in &mut args.args {\n   |                                  ^^^^^^^^^^^^^^ `args` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bound_With_Const_Trait_Implementation_196_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `segment.arguments` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:36:78\n   |\n35 | ...                   if let Some(segment) = type_path.path.segments.last() {\n   |                                   ------- consider changing this binding's type to be: `&mut PathSegment`\n36 | ...                       if let PathArguments::AngleBracketed(args) = &mut segment.arguments {\n   |                                                                        ^^^^^^^^^^^^^^^^^^^^^^ `segment` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bound_With_Const_Trait_Implementation_196_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `type_path.path.segments` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:35:52\n   |\n35 | ...                   if let Some(segment) = type_path.path.segments.last_mut() {\n   |                                              ^^^^^^^^^^^^^^^^^^^^^^^ `type_path` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_trait_bound_with_const_trait_implementation_196.rs"
    },
    {
        "mutator_name": "Modify_Trait_Bound_With_Generic_Const_Expressions_164",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bound_With_Generic_Const_Expressions_164_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:40:83\n   |\n40 | ...                   if let Expr::Block(expr_block) = &*type_array.len {\n   |                                                         ^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:42:75\n   |\n42 | ...                   if let Stmt::Expr(Expr::Lit(expr_lit)) = stmt {\n   |                                         ^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n42 |                                                         if let Stmt::Expr(Expr::Lit(expr_lit), _) = stmt {\n   |                                                                                              +++\n\nerror[E0061]: this enum variant takes 2 arguments but 1 argument was supplied\n  --> src\\main.rs:45:73\n   |\n45 | ...                   *stmt = Stmt::Expr(new_expr);\n   |                               ^^^^^^^^^^---------- argument #2 of type `Option<Semi>` is missing\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:9\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |         ^^^^\nhelp: provide the argument\n   |\n45 |                                                                 *stmt = Stmt::Expr(new_expr, /* Option<Semi> */);\n   |                                                                                            ++++++++++++++++++++\n\nSome errors have detailed explanations: E0023, E0061, E0614.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bound_With_Generic_Const_Expressions_164_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0425]: cannot find value `stmt` in this scope\n  --> src\\main.rs:43:58\n   |\n43 | ...                   *stmt = Stmt::Expr(new_expr, None);\n   |                        ^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_trait_bound_with_generic_const_expressions_164.rs"
    },
    {
        "mutator_name": "Modify_Trait_Definition_And_Implementation_125",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Definition_And_Implementation_125_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0412]: cannot find type `TraitItemMethod` in crate `syn`\n   --> src\\main.rs:33:42\n    |\n33  |                   let new_method_sig: syn::TraitItemMethod = parse_quote! {\n    |                                            ^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `TraitItemMacro`\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\item.rs:678:1\n    |\n678 | / ast_struct! {\n679 | |     /// A macro invocation within the definition of a trait.\n680 | |     #[cfg_attr(docsrs, doc(cfg(feature = \"full\")))]\n681 | |     pub struct TraitItemMacro {\n...   |\n686 | | }\n    | |_- similarly named struct `TraitItemMacro` defined here\n\nerror[E0412]: cannot find type `ImplItemMethod` in crate `syn`\n   --> src\\main.rs:43:59\n    |\n43  |   ...                   let new_method_impl: syn::ImplItemMethod = parse_quote! {\n    |                                                   ^^^^^^^^^^^^^^ help: a struct with a similar name exists: `ImplItemMacro`\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\item.rs:780:1\n    |\n780 | / ast_struct! {\n781 | |     /// A macro invocation within an impl block.\n782 | |     #[cfg_attr(docsrs, doc(cfg(feature = \"full\")))]\n783 | |     pub struct ImplItemMacro {\n...   |\n788 | | }\n    | |_- similarly named struct `ImplItemMacro` defined here\n\nerror[E0599]: no variant or associated item named `Method` found for enum `TraitItem` in the current scope\n  --> src\\main.rs:37:55\n   |\n37 |                 trait_item.items.push(syn::TraitItem::Method(new_method_sig));\n   |                                                       ^^^^^^ variant or associated item not found in `TraitItem`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:48:70\n   |\n48 | ...                   impl_block.items.push(syn::ImplItem::Method(new_method_impl));\n   |                                                            ^^^^^^ variant or associated item not found in `ImplItem`\n\nSome errors have detailed explanations: E0412, E0599.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Definition_And_Implementation_125_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0499]: cannot borrow `file.items` as mutable more than once at a time\n  --> src\\main.rs:40:34\n   |\n31 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     first mutable borrow occurs here\n   |                     first borrow later used here\n...\n40 |                 for impl_item in &mut file.items {\n   |                                  ^^^^^^^^^^^^^^^ second mutable borrow occurs here\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Definition_And_Implementation_125_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:16:54\n   |\n16 |                 let new_method_sig: syn::TraitItem = parse_quote! {\n   |                                                      ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:37:62\n   |\n37 |                         let new_method_impl: syn::ImplItem = parse_quote! {\n   |                                                              ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:14:20\n   |\n14 |             if let Item::Trait(trait_item) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:15:40\n   |\n15 |                 let new_method_ident = Ident::new(\"new_method\", Span::call_site());\n   |                                        ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:15:65\n   |\n15 |                 let new_method_ident = Ident::new(\"new_method\", Span::call_site());\n   |                                                                 ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:25:20\n   |\n25 |             if let Item::Impl(impl_block) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:36:48\n   |\n36 |                         let new_method_ident = Ident::new(\"new_method\", Span::call_site());\n   |                                                ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:36:73\n   |\n36 |                         let new_method_ident = Ident::new(\"new_method\", Span::call_site());\n   |                                                                         ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nFor more information about this error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 8 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Definition_And_Implementation_125_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:8:6\n  |\n8 | impl Mutator for Modify_Trait_Definition_And_Implementation_125 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Definition_And_Implementation_125_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0499]: cannot borrow `file.items` as mutable more than once at a time\n  --> src\\main.rs:28:21\n   |\n17 |         for item in &mut file.items {\n   |                     --------------- first mutable borrow occurs here\n...\n28 |         for item in &mut file.items {\n   |                     ^^^^^^^^^^^^^^^ second mutable borrow occurs here\n...\n34 |         for (trait_item, new_method_sig) in trait_items {\n   |                                             ----------- first borrow later used here\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Definition_And_Implementation_125_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0502]: cannot borrow `file.items` as mutable because it is also borrowed as immutable\n  --> src\\main.rs:35:25\n   |\n28 |         for item in &file.items {\n   |                     ----------- immutable borrow occurs here\n...\n35 |             for item in &mut file.items {\n   |                         ^^^^^^^^^^^^^^^ mutable borrow occurs here\n...\n43 |             for impl_block in &mut impl_items {\n   |                               --------------- immutable borrow later used here\n\nerror[E0596]: cannot borrow `impl_block.items` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:52:25\n   |\n52 |                         impl_block.items.push(new_method_impl);\n   |                         ^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nSome errors have detailed explanations: E0502, E0596.\nFor more information about an error, try `rustc --explain E0502`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_definition_and_implementation_125.rs"
    },
    {
        "mutator_name": "Modify_Trait_Implementation_123",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Implementation_123_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:34:47\n   |\n34 |                         if let syn::ImplItem::Method(method) = impl_item {\n   |                                               ^^^^^^ variant or associated item not found in `ImplItem`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `TraitItem` in the current scope\n  --> src\\main.rs:40:68\n   |\n40 | ...                   if let syn::TraitItem::Method(trait_method) = trait_item {\n   |                                              ^^^^^^ variant or associated item not found in `TraitItem`\n\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:43:101\n   |\n43 | ...                   if let Type::Path(TypePath { path, .. }) = &**ty {\n   |                                                                   ^^^^ can't be dereferenced\n\nSome errors have detailed explanations: E0599, E0614.\nFor more information about an error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Implementation_123_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0502]: cannot borrow `file.items` as immutable because it is also borrowed as mutable\n  --> src\\main.rs:38:47\n   |\n32 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     mutable borrow occurs here\n   |                     mutable borrow later used here\n...\n38 |                             for trait_item in &file.items {\n   |                                               ^^^^^^^^^^^ immutable borrow occurs here\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_implementation_123.rs"
    },
    {
        "mutator_name": "Modify_Trait_Implementation_245",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Implementation_245_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:39:51\n   |\n39 | ...                   if let syn::ImplItem::Method(method) = impl_item {\n   |                                             ^^^^^^ variant or associated item not found in `ImplItem`\n\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:42:85\n   |\n42 | ...                   if let Type::Path(TypePath { path, .. }) = &**ty {\n   |                                                                   ^^^^ can't be dereferenced\n\nSome errors have detailed explanations: E0599, E0614.\nFor more information about an error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Implementation_245_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0432]: unresolved import `syn::ImplItemMethod`\n  --> src\\main.rs:19:15\n   |\n19 |     ImplItem, ImplItemMethod,\n   |               ^^^^^^^^^^^^^^\n   |               |\n   |               no `ImplItemMethod` in the root\n   |               help: a similar name exists in the module: `ImplItemMacro`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:40:46\n   |\n40 | ...                   if let ImplItem::Method(ImplItemMethod { sig, .. }) = impl_item {\n   |                                        ^^^^^^ variant or associated item not found in `ImplItem`\n\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:43:85\n   |\n43 | ...                   if let Type::Path(TypePath { path, .. }) = &**ty {\n   |                                                                   ^^^^ can't be dereferenced\n\nSome errors have detailed explanations: E0432, E0599, E0614.\nFor more information about an error, try `rustc --explain E0432`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Implementation_245_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0382]: use of moved value: `items`\n   --> src\\main.rs:39:42\n    |\n32  |             if let Item::Impl(ItemImpl { generics, items, .. }) = item {\n    |                                                    -----\n    |                                                    |\n    |                                                    this reinitialization might get skipped\n    |                                                    move occurs because `items` has type `&mut Vec<ImplItem>`, which does not implement the `Copy` trait\n...\n35  |                 for param in &generics.params {\n    |                 ----------------------------- inside of this loop\n...\n39  |                         for impl_item in items {\n    |                                          ^^^^^ `items` moved due to this implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote: `into_iter` takes ownership of the receiver `self`, which moves `items`\n   --> C:\\Users\\love\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\iter\\traits\\collect.rs:313:18\n    |\n313 |     fn into_iter(self) -> Self::IntoIter;\n    |                  ^^^^\nhelp: consider creating a fresh reborrow of `items` here\n    |\n39  |                         for impl_item in &mut *items {\n    |                                          ++++++\n\nFor more information about this error, try `rustc --explain E0382`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_implementation_245.rs"
    },
    {
        "mutator_name": "Modify_Trait_Implementation_Conditions_199",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Implementation_Conditions_199_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:41:63\n   |\n41 | ...                   if let Stmt::Expr(Expr::Binary(ref mut bin_expr)) = stmt {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n41 |                                             if let Stmt::Expr(Expr::Binary(ref mut bin_expr), _) = stmt {\n   |                                                                                             +++\n\nFor more information about this error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Implementation_Conditions_199_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:34:33\n   |\n34 |                 if let Some((_, ref mut trait_path, _)) = &mut i.trait_ {\n   |                                 ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:34:24\n   |\n34 |                 if let Some((_, ref mut trait_path, _)) = &mut i.trait_ {\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n34 -                 if let Some((_, ref mut trait_path, _)) = &mut i.trait_ {\n34 +                 if let Some((_, trait_path, _)) = &mut i.trait_ {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:39:79\n   |\n39 | ...                   if let GenericArgument::Const(Expr::Block(ref mut block)) = arg {\n   |                                                                 ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:39:44\n   |\n39 | ...                   if let GenericArgument::Const(Expr::Block(ref mut block)) = arg {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n39 -                                     if let GenericArgument::Const(Expr::Block(ref mut block)) = arg {\n39 +                                     if let GenericArgument::Const(Expr::Block(block)) = arg {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:41:76\n   |\n41 | ...                   if let Stmt::Expr(Expr::Binary(ref mut bin_expr), _) = stmt {\n   |                                                      ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:41:52\n   |\n41 | ...                   if let Stmt::Expr(Expr::Binary(ref mut bin_expr), _) = stmt {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n41 -                                             if let Stmt::Expr(Expr::Binary(ref mut bin_expr), _) = stmt {\n41 +                                             if let Stmt::Expr(Expr::Binary(bin_expr), _) = stmt {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_trait_implementation_conditions_199.rs"
    },
    {
        "mutator_name": "Modify_Trait_Implementation_With_Missing_Method_120",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Implementation_With_Missing_Method_120_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `syn::TraitItem` in the current scope\n  --> src\\main.rs:36:39\n   |\n36 |                     if let TraitItem::Method(method) = item {\n   |                                       ^^^^^^ variant or associated item not found in `TraitItem`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `syn::ImplItem` in the current scope\n  --> src\\main.rs:48:42\n   |\n48 |                         if let ImplItem::Method(method) = item {\n   |                                          ^^^^^^ variant or associated item not found in `ImplItem`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `syn::ImplItem` in the current scope\n  --> src\\main.rs:67:50\n   |\n67 | ...                   if let ImplItem::Method(method) = item {\n   |                                        ^^^^^^ variant or associated item not found in `ImplItem`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Implementation_With_Missing_Method_120_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0432]: unresolved imports `syn::TraitItemMethod`, `syn::ImplItemMethod`\n --> src\\main.rs:2:37\n  |\n2 |     ItemTrait, TraitItem, ImplItem, TraitItemMethod, ImplItemMethod,\n  |                                     ^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^ no `ImplItemMethod` in the root\n  |                                     |\n  |                                     no `TraitItemMethod` in the root\n  |\nhelp: a similar name exists in the module\n  |\n2 -     ItemTrait, TraitItem, ImplItem, TraitItemMethod, ImplItemMethod,\n2 +     ItemTrait, TraitItem, ImplItem, TraitItemMacro, ImplItemMethod,\n  |\nhelp: a similar name exists in the module\n  |\n2 -     ItemTrait, TraitItem, ImplItem, TraitItemMethod, ImplItemMethod,\n2 +     ItemTrait, TraitItem, ImplItem, TraitItemMethod, ImplItemMacro,\n  |\n\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:7:6\n  |\n7 | impl Mutator for Modify_Trait_Implementation_With_Missing_Method_120 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n  --> src\\main.rs:12:33\n   |\n12 |         let mut trait_methods = HashSet::new();\n   |                                 ^^^^^^^ use of undeclared type `HashSet`\n   |\nhelp: consider importing this struct\n   |\n1  + use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:16:20\n   |\n16 |             if let Item::Trait(trait_item) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:26:20\n   |\n26 |             if let Item::Impl(impl_item) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:45:24\n   |\n45 |                 if let Item::Impl(impl_item) = item {\n   |                        ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nSome errors have detailed explanations: E0405, E0432, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 6 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Implementation_With_Missing_Method_120_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `TraitItem` in the current scope\n  --> src\\main.rs:20:39\n   |\n20 |                     if let TraitItem::Method(method) = item {\n   |                                       ^^^^^^ variant or associated item not found in `TraitItem`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:32:42\n   |\n32 |                         if let ImplItem::Method(method) = item {\n   |                                          ^^^^^^ variant or associated item not found in `ImplItem`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:51:50\n   |\n51 | ...                   if let ImplItem::Method(method) = item {\n   |                                        ^^^^^^ variant or associated item not found in `ImplItem`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Implementation_With_Missing_Method_120_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0432]: unresolved imports `syn::TraitItemMethod`, `syn::ImplItemMethod`\n --> src\\main.rs:2:43\n  |\n2 |     ItemTrait, TraitItem, ImplItem, Item, TraitItemMethod, ImplItemMethod,\n  |                                           ^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^ no `ImplItemMethod` in the root\n  |                                           |\n  |                                           no `TraitItemMethod` in the root\n  |\nhelp: a similar name exists in the module\n  |\n2 -     ItemTrait, TraitItem, ImplItem, Item, TraitItemMethod, ImplItemMethod,\n2 +     ItemTrait, TraitItem, ImplItem, Item, TraitItemMacro, ImplItemMethod,\n  |\nhelp: a similar name exists in the module\n  |\n2 -     ItemTrait, TraitItem, ImplItem, Item, TraitItemMethod, ImplItemMethod,\n2 +     ItemTrait, TraitItem, ImplItem, Item, TraitItemMethod, ImplItemMacro,\n  |\n\nerror[E0599]: no variant or associated item named `Method` found for enum `TraitItem` in the current scope\n  --> src\\main.rs:20:39\n   |\n20 |                     if let TraitItem::Method(method) = item {\n   |                                       ^^^^^^ variant or associated item not found in `TraitItem`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:32:42\n   |\n32 |                         if let ImplItem::Method(method) = item {\n   |                                          ^^^^^^ variant or associated item not found in `ImplItem`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:51:50\n   |\n51 | ...                   if let ImplItem::Method(method) = item {\n   |                                        ^^^^^^ variant or associated item not found in `ImplItem`\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_implementation_with_missing_method_120.rs"
    },
    {
        "mutator_name": "Modify_Trait_Impl_180",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Impl_180_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `args.args` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:45:66\n   |\n45 | ...                   *args.args.last_mut().unwrap() = GenericArgument::Const(new_expr);\n   |                        ^^^^^^^^^ `args` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Impl_180_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `last_segment.arguments` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:39:90\n   |\n37 | ...                   if let Some(last_segment) = type_path.path.segments.last() {\n   |                                   ------------ consider changing this binding's type to be: `&mut PathSegment`\n38 | ...                       if last_segment.ident == \"Tensor\" {\n39 | ...                           if let PathArguments::AngleBracketed(args) = &mut last_segment.arguments {\n   |                                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^ `last_segment` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Impl_180_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `type_path.path.segments` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:37:65\n   |\n37 | ...                   if let Some(last_segment) = type_path.path.segments.last_mut() {\n   |                                                   ^^^^^^^^^^^^^^^^^^^^^^^ `type_path` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_trait_impl_180.rs"
    },
    {
        "mutator_name": "Modify_Trait_Impl_Const_Context_132",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Impl_Const_Context_132_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n   --> src\\main.rs:37:49\n    |\n37  |                         item_impl.trait_ = Some((None, const_trait_path));\n    |                                            ---- ^^^^^^^^^^^^^^^^^^^^^^^^ expected a tuple with 3 elements, found one with 2 elements\n    |                                            |\n    |                                            arguments to this enum variant are incorrect\n    |\n    = note: expected tuple `(Option<syn::token::Not>, syn::Path, For)`\n               found tuple `(Option<syn::token::Not>, syn::Path)`\nhelp: the type constructed contains `(Option<syn::token::Not>, syn::Path)` due to the type of the argument passed\n   --> src\\main.rs:37:44\n    |\n37  |                         item_impl.trait_ = Some((None, const_trait_path));\n    |                                            ^^^^^------------------------^\n    |                                                 |\n    |                                                 this argument influences the type of `Some`\nnote: tuple variant defined here\n   --> C:\\Users\\love\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\option.rs:597:5\n    |\n597 |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    |     ^^^^\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Impl_Const_Context_132_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.92s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:36:57:\nexpected identifier, found keyword `const`\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Impl_Const_Context_132_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:12:57\n   |\n12 |                         let const_trait_path: SynPath = parse_quote! { #trait_path };\n   |                                                         ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:13:55\n   |\n13 |                         trait_path.segments.insert(0, parse_quote! { const });\n   |                                                       ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:3:6\n  |\n3 | impl Mutator for Modify_Trait_Impl_Const_Context_132 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n --> src\\main.rs:9:20\n  |\n9 |             if let Item::Impl(item_impl) = item {\n  |                    ^^^^ use of undeclared type `Item`\n  |\nhelp: consider importing this enum\n  |\n1 + use syn::Item;\n  |\n\nerror[E0412]: cannot find type `SynPath` in this scope\n  --> src\\main.rs:12:47\n   |\n12 |                         let const_trait_path: SynPath = parse_quote! { #trait_path };\n   |                                               ^^^^^^^ not found in this scope\n\nSome errors have detailed explanations: E0405, E0412, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 5 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Impl_Const_Context_132_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `mutate` found for struct `Modify_Trait_Impl_Const_Context_132` in the current scope\n  --> src\\main.rs:48:49\n   |\n3  | pub struct Modify_Trait_Impl_Const_Context_132;\n   | ---------------------------------------------- method `mutate` not found for this struct\n...\n48 |             Modify_Trait_Impl_Const_Context_132.mutate(&mut file_ast);\n   |                                                 ^^^^^^ method not found in `Modify_Trait_Impl_Const_Context_132`\n   |\n  ::: src\\mutator.rs:15:8\n   |\n15 |     fn mutate(&self, file: &mut syn::File);\n   |        ------ the method is available for `Modify_Trait_Impl_Const_Context_132` here\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: trait `Mutator` which provides `mutate` is implemented but not in scope; perhaps you want to import it\n   |\n1  + use crate::mutator::Mutator;\n   |\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Impl_Const_Context_132_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.68s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:16:55:\nexpected identifier, found keyword `const`\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_impl_const_context_132.rs"
    },
    {
        "mutator_name": "Modify_Trait_Impl_With_Const_Generics_226",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Impl_With_Const_Generics_226_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0423]: expected value, found module `path`\n  --> src\\main.rs:33:110\n   |\n33 |                 if sig.inputs.is_empty() && sig.output == ReturnType::Type(_, Box::new(Type::Path(TypePath { path, .. }))) {\n   |                                                                                                              ^^^^ not a value\n\nerror[E0423]: expected value, found module `path`\n  --> src\\main.rs:34:24\n   |\n34 |                     if path.segments.last().unwrap().ident == \"usize\" {\n   |                        ^^^^\n   |\nhelp: use the path separator to refer to an item\n   |\n34 -                     if path.segments.last().unwrap().ident == \"usize\" {\n34 +                     if path::segments.last().unwrap().ident == \"usize\" {\n   |\n\nerror: in expressions, `_` can only be used on the left-hand side of an assignment\n  --> src\\main.rs:33:76\n   |\n33 |                 if sig.inputs.is_empty() && sig.output == ReturnType::Type(_, Box::new(Type::Path(TypePath { path, .. }))) {\n   |                                                                            ^ `_` not allowed here\n\nerror[E0797]: base expression required after `..`\n  --> src\\main.rs:33:118\n   |\n33 |                 if sig.inputs.is_empty() && sig.output == ReturnType::Type(_, Box::new(Type::Path(TypePath { path, .. }))) {\n   |                                                                                                                      ^\n   |\nhelp: add a base expression here\n   |\n33 |                 if sig.inputs.is_empty() && sig.output == ReturnType::Type(_, Box::new(Type::Path(TypePath { path, ../* expr */ }))) {\n   |                                                                                                                      ++++++++++\n\nSome errors have detailed explanations: E0423, E0797.\nFor more information about an error, try `rustc --explain E0423`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Impl_With_Const_Generics_226_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:28:40\n   |\n28 |             let new_function: ItemFn = parse_quote! {\n   |                                        ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:46:70\n   |\n46 | ...                   let new_expr: Expr = parse_quote! { #fn_name() };\n   |                                            ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:12:20\n   |\n12 |             if let Item::Fn(ItemFn { sig, .. }) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `ItemFn` in this scope\n  --> src\\main.rs:12:29\n   |\n12 |             if let Item::Fn(ItemFn { sig, .. }) = item {\n   |                             ^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::ItemFn;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `ReturnType`\n  --> src\\main.rs:14:28\n   |\n14 |                     if let ReturnType::Type(_, box_type) = &sig.output {\n   |                            ^^^^^^^^^^ use of undeclared type `ReturnType`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::ReturnType;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:15:32\n   |\n15 |                         if let Type::Path(TypePath { path, .. }) = &**box_type {\n   |                                ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypePath` in this scope\n  --> src\\main.rs:15:43\n   |\n15 |                         if let Type::Path(TypePath { path, .. }) = &**box_type {\n   |                                           ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypePath;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:27:34\n   |\n27 |             function_name = Some(Ident::new(\"generated_function\", Span::call_site()));\n   |                                  ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:27:67\n   |\n27 |             function_name = Some(Ident::new(\"generated_function\", Span::call_site()));\n   |                                                                   ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0412]: cannot find type `ItemFn` in this scope\n  --> src\\main.rs:28:31\n   |\n28 |             let new_function: ItemFn = parse_quote! {\n   |                               ^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::ItemFn;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:33:34\n   |\n33 |             file.items.insert(0, Item::Fn(new_function));\n   |                                  ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:38:24\n   |\n38 |                 if let Item::Impl(item_impl) = item {\n   |                        ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `PathArguments`\n  --> src\\main.rs:41:36\n   |\n41 | ...                   if let PathArguments::AngleBracketed(args) = &mut segment.arguments {\n   |                              ^^^^^^^^^^^^^ use of undeclared type `PathArguments`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::PathArguments;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericArgument`\n  --> src\\main.rs:43:44\n   |\n43 | ...                   if let GenericArgument::Type(Type::Array(type_array)) = arg {\n   |                              ^^^^^^^^^^^^^^^ use of undeclared type `GenericArgument`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericArgument;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:43:66\n   |\n43 | ...                   if let GenericArgument::Type(Type::Array(type_array)) = arg {\n   |                                                    ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:44:48\n   |\n44 | ...                   if let Expr::Path(ExprPath { path: array_path, .. }) = &type_array.len {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `ExprPath` in this scope\n  --> src\\main.rs:44:59\n   |\n44 | ...                   if let Expr::Path(ExprPath { path: array_path, .. }) = &type_array.len {\n   |                                         ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::ExprPath;\n   |\n\nerror[E0412]: cannot find type `Expr` in this scope\n  --> src\\main.rs:46:63\n   |\n46 | ...                   let new_expr: Expr = parse_quote! { #fn_name() };\n   |                                     ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nSome errors have detailed explanations: E0412, E0422, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 18 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Impl_With_Const_Generics_226_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:6:6\n  |\n6 | impl Mutator for Modify_Trait_Impl_With_Const_Generics_226 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Impl_With_Const_Generics_226_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `path.segments` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:42:40\n   |\n42 |                         for segment in &mut path.segments {\n   |                                        ^^^^^^^^^^^^^^^^^^ `path` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_impl_with_const_generics_226.rs"
    },
    {
        "mutator_name": "Modify_Trait_Impl_With_Generic_Const_225",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Impl_With_Generic_Const_225_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0499]: cannot borrow `file.items` as mutable more than once at a time\n  --> src\\main.rs:48:45\n   |\n35 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     first mutable borrow occurs here\n   |                     first borrow later used here\n...\n48 |                                             file.items.push(Item::Const(new_const));\n   |                                             ^^^^^^^^^^ second mutable borrow occurs here\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_trait_impl_with_generic_const_225.rs"
    },
    {
        "mutator_name": "Modify_Trait_Method_Signature_147",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Method_Signature_147_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `TraitItem` in the current scope\n  --> src\\main.rs:33:44\n   |\n33 |                     if let syn::TraitItem::Method(ref mut method) = trait_item {\n   |                                            ^^^^^^ variant or associated item not found in `TraitItem`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Method_Signature_147_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:34:37\n   |\n34 |                         if let Some(syn::Signature { constness: Some(_), generics, .. }) = method.sig.constness {\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    -------------------- this expression has type `Option<syn::token::Const>`\n   |                                     |\n   |                                     expected `Const`, found `Signature`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Method_Signature_147_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:17:54\n   |\n17 | ...                   const_param.ty = parse_quote! { &str };\n   |                                        ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Trait(ref mut trait_item) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericParam`\n  --> src\\main.rs:16:40\n   |\n16 | ...                   if let GenericParam::Const(ref mut const_param) = param {\n   |                              ^^^^^^^^^^^^ use of undeclared type `GenericParam`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nFor more information about this error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Method_Signature_147_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:7:6\n  |\n7 | impl Mutator for Modify_Trait_Method_Signature_147 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Method_Signature_147_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:14:32\n   |\n14 |             if let Item::Trait(ref mut trait_item) = item {\n   |                                ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:14:20\n   |\n14 |             if let Item::Trait(ref mut trait_item) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n14 -             if let Item::Trait(ref mut trait_item) = item {\n14 +             if let Item::Trait(trait_item) = item {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:16:47\n   |\n16 |                     if let syn::TraitItem::Fn(ref mut method) = trait_item {\n   |                                               ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:16:28\n   |\n16 |                     if let syn::TraitItem::Fn(ref mut method) = trait_item {\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n16 -                     if let syn::TraitItem::Fn(ref mut method) = trait_item {\n16 +                     if let syn::TraitItem::Fn(method) = trait_item {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:19:60\n   |\n19 | ...                   if let GenericParam::Const(ref mut const_param) = param {\n   |                                                  ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:19:40\n   |\n19 | ...                   if let GenericParam::Const(ref mut const_param) = param {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n19 -                                 if let GenericParam::Const(ref mut const_param) = param {\n19 +                                 if let GenericParam::Const(const_param) = param {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_trait_method_signature_147.rs"
    },
    {
        "mutator_name": "Modify_Trait_With_Generic_Const_Parameter_206",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_With_Generic_Const_Parameter_206_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:35:37\n   |\n35 |                         if let Some((_, ref mut generics)) = type_item.generics.const_params_mut().next() {\n   |                                     ^^^^^^^^^^^^^^^^^^^^^    -------------------------------------------- this expression has type `Option<&mut ConstParam>`\n   |                                     |\n   |                                     expected `ConstParam`, found `(_, _)`\n   |\n   = note: expected struct `ConstParam`\n               found tuple `(_, _)`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_with_generic_const_parameter_206.rs"
    },
    {
        "mutator_name": "Modify_Tuple_Access_34",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Tuple_Access_34_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n   --> src\\main.rs:40:78\n    |\n40  | ...                   expr_field.member = syn::Member::Unnamed(index + 2);\n    |                                           -------------------- ^^^^^^^^^ expected `Index`, found `usize`\n    |                                           |\n    |                                           arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\expr.rs:979:9\n    |\n979 |         Unnamed(Index),\n    |         ^^^^^^^\nhelp: call `Into::into` on this expression to convert `usize` into `syn::Index`\n    |\n40  |                                     expr_field.member = syn::Member::Unnamed((index + 2).into());\n    |                                                                              +         ++++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Tuple_Access_34_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:3:6\n  |\n3 | impl Mutator for Modify_Tuple_Access_34 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nerror[E0405]: cannot find trait `VisitMut` in this scope\n  --> src\\main.rs:10:14\n   |\n10 |         impl VisitMut for TupleFieldAccessMutator {\n   |              ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this trait\n   |\n1  + use syn::visit_mut::VisitMut;\n   |\n\nerror[E0412]: cannot find type `ExprField` in this scope\n  --> src\\main.rs:11:65\n   |\n11 |             fn visit_expr_field_mut(&mut self, expr_field: &mut ExprField) {\n   |                                                                 ^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::ExprField;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:12:24\n   |\n12 |                 if let Expr::Path(ExprPath { path, .. }) = &*expr_field.base {\n   |                        ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `ExprPath` in this scope\n  --> src\\main.rs:12:35\n   |\n12 |                 if let Expr::Path(ExprPath { path, .. }) = &*expr_field.base {\n   |                                   ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::ExprPath;\n   |\n\nSome errors have detailed explanations: E0405, E0412, E0422, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 5 previous errors\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_tuple_access_34.rs"
    },
    {
        "mutator_name": "Modify_Type_Alias_With_Non_Implementing_Type_232",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_type_alias_with_non_implementing_type_232.rs"
    },
    {
        "mutator_name": "Modify_Type_Alias_With_Trait_Bound_243",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Type_Alias_With_Trait_Bound_243_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:32:24\n   |\n32 |                 if let Type::ImplTrait(type_impl_trait) = &type_item.ty {\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ------------- this expression has type `&std::boxed::Box<syn::Type>`\n   |                        |\n   |                        expected `Box<Type>`, found `Type`\n   |\n   = note: expected struct `std::boxed::Box<syn::Type>`\n                found enum `syn::Type`\nhelp: consider dereferencing to access the inner value using the Deref trait\n   |\n32 |                 if let Type::ImplTrait(type_impl_trait) = &*type_item.ty {\n   |                                                            +\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_type_alias_with_trait_bound_243.rs"
    },
    {
        "mutator_name": "Modify_Union_With_Generic_Const_Expressions_141",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Union_With_Generic_Const_Expressions_141_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:35:59\n   |\n35 |                         if let Expr::Block(expr_block) = &*type_array.len {\n   |                                                           ^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:37:51\n   |\n37 | ...                   if let Stmt::Expr(Expr::Call(expr_call)) = &expr_block.block.stmts[0] {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n37 |                                 if let Stmt::Expr(Expr::Call(expr_call), _) = &expr_block.block.stmts[0] {\n   |                                                                        +++\n\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:53:67\n   |\n53 | ...                   if let Expr::Block(expr_block) = &mut *type_array.len {\n   |                                                             ^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:55:55\n   |\n55 | ...                   if let Stmt::Expr(Expr::Call(expr_call)) = &mut expr_block.block.stmts[0] {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n55 |                                     if let Stmt::Expr(Expr::Call(expr_call), _) = &mut expr_block.block.stmts[0] {\n   |                                                                            +++\n\nerror[E0061]: this enum variant takes 2 arguments but 1 argument was supplied\n  --> src\\main.rs:59:77\n   |\n59 | ...                   expr_block.block.stmts[0] = Stmt::Expr(new_expr);\n   |                                                   ^^^^^^^^^^---------- argument #2 of type `Option<Semi>` is missing\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:9\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |         ^^^^\nhelp: provide the argument\n   |\n59 |                                                 expr_block.block.stmts[0] = Stmt::Expr(new_expr, /* Option<Semi> */);\n   |                                                                                                ++++++++++++++++++++\n\nSome errors have detailed explanations: E0023, E0061, E0614.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 5 previous errors\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_union_with_generic_const_expressions_141.rs"
    },
    {
        "mutator_name": "Mutate_Closure_Type_Mismatch_10",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Mutate_Closure_Type_Mismatch_10_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:39:59\n   |\n39 | ...                   if let Stmt::Expr(expr) = stmt {\n   |                                         ^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n39 |                                         if let Stmt::Expr(expr, _) = stmt {\n   |                                                               +++\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:45:48\n   |\n45 | ...                   if let Some(Expr::Block(block)) = &mut *closure.body {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^   ------------------ this expression has type `&mut syn::Expr`\n   |                              |\n   |                              expected `Expr`, found `Option<_>`\n   |\n   = note: expected enum `syn::Expr`\n              found enum `Option<_>`\n\nerror[E0609]: no field `stmts` on type `&mut ExprBlock`\n  --> src\\main.rs:46:51\n   |\n46 | ...                   block.stmts.push(parse_quote! {\n   |                             ^^^^^ unknown field\n   |\nhelp: one of the expressions' fields has a field of the same name\n   |\n46 |                                             block.block.stmts.push(parse_quote! {\n   |                                                   ++++++\n\nSome errors have detailed explanations: E0023, E0308, E0609.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\mutate_closure_type_mismatch_10.rs"
    },
    {
        "mutator_name": "Mutate_Const_Function_173",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Mutate_Const_Function_173_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:44:68\n   |\n44 | ...                   if let Stmt::Expr(Expr::Call(expr_call)) = expr {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this expression has type `&mut [Stmt]`\n   |                              |\n   |                              expected `[Stmt]`, found `Stmt`\n   |\n   = note: expected slice `[Stmt]`\n               found enum `Stmt`\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:44:79\n   |\n44 | ...                   if let Stmt::Expr(Expr::Call(expr_call)) = expr {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n44 |                                                             if let Stmt::Expr(Expr::Call(expr_call), _) = expr {\n   |                                                                                                    +++\n\nerror[E0277]: the size for values of type `[Stmt]` cannot be known at compilation time\n  --> src\\main.rs:49:77\n   |\n49 | ...                   *expr = parse_quote!({ const fn inner() -> bool { true } inner(); false });\n   |                       ^^^^^ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented for `[Stmt]`\n   = note: the left-hand-side of an assignment must have a statically known size\n\nerror[E0277]: the trait bound `[Stmt]: syn::parse_quote::ParseQuote` is not satisfied\n   --> src\\main.rs:49:85\n    |\n49  | ...                   *expr = parse_quote!({ const fn inner() -> bool { true } inner(); false });\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Parse` is not implemented for `[Stmt]`\n    |\n    = help: the following other types implement trait `Parse`:\n              Abstract\n              AndAnd\n              AndEq\n              AngleBracketedGenericArguments\n              Arm\n              As\n              At\n              Auto\n            and 248 others\n    = note: required for `[Stmt]` to implement `syn::parse_quote::ParseQuote`\nnote: required by a bound in `parse_quote`\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\parse_quote.rs:117:17\n    |\n117 | pub fn parse<T: ParseQuote>(token_stream: TokenStream) -> T {\n    |                 ^^^^^^^^^^ required by this bound in `parse`\n    = note: this error originates in the macro `parse_quote` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0023, E0277, E0308.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\mutate_const_function_173.rs"
    },
    {
        "mutator_name": "Mutator_Add_Const_Generic_215",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Mutator_Add_Const_Generic_215_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0499]: cannot borrow `file.items` as mutable more than once at a time\n  --> src\\main.rs:48:21\n   |\n30 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     first mutable borrow occurs here\n   |                     first borrow later used here\n...\n48 |                     file.items.push(Item::Fn(compute_fn));\n   |                     ^^^^^^^^^^ second mutable borrow occurs here\n\nerror[E0499]: cannot borrow `file.items` as mutable more than once at a time\n  --> src\\main.rs:49:21\n   |\n30 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     first mutable borrow occurs here\n   |                     first borrow later used here\n...\n49 |                     file.items.push(Item::Fn(use_fn));\n   |                     ^^^^^^^^^^ second mutable borrow occurs here\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\mutator_add_const_generic_215.rs"
    },
    {
        "mutator_name": "Mutator_Add_Logging_13",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\mutator_add_logging_13.rs"
    },
    {
        "mutator_name": "Mutator_Change_AssocType_Context_160",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\mutator_change_assoctype_context_160.rs"
    },
    {
        "mutator_name": "Mutator_Change_Trait_Bound_23",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Mutator_Change_Trait_Bound_23_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n    --> src\\main.rs:37:48\n     |\n37   | ...                   trait_bound.path = new_trait;\n     |                       ----------------   ^^^^^^^^^ expected `syn::Path`, found `std::path::Path`\n     |                       |\n     |                       expected due to the type of this binding\n     |\n     = note: `std::path::Path` and `syn::Path` have similar names, but are actually distinct types\nnote: `std::path::Path` is defined in crate `std`\n    --> C:\\Users\\love\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\std\\src\\path.rs:2143:1\n     |\n2143 | pub struct Path {\n     | ^^^^^^^^^^^^^^^\nnote: `syn::Path` is defined in crate `syn`\n    --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\path.rs:11:1\n     |\n11   | / ast_struct! {\n12   | |     /// A path at which a named item is exported (e.g. `std::collections::HashMap`).\n13   | |     #[cfg_attr(docsrs, doc(cfg(any(feature = \"full\", feature = \"derive\"))))]\n14   | |     pub struct Path {\n...    |\n18   | | }\n     | |_^\n     = note: this error originates in the macro `ast_struct` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n    --> src\\main.rs:36:33\n     |\n36   | ...                   let new_trait: Path = parse_quote!(Clone);\n     |                           ^^^^^^^^^ doesn't have a size known at compile-time\n     |\n     = help: within `std::path::Path`, the trait `Sized` is not implemented for `[u8]`\nnote: required because it appears within the type `std::path::Path`\n    --> C:\\Users\\love\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\std\\src\\path.rs:2143:12\n     |\n2143 | pub struct Path {\n     |            ^^^^\n     = note: all local variables must have a statically known size\n     = help: unsized locals are gated as an unstable feature\nhelp: consider borrowing here\n     |\n36   |                             let new_trait: &Path = parse_quote!(Clone);\n     |                                            +\n\nerror[E0277]: the trait bound `std::path::Path: syn::parse_quote::ParseQuote` is not satisfied\n   --> src\\main.rs:36:51\n    |\n36  | ...                   let new_trait: Path = parse_quote!(Clone);\n    |                                             ^^^^^^^^^^^^^^^^^^^ the trait `Parse` is not implemented for `std::path::Path`\n    |\n    = help: the following other types implement trait `Parse`:\n              Abstract\n              AndAnd\n              AndEq\n              AngleBracketedGenericArguments\n              Arm\n              As\n              At\n              Auto\n            and 248 others\n    = note: required for `std::path::Path` to implement `syn::parse_quote::ParseQuote`\nnote: required by a bound in `parse_quote`\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\parse_quote.rs:117:17\n    |\n117 | pub fn parse<T: ParseQuote>(token_stream: TokenStream) -> T {\n    |                 ^^^^^^^^^^ required by this bound in `parse`\n    = note: this error originates in the macro `parse_quote` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n    --> src\\main.rs:36:51\n     |\n36   | ...                   let new_trait: Path = parse_quote!(Clone);\n     |                                             ^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n     |\n     = help: within `std::path::Path`, the trait `Sized` is not implemented for `[u8]`\nnote: required because it appears within the type `std::path::Path`\n    --> C:\\Users\\love\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\std\\src\\path.rs:2143:12\n     |\n2143 | pub struct Path {\n     |            ^^^^\n     = note: the return type of a function must have a statically known size\n     = note: this error originates in the macro `parse_quote` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\mutator_change_trait_bound_23.rs"
    },
    {
        "mutator_name": "Mutator_Closure_Trait_Bound_138",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Mutator_Closure_Trait_Bound_138_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:33:39\n   |\n33 |                     if let Stmt::Expr(Expr::Closure(expr_closure)) = stmt {\n   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n33 |                     if let Stmt::Expr(Expr::Closure(expr_closure), _) = stmt {\n   |                                                                  +++\n\nerror[E0599]: the method `as_ref` exists for reference `&syn::Expr`, but its trait bounds were not satisfied\n   --> src\\main.rs:34:77\n    |\n34  |                           if let Some((_, expr)) = expr_closure.body.as_ref().as_ref() {\n    |                                                                               ^^^^^^ method cannot be called on `&syn::Expr` due to unsatisfied trait bounds\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\expr.rs:35:1\n    |\n35  | / ast_enum_of_structs! {\n36  | |     /// A Rust expression.\n37  | |     ///\n38  | |     /// *This type is available only if Syn is built with the `\"derive\"` or `\"full\"`\n...   |\n267 | | }\n    | |_- doesn't satisfy `syn::Expr: AsRef<_>`\n    |\n    = note: the following trait bounds were not satisfied:\n            `syn::Expr: AsRef<_>`\n            which is required by `&syn::Expr: AsRef<_>`\n\nerror[E0061]: this enum variant takes 2 arguments but 1 argument was supplied\n  --> src\\main.rs:54:45\n   |\n54 | ...                   *stmt = Stmt::Expr(Expr::Cast(new_cast));\n   |                               ^^^^^^^^^^---------------------- argument #2 of type `Option<Semi>` is missing\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:9\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |         ^^^^\nhelp: provide the argument\n   |\n54 |                                     *stmt = Stmt::Expr(Expr::Cast(new_cast), /* Option<Semi> */);\n   |                                                                            ++++++++++++++++++++\n\nSome errors have detailed explanations: E0023, E0061, E0599.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mutator_Closure_Trait_Bound_138_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Fn(item_fn) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:13:28\n   |\n13 |                     if let Stmt::Expr(Expr::Closure(expr_closure), _) = stmt {\n   |                            ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:13:39\n   |\n13 |                     if let Stmt::Expr(Expr::Closure(expr_closure), _) = stmt {\n   |                                       ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:14:32\n   |\n14 |                         if let Expr::Cast(expr_cast) = &*expr_closure.body {\n   |                                ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:15:36\n   |\n15 | ...                   if let Type::Reference(type_ref) = &*expr_cast.ty {\n   |                              ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0425]: cannot find function `thread_rng` in this scope\n  --> src\\main.rs:16:47\n   |\n16 | ...                   let mut rng = thread_rng();\n   |                                     ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  + use rand::thread_rng;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:17:48\n   |\n17 | ...                   let new_type = Ident::new(\"SomeOtherType\", Span::call_site());\n   |                                      ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:17:76\n   |\n17 | ...                   let new_type = Ident::new(\"SomeOtherType\", Span::call_site());\n   |                                                                  ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `ExprCast` in this scope\n  --> src\\main.rs:18:48\n   |\n18 | ...                   let new_cast = ExprCast {\n   |                                      ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::ExprCast;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:22:50\n   |\n22 | ...                   ty: Box::new(Type::Path(TypePath {\n   |                                    ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypePath` in this scope\n  --> src\\main.rs:22:61\n   |\n22 | ...                   ty: Box::new(Type::Path(TypePath {\n   |                                               ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypePath;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `SynPath` in this scope\n  --> src\\main.rs:24:47\n   |\n24 | ...                   path: SynPath {\n   |                             ^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Punctuated`\n  --> src\\main.rs:26:55\n   |\n26 | ...                   segments: Punctuated::from_iter(vec![PathSegment {\n   |                                 ^^^^^^^^^^ use of undeclared type `Punctuated`\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::punctuated::Punctuated;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `PathSegment` in this scope\n  --> src\\main.rs:26:82\n   |\n26 | ...                   segments: Punctuated::from_iter(vec![PathSegment {\n   |                                                            ^^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::PathSegment;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `PathArguments`\n  --> src\\main.rs:28:60\n   |\n28 | ...                   arguments: PathArguments::None,\n   |                                  ^^^^^^^^^^^^^ use of undeclared type `PathArguments`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::PathArguments;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:33:41\n   |\n33 | ...                   *stmt = Stmt::Expr(Expr::Cast(new_cast), None);\n   |                               ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:33:52\n   |\n33 | ...                   *stmt = Stmt::Expr(Expr::Cast(new_cast), None);\n   |                                          ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nSome errors have detailed explanations: E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 17 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mutator_Closure_Trait_Bound_138_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:17:39\n   |\n17 |                     if let Stmt::Expr(Expr::Closure(expr_closure)) = stmt {\n   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n17 |                     if let Stmt::Expr(Expr::Closure(expr_closure), _) = stmt {\n   |                                                                  +++\n\nerror[E0061]: this enum variant takes 2 arguments but 1 argument was supplied\n  --> src\\main.rs:37:41\n   |\n37 | ...                   *stmt = Stmt::Expr(Expr::Cast(new_cast));\n   |                               ^^^^^^^^^^---------------------- argument #2 of type `Option<Semi>` is missing\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:9\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |         ^^^^\nhelp: provide the argument\n   |\n37 |                                 *stmt = Stmt::Expr(Expr::Cast(new_cast), /* Option<Semi> */);\n   |                                                                        ++++++++++++++++++++\n\nSome errors have detailed explanations: E0023, E0061.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\mutator_closure_trait_bound_138.rs"
    },
    {
        "mutator_name": "Mutator_Function_Signature_Mismatch_190",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Mutator_Function_Signature_Mismatch_190_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `TraitItem` in the current scope\n  --> src\\main.rs:35:44\n   |\n35 |                     if let syn::TraitItem::Method(method) = item {\n   |                                            ^^^^^^ variant or associated item not found in `TraitItem`\n\nerror[E0614]: type `Pat` cannot be dereferenced\n  --> src\\main.rs:37:63\n   |\n37 | ...                   if let Pat::Ident(param_ident) = &**pat {\n   |                                                         ^^^^^ can't be dereferenced\n\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:38:82\n   |\n38 | ...                   trait_methods.insert((param_ident.ident.clone(), (**ty).clone()));\n   |                                                                        ^^^^^^ can't be dereferenced\n\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:49:43\n   |\n49 |                     if let syn::ImplItem::Method(method) = item {\n   |                                           ^^^^^^ variant or associated item not found in `ImplItem`\n\nerror[E0614]: type `Pat` cannot be dereferenced\n  --> src\\main.rs:51:63\n   |\n51 | ...                   if let Pat::Ident(param_ident) = &**pat {\n   |                                                         ^^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n   --> src\\main.rs:52:85\n    |\n52  | ...                   if let Some((_, original_type)) = trait_methods.get(&param_ident.ident) {\n    |                                                                       --- ^^^^^^^^^^^^^^^^^^ expected `&(Ident, Type)`, found `&Ident`\n    |                                                                       |\n    |                                                                       arguments to this method are incorrect\n    |\n    = note: expected reference `&(proc_macro2::Ident, syn::Type)`\n               found reference `&proc_macro2::Ident`\nnote: method defined here\n   --> C:\\Users\\love\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\std\\src\\collections\\hash\\set.rs:713:12\n    |\n713 |     pub fn get<Q: ?Sized>(&self, value: &Q) -> Option<&T>\n    |            ^^^\n\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:53:81\n   |\n53 | ...                   if let Type::Path(TypePath { path, .. }) = &**ty {\n   |                                                                   ^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:55:51\n   |\n55 | ...                   *ty = Box::new(parse_quote!(usize));\n   |                       ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Type`, found `Box<_>`\n   |                       |\n   |                       expected due to the type of this binding\n   |\n   = note: expected enum `syn::Type`\n            found struct `std::boxed::Box<_>`\nhelp: consider unboxing the value\n   |\n55 |                                             *ty = *Box::new(parse_quote!(usize));\n   |                                                   +\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:57:51\n   |\n57 | ...                   *ty = Box::new(parse_quote!(u8));\n   |                       ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Type`, found `Box<_>`\n   |                       |\n   |                       expected due to the type of this binding\n   |\n   = note: expected enum `syn::Type`\n            found struct `std::boxed::Box<_>`\nhelp: consider unboxing the value\n   |\n57 |                                             *ty = *Box::new(parse_quote!(u8));\n   |                                                   +\n\nSome errors have detailed explanations: E0308, E0599, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 9 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mutator_Function_Signature_Mismatch_190_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:35:51\n   |\n35 | ...                   *ty = parse_quote!(usize);\n   |                             ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:37:51\n   |\n37 | ...                   *ty = parse_quote!(u8);\n   |                             ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0412]: cannot find type `HashSet` in this scope\n  --> src\\main.rs:10:32\n   |\n10 |         let mut trait_methods: HashSet<(Ident, Type)> = HashSet::new();\n   |                                ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use std::collections::HashSet;\n   |\n\nerror[E0412]: cannot find type `Ident` in this scope\n  --> src\\main.rs:10:41\n   |\n10 |         let mut trait_methods: HashSet<(Ident, Type)> = HashSet::new();\n   |                                         ^^^^^ not found in this scope\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nerror[E0412]: cannot find type `Type` in this scope\n  --> src\\main.rs:10:48\n   |\n10 |         let mut trait_methods: HashSet<(Ident, Type)> = HashSet::new();\n   |                                                ^^^^ not found in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n  --> src\\main.rs:10:57\n   |\n10 |         let mut trait_methods: HashSet<(Ident, Type)> = HashSet::new();\n   |                                                         ^^^^^^^ use of undeclared type `HashSet`\n   |\nhelp: consider importing this struct\n   |\n1  + use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:13:20\n   |\n13 |             if let Item::Trait(trait_item) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `FnArg`\n  --> src\\main.rs:16:37\n   |\n16 |                         if let Some(FnArg::Typed(PatType { ty, pat, .. })) = method.sig.inputs.first() {\n   |                                     ^^^^^ use of undeclared type `FnArg`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::FnArg;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `PatType` in this scope\n  --> src\\main.rs:16:50\n   |\n16 |                         if let Some(FnArg::Typed(PatType { ty, pat, .. })) = method.sig.inputs.first() {\n   |                                                  ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::PatType;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Pat`\n  --> src\\main.rs:17:36\n   |\n17 | ...                   if let Pat::Ident(param_ident) = &*pat {\n   |                              ^^^ use of undeclared type `Pat`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Pat;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:27:20\n   |\n27 |             if let Item::Impl(ItemImpl { items, .. }) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `ItemImpl` in this scope\n  --> src\\main.rs:27:31\n   |\n27 |             if let Item::Impl(ItemImpl { items, .. }) = item {\n   |                               ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::ItemImpl;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `FnArg`\n  --> src\\main.rs:30:37\n   |\n30 |                         if let Some(FnArg::Typed(PatType { ty, pat, .. })) = method.sig.inputs.first_mut() {\n   |                                     ^^^^^ use of undeclared type `FnArg`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::FnArg;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `PatType` in this scope\n  --> src\\main.rs:30:50\n   |\n30 |                         if let Some(FnArg::Typed(PatType { ty, pat, .. })) = method.sig.inputs.first_mut() {\n   |                                                  ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::PatType;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Pat`\n  --> src\\main.rs:31:36\n   |\n31 | ...                   if let Pat::Ident(param_ident) = &*pat {\n   |                              ^^^ use of undeclared type `Pat`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Pat;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:33:44\n   |\n33 | ...                   if let Type::Path(TypePath { path, .. }) = &*ty {\n   |                              ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypePath` in this scope\n  --> src\\main.rs:33:55\n   |\n33 | ...                   if let Type::Path(TypePath { path, .. }) = &*ty {\n   |                                         ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypePath;\n   |\n\nSome errors have detailed explanations: E0412, E0422, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 17 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mutator_Function_Signature_Mismatch_190_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:7:6\n  |\n7 | impl Mutator for Mutator_Function_Signature_Mismatch_190 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mutator_Function_Signature_Mismatch_190_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:20:36\n   |\n20 | ...                   if let Pat::Ident(param_ident) = &*pat {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^   ----- this expression has type `&std::boxed::Box<Pat>`\n   |                              |\n   |                              expected `Box<Pat>`, found `Pat`\n   |\n   = note: expected struct `std::boxed::Box<Pat>`\n                found enum `Pat`\nhelp: consider dereferencing to access the inner value using the Deref trait\n   |\n20 |                             if let Pat::Ident(param_ident) = &**pat {\n   |                                                                +\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:21:82\n   |\n21 | ...                   trait_methods.insert((param_ident.ident.clone(), (*ty).clone()));\n   |                                                                        ^^^^^^^^^^^^^ expected `Type`, found `Box<Type>`\n   |\n   = note: expected enum `syn::Type`\n            found struct `std::boxed::Box<syn::Type>`\nhelp: consider unboxing the value\n   |\n21 |                                 trait_methods.insert((param_ident.ident.clone(), *(*ty).clone()));\n   |                                                                                  +\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:34:36\n   |\n34 | ...                   if let Pat::Ident(param_ident) = &*pat {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^   ----- this expression has type `&std::boxed::Box<Pat>`\n   |                              |\n   |                              expected `Box<Pat>`, found `Pat`\n   |\n   = note: expected struct `std::boxed::Box<Pat>`\n                found enum `Pat`\nhelp: consider dereferencing to access the inner value using the Deref trait\n   |\n34 |                             if let Pat::Ident(param_ident) = &**pat {\n   |                                                                +\n\nerror[E0308]: mismatched types\n   --> src\\main.rs:35:85\n    |\n35  | ...                   if let Some((_, original_type)) = trait_methods.get(&param_ident.ident) {\n    |                                                                       --- ^^^^^^^^^^^^^^^^^^ expected `&(Ident, Type)`, found `&Ident`\n    |                                                                       |\n    |                                                                       arguments to this method are incorrect\n    |\n    = note: expected reference `&(syn::Ident, syn::Type)`\n               found reference `&syn::Ident`\nnote: method defined here\n   --> C:\\Users\\love\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\std\\src\\collections\\hash\\set.rs:713:12\n    |\n713 |     pub fn get<Q: ?Sized>(&self, value: &Q) -> Option<&T>\n    |            ^^^\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:36:44\n   |\n36 | ...                   if let Type::Path(TypePath { path, .. }) = &*ty {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this expression has type `&std::boxed::Box<syn::Type>`\n   |                              |\n   |                              expected `Box<Type>`, found `Type`\n   |\n   = note: expected struct `std::boxed::Box<syn::Type>`\n                found enum `syn::Type`\nhelp: consider dereferencing to access the inner value using the Deref trait\n   |\n36 |                                     if let Type::Path(TypePath { path, .. }) = &**ty {\n   |                                                                                  +\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 5 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\mutator_function_signature_mismatch_190.rs"
    },
    {
        "mutator_name": "Mutator_Type_Alias_Impl_Trait_227",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Mutator_Type_Alias_Impl_Trait_227_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:32:24\n   |\n32 |                 if let Type::ImplTrait(type_impl_trait) = &type_item.ty {\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ------------- this expression has type `&std::boxed::Box<syn::Type>`\n   |                        |\n   |                        expected `Box<Type>`, found `Type`\n   |\n   = note: expected struct `std::boxed::Box<syn::Type>`\n                found enum `syn::Type`\nhelp: consider dereferencing to access the inner value using the Deref trait\n   |\n32 |                 if let Type::ImplTrait(type_impl_trait) = &*type_item.ty {\n   |                                                            +\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mutator_Type_Alias_Impl_Trait_227_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:15:57\n   |\n15 |                     let another_trait: TypeParamBound = parse_quote!(AnotherTrait);\n   |                                                         ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:28:40\n   |\n28 |         let another_trait_decl: Item = parse_quote! {\n   |                                        ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Type(type_item) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:12:24\n   |\n12 |                 if let Type::ImplTrait(type_impl_trait) = &*type_item.ty {\n   |                        ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0412]: cannot find type `TypeParamBound` in this scope\n  --> src\\main.rs:15:40\n   |\n15 |                     let another_trait: TypeParamBound = parse_quote!(AnotherTrait);\n   |                                        ^^^^^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TypeParamBound;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TypeParamBound`\n  --> src\\main.rs:16:63\n   |\n16 | ...   if !new_bounds.iter().any(|b| matches!(b, TypeParamBound::Trait(trait_bound) if trait_bound.path.is_ident(\"AnotherTrait\"))) {\n   |                                                 ^^^^^^^^^^^^^^ use of undeclared type `TypeParamBound`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TypeParamBound;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:20:45\n   |\n20 |                     type_item.ty = Box::new(Type::ImplTrait(TypeImplTrait {\n   |                                             ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypeImplTrait` in this scope\n  --> src\\main.rs:20:61\n   |\n20 |                     type_item.ty = Box::new(Type::ImplTrait(TypeImplTrait {\n   |                                                             ^^^^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypeImplTrait;\n   |\n\nerror[E0412]: cannot find type `Item` in this scope\n  --> src\\main.rs:28:33\n   |\n28 |         let another_trait_decl: Item = parse_quote! {\n   |                                 ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nSome errors have detailed explanations: E0412, E0422, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 9 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mutator_Type_Alias_Impl_Trait_227_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Mutator_Type_Alias_Impl_Trait_227 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\mutator_type_alias_impl_trait_227.rs"
    },
    {
        "mutator_name": "Mutator_Type_Alias_Impl_Trait_242",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Mutator_Type_Alias_Impl_Trait_242_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:74:54\n   |\n74 | ...                   impl_item.trait_ = Some((impl_item.defaultness, path.clone(), impl_item.generics.clone()));\n   |                                                ^^^^^^^^^^^^^^^^^^^^^ expected `Option<Not>`, found `Option<Default>`\n   |\n   = note: expected enum `Option<syn::token::Not>`\n              found enum `Option<syn::token::Default>`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:74:91\n   |\n74 | ...                   impl_item.trait_ = Some((impl_item.defaultness, path.clone(), impl_item.generics.clone()));\n   |                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `For`, found `Generics`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mutator_Type_Alias_Impl_Trait_242_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:38:35\n   |\n38 |             let new_trait: Item = parse_quote! {\n   |                                   ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:43:40\n   |\n43 |             let impl_new_trait: Item = parse_quote! {\n   |                                        ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:52:61\n   |\n52 | ...                   let new_bound: TypeParamBound = parse_quote!(#new_trait_ident);\n   |                                                       ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:53:79\n   |\n53 | ...                   impl_item.generics.params.push(GenericParam::Type(parse_quote!(T: #new_trait_ident)));\n   |                                                                         ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:15:20\n   |\n15 |             if let Item::Type(type_item) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:16:24\n   |\n16 |                 if let Type::ImplTrait(type_impl_trait) = *type_item.ty.clone() {\n   |                        ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TypeParamBound`\n  --> src\\main.rs:18:32\n   |\n18 |                         if let TypeParamBound::Trait(trait_bound) = first_bound {\n   |                                ^^^^^^^^^^^^^^ use of undeclared type `TypeParamBound`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TypeParamBound;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:30:24\n   |\n30 |                 if let Item::Trait(trait_item) = item {\n   |                        ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:37:35\n   |\n37 |             let new_trait_ident = Ident::new(\"NewTrait\", Span::call_site());\n   |                                   ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:37:58\n   |\n37 |             let new_trait_ident = Ident::new(\"NewTrait\", Span::call_site());\n   |                                                          ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0412]: cannot find type `Item` in this scope\n  --> src\\main.rs:38:28\n   |\n38 |             let new_trait: Item = parse_quote! {\n   |                            ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0412]: cannot find type `Item` in this scope\n  --> src\\main.rs:43:33\n   |\n43 |             let impl_new_trait: Item = parse_quote! {\n   |                                 ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:49:24\n   |\n49 |                 if let Item::Impl(impl_item) = item {\n   |                        ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0412]: cannot find type `TypeParamBound` in this scope\n  --> src\\main.rs:52:44\n   |\n52 | ...                   let new_bound: TypeParamBound = parse_quote!(#new_trait_ident);\n   |                                      ^^^^^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TypeParamBound;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericParam`\n  --> src\\main.rs:53:60\n   |\n53 | ...                   impl_item.generics.params.push(GenericParam::Type(parse_quote!(T: #new_trait_ident)));\n   |                                                      ^^^^^^^^^^^^ use of undeclared type `GenericParam`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Punctuated`\n  --> src\\main.rs:54:99\n   |\n54 | ...                   impl_item.trait_ = Some((impl_item.defaultness.clone(), path.clone(), Punctuated::new()));\n   |                                                                                             ^^^^^^^^^^ use of undeclared type `Punctuated`\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::punctuated::Punctuated;\n   |\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 16 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mutator_Type_Alias_Impl_Trait_242_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:7:6\n  |\n7 | impl Mutator for Mutator_Type_Alias_Impl_Trait_242 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mutator_Type_Alias_Impl_Trait_242_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:57:54\n   |\n57 | ...                   impl_item.trait_ = Some((impl_item.defaultness.clone(), path.clone(), Punctuated::new()));\n   |                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Option<Not>`, found `Option<Default>`\n   |\n   = note: expected enum `Option<syn::token::Not>`\n              found enum `Option<syn::token::Default>`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:57:99\n   |\n57 | ...                   impl_item.trait_ = Some((impl_item.defaultness.clone(), path.clone(), Punctuated::new()));\n   |                                                                                             ^^^^^^^^^^^^^^^^^ expected `For`, found `Punctuated<_, _>`\n   |\n   = note: expected struct `For`\n              found struct `syn::punctuated::Punctuated<_, _>`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mutator_Type_Alias_Impl_Trait_242_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:57:74\n   |\n57 | ...                   impl_item.trait_ = Some((None, path.clone(), None));\n   |                                                                    ^^^^ expected `For`, found `Option<_>`\n   |\n   = note: expected struct `For`\n                found enum `Option<_>`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mutator_Type_Alias_Impl_Trait_242_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:57:74\n   |\n57 | ...                   impl_item.trait_ = Some((None, path.clone(), None));\n   |                                                                    ^^^^ expected `For`, found `Option<_>`\n   |\n   = note: expected struct `For`\n                found enum `Option<_>`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\mutator_type_alias_impl_trait_242.rs"
    },
    {
        "mutator_name": "Mutator_Union_Const_Generics_152",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\mutator_union_const_generics_152.rs"
    },
    {
        "mutator_name": "Omit_Trait_Methods_136",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Omit_Trait_Methods_136_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0502]: cannot borrow `file.items` as immutable because it is also borrowed as mutable\n  --> src\\main.rs:36:49\n   |\n30 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     mutable borrow occurs here\n   |                     mutable borrow later used here\n...\n36 |                     let trait_methods: Vec<_> = file.items.iter().filter_map(|i| {\n   |                                                 ^^^^^^^^^^ immutable borrow occurs here\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Omit_Trait_Methods_136_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Trait(item_trait) = i {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:19:20\n   |\n19 |             if let Item::Impl(item_impl) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nFor more information about this error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Omit_Trait_Methods_136_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Omit_Trait_Methods_136 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\omit_trait_methods_136.rs"
    },
    {
        "mutator_name": "Recursive_Trait_Method_Call_229",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Recursive_Trait_Method_Call_229_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `TraitItem` in the current scope\n  --> src\\main.rs:37:44\n   |\n37 |                     if let syn::TraitItem::Method(method) = item {\n   |                                            ^^^^^^ variant or associated item not found in `TraitItem`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:49:43\n   |\n49 |                     if let syn::ImplItem::Method(method) = item {\n   |                                           ^^^^^^ variant or associated item not found in `ImplItem`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:68:55\n   |\n68 | ...                   if let syn::ImplItem::Method(method) = item {\n   |                                             ^^^^^^ variant or associated item not found in `ImplItem`\n\nerror[E0061]: this enum variant takes 2 arguments but 1 argument was supplied\n  --> src\\main.rs:70:65\n   |\n70 | ...                   method.block.stmts.push(Stmt::Expr(new_method_call.clone()));\n   |                                               ^^^^^^^^^^------------------------- argument #2 of type `Option<Semi>` is missing\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:9\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |         ^^^^\nhelp: provide the argument\n   |\n70 |                                         method.block.stmts.push(Stmt::Expr(new_method_call.clone(), /* Option<Semi> */));\n   |                                                                                                   ++++++++++++++++++++\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Recursive_Trait_Method_Call_229_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n  --> src\\main.rs:21:39\n   |\n21 |         let mut async_trait_methods = HashSet::new();\n   |                                       ^^^^^^^ use of undeclared type `HashSet`\n   |\nhelp: consider importing this struct\n   |\n1  + use std::collections::HashSet;\n   |\n\nFor more information about this error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Recursive_Trait_Method_Call_229_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:40:45\n   |\n40 |                 let new_method_call: Expr = parse_quote! {\n   |                                             ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Recursive_Trait_Method_Call_229 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:15:20\n   |\n15 |             if let Item::Trait(item_trait) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TraitItem`\n  --> src\\main.rs:17:28\n   |\n17 |                     if let TraitItem::Fn(method) = item {\n   |                            ^^^^^^^^^ use of undeclared type `TraitItem`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TraitItem;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:27:20\n   |\n27 |             if let Item::Impl(item_impl) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `ImplItem`\n  --> src\\main.rs:29:28\n   |\n29 |                     if let ImplItem::Fn(method) = item {\n   |                            ^^^^^^^^ use of undeclared type `ImplItem`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::ImplItem;\n   |\n\nerror[E0412]: cannot find type `Expr` in this scope\n  --> src\\main.rs:40:38\n   |\n40 |                 let new_method_call: Expr = parse_quote! {\n   |                                      ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:45:28\n   |\n45 |                     if let Item::Impl(item_impl) = item {\n   |                            ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `ImplItem`\n  --> src\\main.rs:48:40\n   |\n48 | ...                   if let ImplItem::Fn(method) = item {\n   |                              ^^^^^^^^ use of undeclared type `ImplItem`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::ImplItem;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:50:65\n   |\n50 | ...                   method.block.stmts.push(Stmt::Expr(new_method_call.clone()));\n   |                                               ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nSome errors have detailed explanations: E0405, E0412, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 10 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Recursive_Trait_Method_Call_229_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n  --> src\\main.rs:13:39\n   |\n13 |         let mut async_trait_methods = HashSet::new();\n   |                                       ^^^^^^^ use of undeclared type `HashSet`\n   |\nhelp: consider importing this struct\n   |\n1  + use std::collections::HashSet;\n   |\n\nerror[E0061]: this enum variant takes 2 arguments but 1 argument was supplied\n  --> src\\main.rs:51:65\n   |\n51 | ...                   method.block.stmts.push(Stmt::Expr(new_method_call.clone()));\n   |                                               ^^^^^^^^^^------------------------- argument #2 of type `Option<Semi>` is missing\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:9\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |         ^^^^\nhelp: provide the argument\n   |\n51 |                                         method.block.stmts.push(Stmt::Expr(new_method_call.clone(), /* Option<Semi> */));\n   |                                                                                                   ++++++++++++++++++++\n\nSome errors have detailed explanations: E0061, E0433.\nFor more information about an error, try `rustc --explain E0061`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Recursive_Trait_Method_Call_229_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:6:6\n  |\n6 | impl Mutator for Recursive_Trait_Method_Call_229 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Recursive_Trait_Method_Call_229_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0061]: this enum variant takes 2 arguments but 1 argument was supplied\n  --> src\\main.rs:52:65\n   |\n52 | ...                   method.block.stmts.push(Stmt::Expr(new_method_call.clone()));\n   |                                               ^^^^^^^^^^------------------------- argument #2 of type `Option<Semi>` is missing\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:9\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |         ^^^^\nhelp: provide the argument\n   |\n52 |                                         method.block.stmts.push(Stmt::Expr(new_method_call.clone(), /* Option<Semi> */));\n   |                                                                                                   ++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0061`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\recursive_trait_method_call_229.rs"
    },
    {
        "mutator_name": "Remove_Type_Parameter_129",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Remove_Type_Parameter_129_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:35:51\n   |\n35 | ...                   if let syn::ImplItem::Method(method) = impl_item {\n   |                                             ^^^^^^ variant or associated item not found in `ImplItem`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Remove_Type_Parameter_129_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:36:40\n   |\n36 | ...                   if let Some((_, ref generics, _)) = &method.sig.generics.split_for_impl() {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^   ------------------------------------- this expression has type `&(ImplGenerics<'_>, TypeGenerics<'_>, Option<&WhereClause>)`\n   |                              |\n   |                              expected `(ImplGenerics<'_>, ..., ...)`, found `Option<_>`\n   |\n   = note: expected tuple `(ImplGenerics<'_>, TypeGenerics<'_>, Option<&WhereClause>)`\n               found enum `Option<_>`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\remove_type_parameter_129.rs"
    },
    {
        "mutator_name": "Rename_Macro_Identifiers_95",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Rename_Macro_Identifiers_95_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:34:29\n   |\n34 |                 if let Some((_, ref mut tokens)) = i.mac.tokens.clone().into_iter().next() {\n   |                             ^^^^^^^^^^^^^^^^^^^    --------------------------------------- this expression has type `Option<TokenTree>`\n   |                             |\n   |                             expected `TokenTree`, found `(_, _)`\n   |\n   = note: expected enum `TokenTree`\n             found tuple `(_, _)`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\rename_macro_identifiers_95.rs"
    },
    {
        "mutator_name": "Replace_Array_Length_With_Closure_15",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Replace_Array_Length_With_Closure_15_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:34:37\n   |\n34 |                         if let Some((_, ref mut expr)) = local.init {\n   |                                     ^^^^^^^^^^^^^^^^^    ---------- this expression has type `Option<LocalInit>`\n   |                                     |\n   |                                     expected `LocalInit`, found `(_, _)`\n   |\n   = note: expected struct `LocalInit`\n               found tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:41:57\n   |\n41 | ...                   *len_expr = closure_expr;\n   |                       ---------   ^^^^^^^^^^^^ expected `&mut Expr`, found `Expr`\n   |                       |\n   |                       expected due to the type of this binding\n   |\nhelp: consider dereferencing here to assign to the mutably borrowed value\n   |\n41 |                                             **len_expr = closure_expr;\n   |                                             +\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Replace_Array_Length_With_Closure_15_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:29\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                             ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n31 -             if let Item::Fn(ref mut func) = item {\n31 +             if let Item::Fn(func) = item {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:33:40\n   |\n33 |                     if let Stmt::Local(ref mut local) = stmt {\n   |                                        ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:33:28\n   |\n33 |                     if let Stmt::Local(ref mut local) = stmt {\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n33 -                     if let Stmt::Local(ref mut local) = stmt {\n33 +                     if let Stmt::Local(local) = stmt {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:37:54\n   |\n37 | ...                   if let Expr::Lit(ref lit) = len_expr {\n   |                                        ^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:37:44\n   |\n37 | ...                   if let Expr::Lit(ref lit) = len_expr {\n   |                              ^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: make the implied reference patterns explicit\n   |\n37 |                                     if let &mut &mut Expr::Lit(ref lit) = len_expr {\n   |                                            +++++++++\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Replace_Array_Length_With_Closure_15_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:20:70\n   |\n20 | ...                   let closure_expr: Expr = parse_quote!(|| #int_value);\n   |                                                ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Fn(func) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:13:28\n   |\n13 |                     if let Stmt::Local(local) = stmt {\n   |                            ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `LocalInit` in this scope\n  --> src\\main.rs:14:37\n   |\n14 |                         if let Some(LocalInit { expr, .. }) = &mut local.init {\n   |                                     ^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::LocalInit;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:15:36\n   |\n15 | ...                   if let Expr::Array(array_expr) = &mut **expr {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:17:44\n   |\n17 | ...                   if let Expr::Lit(lit) = len_expr {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0412]: cannot find type `Expr` in this scope\n  --> src\\main.rs:20:63\n   |\n20 | ...                   let closure_expr: Expr = parse_quote!(|| #int_value);\n   |                                         ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nSome errors have detailed explanations: E0412, E0422, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 7 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Replace_Array_Length_With_Closure_15_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Replace_Array_Length_With_Closure_15 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\replace_array_length_with_closure_15.rs"
    },
    {
        "mutator_name": "Replace_Const_Function_Call_161",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Replace_Const_Function_Call_161_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0594]: cannot assign to `*expr`, which is behind a `&` reference\n  --> src\\main.rs:41:49\n   |\n41 | ...                   *expr = new_expr;\n   |                       ^^^^^ `expr` is a `&` reference, so the data it refers to cannot be written\n\nFor more information about this error, try `rustc --explain E0594`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Replace_Const_Function_Call_161_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:41:57\n   |\n41 | ...                   *expr = GenericArgument::Const(new_expr);\n   |                       -----   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Expr`, found `GenericArgument`\n   |                       |\n   |                       expected due to the type of this binding\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Replace_Const_Function_Call_161_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `args.args` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:35:40\n   |\n35 | ...                   for arg in &mut args.args {\n   |                                  ^^^^^^^^^^^^^^ `args` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Replace_Const_Function_Call_161_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `first_segment.arguments` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:34:70\n   |\n33 |                     if let Some(first_segment) = path.segments.first() {\n   |                                 ------------- consider changing this binding's type to be: `&mut PathSegment`\n34 |                         if let PathArguments::AngleBracketed(args) = &mut first_segment.arguments {\n   |                                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `first_segment` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Replace_Const_Function_Call_161_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `path.segments` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:33:50\n   |\n33 |                     if let Some(first_segment) = path.segments.first_mut() {\n   |                                                  ^^^^^^^^^^^^^ `path` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\replace_const_function_call_161.rs"
    },
    {
        "mutator_name": "Replace_Const_Generic_With_Non_Supported_Type_198",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Replace_Const_Generic_With_Non_Supported_Type_198_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:36:24\n   |\n36 |                 if let Some((_, generics, _)) = &mut i.generics.split_for_impl() {\n   |                        ^^^^^^^^^^^^^^^^^^^^^^   -------------------------------- this expression has type `&mut (ImplGenerics<'_>, TypeGenerics<'_>, Option<&WhereClause>)`\n   |                        |\n   |                        expected `(ImplGenerics<'_>, ..., ...)`, found `Option<_>`\n   |\n   = note: expected tuple `(ImplGenerics<'_>, TypeGenerics<'_>, Option<&WhereClause>)`\n               found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:50:24\n   |\n50 |                 if let Some((_, generics, _)) = &mut i.sig.generics.split_for_impl() {\n   |                        ^^^^^^^^^^^^^^^^^^^^^^   ------------------------------------ this expression has type `&mut (ImplGenerics<'_>, TypeGenerics<'_>, Option<&WhereClause>)`\n   |                        |\n   |                        expected `(ImplGenerics<'_>, ..., ...)`, found `Option<_>`\n   |\n   = note: expected tuple `(ImplGenerics<'_>, TypeGenerics<'_>, Option<&WhereClause>)`\n               found enum `Option<_>`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\replace_const_generic_with_non_supported_type_198.rs"
    },
    {
        "mutator_name": "Replace_Impl_Trait_237",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Replace_Impl_Trait_237_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `segment.arguments.0` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:39:74\n   |\n36 | ...                   if let Some(segment) = trait_bound.path.segments.last() {\n   |                                   ------- consider changing this binding's type to be: `&mut PathSegment`\n...\n39 | ...                           if let PathArguments::AngleBracketed(ref mut args) = segment.arguments {\n   |                                                                    ^^^^^^^^^^^^ `segment` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Replace_Impl_Trait_237_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `trait_bound.path.segments` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:36:52\n   |\n36 | ...                   if let Some(segment) = trait_bound.path.segments.last_mut() {\n   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^ `trait_bound` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\replace_impl_trait_237.rs"
    },
    {
        "mutator_name": "Replace_Impl_Trait_Alias_82",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [],
        "label": "Negative",
        "file": ".\\mutators\\replace_impl_trait_alias_82.rs"
    },
    {
        "mutator_name": "Replace_Unsized_Types_25",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\replace_unsized_types_25.rs"
    },
    {
        "mutator_name": "Struct_Field_Pattern_Assignment_12",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Struct_Field_Pattern_Assignment_12_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:36:24\n   |\n36 |                 if let Some(body) = i.body.as_mut() {\n   |                        ^^^^^^^^^^   --------------- this expression has type `&mut syn::Expr`\n   |                        |\n   |                        expected `Expr`, found `Option<_>`\n   |\n   = note: expected enum `syn::Expr`\n              found enum `Option<_>`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Struct_Field_Pattern_Assignment_12_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:18:57\n   |\n18 | ...                   let new_pattern: Expr = parse_quote! { S(x) };\n   |                                               ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:3:6\n  |\n3 | impl Mutator for Struct_Field_Pattern_Assignment_12 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nerror[E0412]: cannot find type `Expr` in this scope\n --> src\\main.rs:9:36\n  |\n9 |             mutations: &'a mut Vec<Expr>,\n  |                                    ^^^^ not found in this scope\n  |\nhelp: consider importing this enum\n  |\n1 + use syn::Expr;\n  |\n\nerror[E0405]: cannot find trait `VisitMut` in this scope\n  --> src\\main.rs:12:18\n   |\n12 |         impl<'a> VisitMut for ClosureVisitor<'a> {\n   |                  ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this trait\n   |\n1  + use syn::visit_mut::VisitMut;\n   |\n\nerror[E0412]: cannot find type `ExprClosure` in this scope\n  --> src\\main.rs:13:58\n   |\n13 |             fn visit_expr_closure_mut(&mut self, i: &mut ExprClosure) {\n   |                                                          ^^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::ExprClosure;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:14:24\n   |\n14 |                 if let Expr::Assign(assign_expr) = &mut *i.body {\n   |                        ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:15:28\n   |\n15 |                     if let Expr::Path(expr_path) = &*assign_expr.left {\n   |                            ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0412]: cannot find type `Expr` in this scope\n  --> src\\main.rs:18:50\n   |\n18 | ...                   let new_pattern: Expr = parse_quote! { S(x) };\n   |                                        ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `visit_mut`\n  --> src\\main.rs:25:17\n   |\n25 |                 visit_mut::visit_expr_closure_mut(self, i);\n   |                 ^^^^^^^^^ use of unresolved module or unlinked crate `visit_mut`\n   |\n   = help: if you wanted to use a crate named `visit_mut`, use `cargo add visit_mut` to add it to your `Cargo.toml`\nhelp: consider importing this module\n   |\n1  + use syn::visit_mut;\n   |\n\nSome errors have detailed explanations: E0405, E0412, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 9 previous errors\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\struct_field_pattern_assignment_12.rs"
    },
    {
        "mutator_name": "Swap_Const_Generics_73",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\swap_const_generics_73.rs"
    },
    {
        "mutator_name": "Swap_Const_Type_Generics_197",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\swap_const_type_generics_197.rs"
    },
    {
        "mutator_name": "Trait_Bound_Modification_110",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Trait_Bound_Modification_110_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:32\n   |\n31 |             if let Item::Trait(ref mut trait_item) = item {\n   |                                ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Trait(ref mut trait_item) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n31 -             if let Item::Trait(ref mut trait_item) = item {\n31 +             if let Item::Trait(trait_item) = item {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:33:50\n   |\n33 |                     if let TypeParamBound::Trait(ref mut trait_bound) = supertrait {\n   |                                                  ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:33:28\n   |\n33 |                     if let TypeParamBound::Trait(ref mut trait_bound) = supertrait {\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n33 -                     if let TypeParamBound::Trait(ref mut trait_bound) = supertrait {\n33 +                     if let TypeParamBound::Trait(trait_bound) = supertrait {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:37:66\n   |\n37 | ...                   if let GenericArgument::Type(ref mut ty) = arg {\n   |                                                    ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:37:44\n   |\n37 | ...                   if let GenericArgument::Type(ref mut ty) = arg {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n37 -                                     if let GenericArgument::Type(ref mut ty) = arg {\n37 +                                     if let GenericArgument::Type(ty) = arg {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Trait_Bound_Modification_110_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:19:47\n   |\n19 | ...                   *ty = parse_quote!(i32);\n   |                             ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Trait(trait_item) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TypeParamBound`\n  --> src\\main.rs:13:28\n   |\n13 |                     if let TypeParamBound::Trait(trait_bound) = supertrait {\n   |                            ^^^^^^^^^^^^^^ use of undeclared type `TypeParamBound`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TypeParamBound;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `PathArguments`\n  --> src\\main.rs:15:36\n   |\n15 | ...                   if let PathArguments::AngleBracketed(args) = &mut path_segment.arguments {\n   |                              ^^^^^^^^^^^^^ use of undeclared type `PathArguments`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::PathArguments;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericArgument`\n  --> src\\main.rs:17:44\n   |\n17 | ...                   if let GenericArgument::Type(ty) = arg {\n   |                              ^^^^^^^^^^^^^^^ use of undeclared type `GenericArgument`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericArgument;\n   |\n\nFor more information about this error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 5 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Trait_Bound_Modification_110_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:9:6\n  |\n9 | impl Mutator for Trait_Bound_Modification_110 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\trait_bound_modification_110.rs"
    },
    {
        "mutator_name": "Trait_Const_Generic_63",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Trait_Const_Generic_63_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0499]: cannot borrow `file.items` as mutable more than once at a time\n  --> src\\main.rs:43:21\n   |\n30 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     first mutable borrow occurs here\n   |                     first borrow later used here\n...\n43 |                     file.items.push(impl_block);\n   |                     ^^^^^^^^^^ second mutable borrow occurs here\n\nerror[E0499]: cannot borrow `file.items` as mutable more than once at a time\n  --> src\\main.rs:50:21\n   |\n30 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     first mutable borrow occurs here\n   |                     first borrow later used here\n...\n50 |                     file.items.push(use_trait_fn);\n   |                     ^^^^^^^^^^ second mutable borrow occurs here\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\trait_const_generic_63.rs"
    },
    {
        "mutator_name": "Transform_Static_To_Mutable_Static_30",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Transform_Static_To_Mutable_Static_30_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `is_none` found for enum `StaticMutability` in the current scope\n  --> src\\main.rs:32:43\n   |\n32 |                 if item_static.mutability.is_none() {\n   |                                           ^^^^^^^ method not found in `StaticMutability`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:33:46\n   |\n33 |                     item_static.mutability = Some(token::Mut::default());\n   |                     ----------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `StaticMutability`, found `Option<Mut>`\n   |                     |\n   |                     expected due to the type of this binding\n   |\n   = note: expected enum `StaticMutability`\n              found enum `Option<syn::token::Mut>`\n\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:61:25\n   |\n61 |                         *usage = unsafe_block;\n   |                         ^^^^^^ can't be dereferenced\n\nSome errors have detailed explanations: E0308, E0599, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Transform_Static_To_Mutable_Static_30_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:61:25\n   |\n61 |                         *usage = unsafe_block.clone();\n   |                         ^^^^^^ can't be dereferenced\n\nFor more information about this error, try `rustc --explain E0614`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Transform_Static_To_Mutable_Static_30_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0502]: cannot borrow `*file` as immutable because it is also borrowed as mutable\n  --> src\\main.rs:55:39\n   |\n30 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     mutable borrow occurs here\n   |                     mutable borrow later used here\n...\n55 |                     finder.visit_file(file);\n   |                                       ^^^^ immutable borrow occurs here\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Transform_Static_To_Mutable_Static_30_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:42:38\n   |\n42 |             let unsafe_block: Expr = parse_quote! {\n   |                                      ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:13:20\n   |\n13 |             if let Item::Static(item_static) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `StaticMutability`\n  --> src\\main.rs:14:53\n   |\n14 |                 if matches!(item_static.mutability, StaticMutability::None) {\n   |                                                     ^^^^^^^^^^^^^^^^ use of undeclared type `StaticMutability`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::StaticMutability;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `StaticMutability`\n  --> src\\main.rs:15:46\n   |\n15 |                     item_static.mutability = StaticMutability::Mut(token::Mut::default());\n   |                                              ^^^^^^^^^^^^^^^^ use of undeclared type `StaticMutability`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::StaticMutability;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `token`\n  --> src\\main.rs:15:68\n   |\n15 |                     item_static.mutability = StaticMutability::Mut(token::Mut::default());\n   |                                                                    ^^^^^ use of unresolved module or unlinked crate `token`\n   |\n   = help: if you wanted to use a crate named `token`, use `cargo add token` to add it to your `Cargo.toml`\nhelp: consider importing this struct\n   |\n1  + use syn::token::Mut;\n   |\nhelp: if you import `Mut`, refer to it directly\n   |\n15 -                     item_static.mutability = StaticMutability::Mut(token::Mut::default());\n15 +                     item_static.mutability = StaticMutability::Mut(Mut::default());\n   |\n\nerror[E0412]: cannot find type `Ident` in this scope\n  --> src\\main.rs:20:36\n   |\n20 |                         ident: &'a Ident,\n   |                                    ^^^^^ not found in this scope\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nerror[E0412]: cannot find type `Expr` in this scope\n  --> src\\main.rs:21:45\n   |\n21 |                         usages: &'a mut Vec<Expr>,\n   |                                             ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0405]: cannot find trait `Visit` in this scope\n  --> src\\main.rs:24:30\n   |\n24 |                     impl<'a> Visit<'_> for FindUsages<'a> {\n   |                              ^^^^^ not found in this scope\n   |\nhelp: consider importing this trait\n   |\n1  + use syn::visit::Visit;\n   |\n\nerror[E0412]: cannot find type `Expr` in this scope\n  --> src\\main.rs:25:57\n   |\n25 |                         fn visit_expr(&mut self, expr: &Expr) {\n   |                                                         ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:26:36\n   |\n26 | ...                   if let Expr::Path(ExprPath { path, .. }) = expr {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `ExprPath` in this scope\n  --> src\\main.rs:26:47\n   |\n26 | ...                   if let Expr::Path(ExprPath { path, .. }) = expr {\n   |                                         ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::ExprPath;\n   |\n\nerror[E0412]: cannot find type `Expr` in this scope\n  --> src\\main.rs:42:31\n   |\n42 |             let unsafe_block: Expr = parse_quote! {\n   |                               ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nSome errors have detailed explanations: E0405, E0412, E0422, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 12 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Transform_Static_To_Mutable_Static_30_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n  --> src\\main.rs:12:6\n   |\n12 | impl Mutator for Transform_Static_To_Mutable_Static_30 {\n   |      ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this trait\n   |\n1  + use crate::mutator::Mutator;\n   |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Transform_Static_To_Mutable_Static_30_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:23:46\n   |\n23 |                     item_static.mutability = Some(Mut::default());\n   |                     ----------------------   ^^^^^^^^^^^^^^^^^^^^ expected `StaticMutability`, found `Option<Mut>`\n   |                     |\n   |                     expected due to the type of this binding\n   |\n   = note: expected enum `StaticMutability`\n              found enum `Option<syn::token::Mut>`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Transform_Static_To_Mutable_Static_30_compling_err_7.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `is_none` found for enum `StaticMutability` in the current scope\n  --> src\\main.rs:22:43\n   |\n22 |                 if item_static.mutability.is_none() {\n   |                                           ^^^^^^^ method not found in `StaticMutability`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:23:46\n   |\n23 |                     item_static.mutability = Some(StaticMutability::Mut(Mut::default()));\n   |                     ----------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `StaticMutability`, found `Option<StaticMutability>`\n   |                     |\n   |                     expected due to the type of this binding\n   |\n   = note: expected enum `StaticMutability`\n              found enum `Option<StaticMutability>`\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Transform_Static_To_Mutable_Static_30_compling_err_8.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0502]: cannot borrow `*file` as immutable because it is also borrowed as mutable\n  --> src\\main.rs:44:39\n   |\n20 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     mutable borrow occurs here\n   |                     mutable borrow later used here\n...\n44 |                     finder.visit_file(&*file);\n   |                                       ^^^^^^ immutable borrow occurs here\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Transform_Static_To_Mutable_Static_30_compling_err_9.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0502]: cannot borrow `*file` as immutable because it is also borrowed as mutable\n  --> src\\main.rs:45:39\n   |\n19 |         let items = &mut file.items;\n   |                     --------------- mutable borrow occurs here\n20 |\n21 |         for item in items.iter_mut() {\n   |                     ---------------- mutable borrow later used here\n...\n45 |                     finder.visit_file(file);\n   |                                       ^^^^ immutable borrow occurs here\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\transform_static_to_mutable_static_30.rs"
    },
    {
        "mutator_name": "Transform_Thread_Local_Storage_101",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Transform_Thread_Local_Storage_101_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0277]: the trait bound `syn::punctuated::Punctuated<Stmt, Semi>: Parse` is not satisfied\n   --> src\\main.rs:34:63\n    |\n34  |                         if let Ok(mut tokens) = syn::parse2::<Punctuated<syn::Stmt, token::Semi>>(item_macro.mac.tokens.clone()) {\n    |                                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Parse` is not implemented for `syn::punctuated::Punctuated<Stmt, Semi>`\n    |\n    = help: the following other types implement trait `Parse`:\n              Abstract\n              AndAnd\n              AndEq\n              AngleBracketedGenericArguments\n              Arm\n              As\n              At\n              Auto\n            and 248 others\nnote: required by a bound in `syn::parse2`\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\lib.rs:920:18\n    |\n920 | pub fn parse2<T: parse::Parse>(tokens: proc_macro2::TokenStream) -> Result<T> {\n    |                  ^^^^^^^^^^^^ required by this bound in `parse2`\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\transform_thread_local_storage_101.rs"
    },
    {
        "mutator_name": "Unused_Generic_Type_Parameter_80",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\unused_generic_type_parameter_80.rs"
    },
        {
        "mutator_name": "Add_Const_Parameter_390",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\add_const_parameter_390.rs"
    },
    {
        "mutator_name": "Add_Const_Parameter_402",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Add_Const_Parameter_402_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0282]: type annotations needed for `Vec<_>`\n  --> src\\main.rs:34:25\n   |\n34 |                     let mut new_predicates = Vec::new();\n   |                         ^^^^^^^^^^^^^^^^^^   ---------- type must be known at this point\n   |\nhelp: consider giving `new_predicates` an explicit type, where the type for type parameter `T` is specified\n   |\n34 |                     let mut new_predicates: Vec<T> = Vec::new();\n   |                                           ++++++++\n\nerror[E0283]: type annotations needed for `Vec<_>`\n  --> src\\main.rs:34:25\n   |\n34 |                     let mut new_predicates = Vec::new();\n   |                         ^^^^^^^^^^^^^^^^^^\n...\n54 |                     where_clause.predicates.extend(new_predicates);\n   |                                             ------ type must be known at this point\n   |\n   = note: multiple `impl`s satisfying `syn::punctuated::Punctuated<WherePredicate, syn::token::Comma>: Extend<_>` found in the `syn` crate:\n           - impl<T, P> Extend<Pair<T, P>> for syn::punctuated::Punctuated<T, P>\n             where P: std::default::Default;\n           - impl<T, P> Extend<T> for syn::punctuated::Punctuated<T, P>\n             where P: std::default::Default;\nhelp: consider giving `new_predicates` an explicit type, where the type for type parameter `A` is specified\n   |\n34 |                     let mut new_predicates: Vec<T> = Vec::new();\n   |                                           ++++++++\n\nSome errors have detailed explanations: E0282, E0283.\nFor more information about an error, try `rustc --explain E0282`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Add_Const_Parameter_402_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:26:60\n   |\n26 | ...                   let new_const_expr: Expr = parse_quote!({ NP - 2 });\n   |                                                  ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:27:71\n   |\n27 | ...                   let new_generic_param: GenericParam = parse_quote!(const #new_const_ident: usize = #new_const_expr);\n   |                                                             ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:30:53\n   |\n30 | ...                   new_predicates.push(parse_quote!(#new_const_ident: Copy));\n   |                                           ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Add_Const_Parameter_402 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:12:20\n   |\n12 |             if let Item::Fn(ref mut func) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TypeParamBound`\n  --> src\\main.rs:18:40\n   |\n18 | ...                   if let TypeParamBound::Trait(trait_bound) = bound {\n   |                              ^^^^^^^^^^^^^^ use of undeclared type `TypeParamBound`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TypeParamBound;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:25:55\n   |\n25 | ...                   let new_const_ident = Ident::new(\"NM\", Span::call_site());\n   |                                             ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:25:72\n   |\n25 | ...                   let new_const_ident = Ident::new(\"NM\", Span::call_site());\n   |                                                              ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0412]: cannot find type `Expr` in this scope\n  --> src\\main.rs:26:53\n   |\n26 | ...                   let new_const_expr: Expr = parse_quote!({ NP - 2 });\n   |                                           ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0412]: cannot find type `GenericParam` in this scope\n  --> src\\main.rs:27:56\n   |\n27 | ...                   let new_generic_param: GenericParam = parse_quote!(const #new_const_ident: usize = #new_const_expr);\n   |                                              ^^^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nSome errors have detailed explanations: E0405, E0412, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 10 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Add_Const_Parameter_402_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0412]: cannot find type `WherePredicate` in this scope\n  --> src\\main.rs:21:49\n   |\n21 |                     let mut new_predicates: Vec<WherePredicate> = Vec::new();\n   |                                                 ^^^^^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::WherePredicate;\n   |\n\nFor more information about this error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Add_Const_Parameter_402_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:20:29\n   |\n20 |             if let Item::Fn(ref mut func) = item {\n   |                             ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:20:20\n   |\n20 |             if let Item::Fn(ref mut func) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n20 -             if let Item::Fn(ref mut func) = item {\n20 +             if let Item::Fn(func) = item {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\add_const_parameter_402.rs"
    },
    {
        "mutator_name": "Add_Enum_Variant_437",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\add_enum_variant_437.rs"
    },
    {
        "mutator_name": "Add_Parameter_With_Lifetime_And_Trait_Bound_250",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\add_parameter_with_lifetime_and_trait_bound_250.rs"
    },
    {
        "mutator_name": "Alter_Dyn_To_Ref_393",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\alter_dyn_to_ref_393.rs"
    },
    {
        "mutator_name": "Alter_Enum_Variants_With_Mismatched_Types_365",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Alter_Enum_Variants_With_Mismatched_Types_365_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:37:28\n   |\n37 |                     if let Some((_, fields)) = &variant.fields {\n   |                            ^^^^^^^^^^^^^^^^^   --------------- this expression has type `&Fields`\n   |                            |\n   |                            expected `Fields`, found `Option<_>`\n   |\n   = note: expected enum `Fields`\n              found enum `Option<_>`\n\nerror[E0282]: type annotations needed\n  --> src\\main.rs:38:35\n   |\n38 |                         if fields.len() > 0 {\n   |                                   ^^^ cannot infer type\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:56:51\n   |\n56 | ...                   if let Stmt::Expr(Expr::Match(expr_match)) = stmt {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n56 |                                 if let Stmt::Expr(Expr::Match(expr_match), _) = stmt {\n   |                                                                          +++\n\nSome errors have detailed explanations: E0023, E0282, E0308.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Enum_Variants_With_Mismatched_Types_365_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0499]: cannot borrow `file.items` as mutable more than once at a time\n  --> src\\main.rs:53:33\n   |\n31 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     first mutable borrow occurs here\n   |                     first borrow later used here\n...\n53 |                     for item in &mut file.items {\n   |                                 ^^^^^^^^^^^^^^^ second mutable borrow occurs here\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Enum_Variants_With_Mismatched_Types_365_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:59:43\n   |\n59 |                         if let Stmt::Expr(Expr::Match(expr_match)) = stmt {\n   |                                           ^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n59 |                         if let Stmt::Expr(Expr::Match(expr_match), _) = stmt {\n   |                                                                  +++\n\nFor more information about this error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\alter_enum_variants_with_mismatched_types_365.rs"
    },
    {
        "mutator_name": "Alter_Function_Return_Types_342",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Alter_Function_Return_Types_342_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:40:56\n   |\n40 | ...                   *inner_type_path = new_type;\n   |                       ----------------   ^^^^^^^^ expected `TypePath`, found `Type`\n   |                       |\n   |                       expected due to the type of this binding\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Function_Return_Types_342_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `last_segment.arguments.0` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:37:66\n   |\n37 | ...                   if let PathArguments::AngleBracketed(ref mut args) = last_segment.arguments {\n   |                                                            ^^^^^^^^^^^^ `last_segment` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n   |\nhelp: consider specifying this binding's type\n   |\n35 |                         let last_segment: &mut PathSegment = type_path.path.segments.last().unwrap();\n   |                                         ++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Function_Return_Types_342_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:19:62\n   |\n19 | ...                   let new_type: Type = parse_quote! { Option<#inner_type_path> };\n   |                                            ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:12:20\n   |\n12 |             if let Item::Fn(item_fn) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `ReturnType`\n  --> src\\main.rs:13:24\n   |\n13 |                 if let ReturnType::Type(_, ref mut ret_type) = item_fn.sig.output {\n   |                        ^^^^^^^^^^ use of undeclared type `ReturnType`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::ReturnType;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:14:28\n   |\n14 |                     if let Type::Path(type_path) = &mut **ret_type {\n   |                            ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `PathArguments`\n  --> src\\main.rs:17:40\n   |\n17 | ...                   if let PathArguments::AngleBracketed(ref mut args) = last_segment.arguments {\n   |                              ^^^^^^^^^^^^^ use of undeclared type `PathArguments`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::PathArguments;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericArgument`\n  --> src\\main.rs:18:49\n   |\n18 | ...                   if let Some(GenericArgument::Type(Type::Path(inner_type_path))) = args.args.first_mut() {\n   |                                   ^^^^^^^^^^^^^^^ use of undeclared type `GenericArgument`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericArgument;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:18:71\n   |\n18 | ...                   if let Some(GenericArgument::Type(Type::Path(inner_type_path))) = args.args.first_mut() {\n   |                                                         ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0412]: cannot find type `Type` in this scope\n  --> src\\main.rs:19:55\n   |\n19 | ...                   let new_type: Type = parse_quote! { Option<#inner_type_path> };\n   |                                     ^^^^ not found in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:20:67\n   |\n20 | ...                   *inner_type_path = if let Type::Path(type_path) = new_type {\n   |                                                 ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 9 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Function_Return_Types_342_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n  --> src\\main.rs:10:6\n   |\n10 | impl Mutator for Alter_Function_Return_Types_342 {\n   |      ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this trait\n   |\n1  + use crate::mutator::Mutator;\n   |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\alter_function_return_types_342.rs"
    },
    {
        "mutator_name": "Alter_Function_Signature_260",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Alter_Function_Signature_260_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `syn::TraitItem` in the current scope\n  --> src\\main.rs:34:39\n   |\n34 |                     if let TraitItem::Method(method) = item {\n   |                                       ^^^^^^ variant or associated item not found in `TraitItem`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Function_Signature_260_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0432]: unresolved import `syn::TraitItemMethod`\n  --> src\\main.rs:19:16\n   |\n19 |     TraitItem, TraitItemMethod,\n   |                ^^^^^^^^^^^^^^^\n   |                |\n   |                no `TraitItemMethod` in the root\n   |                help: a similar name exists in the module: `TraitItemMacro`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `TraitItem` in the current scope\n  --> src\\main.rs:35:39\n   |\n35 |                     if let TraitItem::Method(method) = item {\n   |                                       ^^^^^^ variant or associated item not found in `TraitItem`\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\alter_function_signature_260.rs"
    },
    {
        "mutator_name": "Alter_Trait_Bounds_396",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Alter_Trait_Bounds_396_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0038]: the trait `Rng` is not dyn compatible\n   --> src\\main.rs:31:26\n    |\n31  |             rng: &'a mut dyn Rng,\n    |                          ^^^^^^^ `Rng` is not dyn compatible\n    |\nnote: for a trait to be dyn compatible it needs to allow building a vtable\n      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rand-0.8.5\\src\\rng.rs:93:8\n    |\n93  |     fn gen<T>(&mut self) -> T\n    |        ^^^ the trait is not dyn compatible because method `gen` has generic type parameters\n...\n129 |     fn gen_range<T, R>(&mut self, range: R) -> T\n    |        ^^^^^^^^^ the trait is not dyn compatible because method `gen_range` has generic type parameters\n...\n152 |     fn sample<T, D: Distribution<T>>(&mut self, distr: D) -> T {\n    |        ^^^^^^ the trait is not dyn compatible because method `sample` has generic type parameters\n...\n218 |     fn fill<T: Fill + ?Sized>(&mut self, dest: &mut T) {\n    |        ^^^^ the trait is not dyn compatible because method `fill` has generic type parameters\n...\n246 |     fn try_fill<T: Fill + ?Sized>(&mut self, dest: &mut T) -> Result<(), Error> {\n    |        ^^^^^^^^ the trait is not dyn compatible because method `try_fill` has generic type parameters\n\nerror[E0038]: the trait `Rng` is not dyn compatible\n   --> src\\main.rs:68:50\n    |\n68  |         let mut visitor = TypeCastVisitor { rng: &mut rng };\n    |                                                  ^^^^^^^^ `Rng` is not dyn compatible\n    |\nnote: for a trait to be dyn compatible it needs to allow building a vtable\n      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rand-0.8.5\\src\\rng.rs:93:8\n    |\n93  |     fn gen<T>(&mut self) -> T\n    |        ^^^ the trait is not dyn compatible because method `gen` has generic type parameters\n...\n129 |     fn gen_range<T, R>(&mut self, range: R) -> T\n    |        ^^^^^^^^^ the trait is not dyn compatible because method `gen_range` has generic type parameters\n...\n152 |     fn sample<T, D: Distribution<T>>(&mut self, distr: D) -> T {\n    |        ^^^^^^ the trait is not dyn compatible because method `sample` has generic type parameters\n...\n218 |     fn fill<T: Fill + ?Sized>(&mut self, dest: &mut T) {\n    |        ^^^^ the trait is not dyn compatible because method `fill` has generic type parameters\n...\n246 |     fn try_fill<T: Fill + ?Sized>(&mut self, dest: &mut T) -> Result<(), Error> {\n    |        ^^^^^^^^ the trait is not dyn compatible because method `try_fill` has generic type parameters\n    = note: required for the cast from `&mut ThreadRng` to `&mut dyn Rng`\n\nerror[E0038]: the trait `Rng` is not dyn compatible\n   --> src\\main.rs:68:50\n    |\n68  |         let mut visitor = TypeCastVisitor { rng: &mut rng };\n    |                                                  ^^^^^^^^ `Rng` is not dyn compatible\n    |\nnote: for a trait to be dyn compatible it needs to allow building a vtable\n      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rand-0.8.5\\src\\rng.rs:93:8\n    |\n93  |     fn gen<T>(&mut self) -> T\n    |        ^^^ the trait is not dyn compatible because method `gen` has generic type parameters\n...\n129 |     fn gen_range<T, R>(&mut self, range: R) -> T\n    |        ^^^^^^^^^ the trait is not dyn compatible because method `gen_range` has generic type parameters\n...\n152 |     fn sample<T, D: Distribution<T>>(&mut self, distr: D) -> T {\n    |        ^^^^^^ the trait is not dyn compatible because method `sample` has generic type parameters\n...\n218 |     fn fill<T: Fill + ?Sized>(&mut self, dest: &mut T) {\n    |        ^^^^ the trait is not dyn compatible because method `fill` has generic type parameters\n...\n246 |     fn try_fill<T: Fill + ?Sized>(&mut self, dest: &mut T) -> Result<(), Error> {\n    |        ^^^^^^^^ the trait is not dyn compatible because method `try_fill` has generic type parameters\n\nerror[E0038]: the trait `Rng` is not dyn compatible\n   --> src\\main.rs:41:32\n    |\n41  | ...                   if self.rng.gen_bool(0.5) {\n    |                          ^^^^^^^^^^^^^^^^^^^^^^ `Rng` is not dyn compatible\n    |\nnote: for a trait to be dyn compatible it needs to allow building a vtable\n      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rand-0.8.5\\src\\rng.rs:93:8\n    |\n93  |     fn gen<T>(&mut self) -> T\n    |        ^^^ the trait is not dyn compatible because method `gen` has generic type parameters\n...\n129 |     fn gen_range<T, R>(&mut self, range: R) -> T\n    |        ^^^^^^^^^ the trait is not dyn compatible because method `gen_range` has generic type parameters\n...\n152 |     fn sample<T, D: Distribution<T>>(&mut self, distr: D) -> T {\n    |        ^^^^^^ the trait is not dyn compatible because method `sample` has generic type parameters\n...\n218 |     fn fill<T: Fill + ?Sized>(&mut self, dest: &mut T) {\n    |        ^^^^ the trait is not dyn compatible because method `fill` has generic type parameters\n...\n246 |     fn try_fill<T: Fill + ?Sized>(&mut self, dest: &mut T) -> Result<(), Error> {\n    |        ^^^^^^^^ the trait is not dyn compatible because method `try_fill` has generic type parameters\n\nerror[E0038]: the trait `Rng` is not dyn compatible\n   --> src\\main.rs:47:40\n    |\n47  | ...                   if self.rng.gen_bool(0.5) {\n    |                          ^^^^^^^^^^^^^^^^^^^^^^ `Rng` is not dyn compatible\n    |\nnote: for a trait to be dyn compatible it needs to allow building a vtable\n      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rand-0.8.5\\src\\rng.rs:93:8\n    |\n93  |     fn gen<T>(&mut self) -> T\n    |        ^^^ the trait is not dyn compatible because method `gen` has generic type parameters\n...\n129 |     fn gen_range<T, R>(&mut self, range: R) -> T\n    |        ^^^^^^^^^ the trait is not dyn compatible because method `gen_range` has generic type parameters\n...\n152 |     fn sample<T, D: Distribution<T>>(&mut self, distr: D) -> T {\n    |        ^^^^^^ the trait is not dyn compatible because method `sample` has generic type parameters\n...\n218 |     fn fill<T: Fill + ?Sized>(&mut self, dest: &mut T) {\n    |        ^^^^ the trait is not dyn compatible because method `fill` has generic type parameters\n...\n246 |     fn try_fill<T: Fill + ?Sized>(&mut self, dest: &mut T) -> Result<(), Error> {\n    |        ^^^^^^^^ the trait is not dyn compatible because method `try_fill` has generic type parameters\n\nFor more information about this error, try `rustc --explain E0038`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 5 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\alter_trait_bounds_396.rs"
    },
    {
        "mutator_name": "Alter_Trait_Bounds_445",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Alter_Trait_Bounds_445_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n    --> src\\main.rs:40:39\n     |\n40   |                     i.items.insert(0, extra_trait);\n     |                             ------    ^^^^^^^^^^^ expected `ImplItem`, found `Item`\n     |                             |\n     |                             arguments to this method are incorrect\n     |\nnote: method defined here\n    --> C:\\Users\\love\\.rustup\\toolchains\\nightly-2025-05-10-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\alloc\\src\\vec\\mod.rs:2002:12\n     |\n2002 |     pub fn insert(&mut self, index: usize, element: T) {\n     |            ^^^^^^\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:49:32\n   |\n49 |                         if let Some(bounds) = &mut type_param.bounds {\n   |                                ^^^^^^^^^^^^   ---------------------- this expression has type `&mut syn::punctuated::Punctuated<TypeParamBound, syn::token::Plus>`\n   |                                |\n   |                                expected `Punctuated<TypeParamBound, Plus>`, found `Option<_>`\n   |\n   = note: expected struct `syn::punctuated::Punctuated<TypeParamBound, syn::token::Plus>`\n                found enum `Option<_>`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Trait_Bounds_445_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.86s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:37:49:\nexpected one of: `default`, `fn`, `const`, `type`, identifier, `self`, `super`, `crate`, `::`\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Trait_Bounds_445_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.73s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:37:49:\nexpected one of: `default`, `fn`, `const`, `type`, identifier, `self`, `super`, `crate`, `::`\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Trait_Bounds_445_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:15:49\n   |\n15 |                     let extra_trait: ImplItem = parse_quote! {\n   |                                                 ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:29:59\n   |\n29 |                         let extra_bound: TypeParamBound = parse_quote!(Extra);\n   |                                                           ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:3:6\n  |\n3 | impl Mutator for Alter_Trait_Bounds_445 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nerror[E0405]: cannot find trait `VisitMut` in this scope\n  --> src\\main.rs:12:14\n   |\n12 |         impl VisitMut for TraitBoundVisitor {\n   |              ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this trait\n   |\n1  + use syn::visit_mut::VisitMut;\n   |\n\nerror[E0412]: cannot find type `ItemImpl` in this scope\n  --> src\\main.rs:13:55\n   |\n13 |             fn visit_item_impl_mut(&mut self, i: &mut ItemImpl) {\n   |                                                       ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::ItemImpl;\n   |\n\nerror[E0412]: cannot find type `ImplItem` in this scope\n  --> src\\main.rs:15:38\n   |\n15 |                     let extra_trait: ImplItem = parse_quote! {\n   |                                      ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::ImplItem;\n   |\n\nerror[E0412]: cannot find type `ItemFn` in this scope\n  --> src\\main.rs:26:53\n   |\n26 |             fn visit_item_fn_mut(&mut self, i: &mut ItemFn) {\n   |                                                     ^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::ItemFn;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericParam`\n  --> src\\main.rs:28:28\n   |\n28 |                     if let GenericParam::Type(type_param) = param {\n   |                            ^^^^^^^^^^^^ use of undeclared type `GenericParam`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nerror[E0412]: cannot find type `TypeParamBound` in this scope\n  --> src\\main.rs:29:42\n   |\n29 |                         let extra_bound: TypeParamBound = parse_quote!(Extra);\n   |                                          ^^^^^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TypeParamBound;\n   |\n\nSome errors have detailed explanations: E0405, E0412, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 9 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Trait_Bounds_445_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `insert` found for mutable reference `&mut &mut [ImplItem]` in the current scope\n    --> src\\main.rs:23:31\n     |\n23   |                         items.insert(0, extra_trait);\n     |                               ^^^^^^\n     |\nhelp: there is a method `iter` with a similar name, but with different arguments\n    --> C:\\Users\\love\\.rustup\\toolchains\\nightly-2025-05-10-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\slice\\mod.rs:1029:5\n     |\n1029 |     pub const fn iter(&self) -> Iter<'_, T> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `mutate` found for struct `Alter_Trait_Bounds_445` in the current scope\n  --> src\\main.rs:71:36\n   |\n5  | pub struct Alter_Trait_Bounds_445;\n   | --------------------------------- method `mutate` not found for this struct\n...\n71 |             Alter_Trait_Bounds_445.mutate(&mut file_ast);\n   |                                    ^^^^^^ method not found in `Alter_Trait_Bounds_445`\n   |\n  ::: src\\mutator.rs:15:8\n   |\n15 |     fn mutate(&self, file: &mut syn::File);\n   |        ------ the method is available for `Alter_Trait_Bounds_445` here\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: trait `Mutator` which provides `mutate` is implemented but not in scope; perhaps you want to import it\n   |\n1  + use crate::mutator::Mutator;\n   |\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Trait_Bounds_445_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `mutate` found for struct `Alter_Trait_Bounds_445` in the current scope\n  --> src\\main.rs:69:36\n   |\n5  | pub struct Alter_Trait_Bounds_445;\n   | --------------------------------- method `mutate` not found for this struct\n...\n69 |             Alter_Trait_Bounds_445.mutate(&mut file_ast);\n   |                                    ^^^^^^ method not found in `Alter_Trait_Bounds_445`\n   |\n  ::: src\\mutator.rs:15:8\n   |\n15 |     fn mutate(&self, file: &mut syn::File);\n   |        ------ the method is available for `Alter_Trait_Bounds_445` here\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: trait `Mutator` which provides `mutate` is implemented but not in scope; perhaps you want to import it\n   |\n1  + use crate::mutator::Mutator;\n   |\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Trait_Bounds_445_compling_err_7.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.87s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:20:49:\nexpected one of: `default`, `fn`, `const`, `type`, identifier, `self`, `super`, `crate`, `::`\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\alter_trait_bounds_445.rs"
    },
    {
        "mutator_name": "Alter_Trait_Impls_With_Const_374",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Alter_Trait_Impls_With_Const_374_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0609]: no field `const_token` on type `&mut ItemImpl`\n  --> src\\main.rs:32:61\n   |\n32 |                 if item_impl.trait_.is_some() && !item_impl.const_token.is_some() {\n   |                                                             ^^^^^^^^^^^ unknown field\n   |\n   = note: available fields are: `attrs`, `defaultness`, `unsafety`, `impl_token`, `generics` ... and 4 others\n\nerror[E0609]: no field `const_token` on type `&mut ItemImpl`\n  --> src\\main.rs:33:31\n   |\n33 |                     item_impl.const_token = Some(token::Const { span: Span::call_site() });\n   |                               ^^^^^^^^^^^ unknown field\n   |\n   = note: available fields are: `attrs`, `defaultness`, `unsafety`, `impl_token`, `generics` ... and 4 others\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\alter_trait_impls_with_const_374.rs"
    },
    {
        "mutator_name": "Alter_Trait_Object_Syntax_394",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Alter_Trait_Object_Syntax_394_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0609]: no field `ty` on type `&mut syn::Local`\n  --> src\\main.rs:34:54\n   |\n34 |                 if let Some((_, ref mut ty)) = local.ty {\n   |                                                      ^^ unknown field\n   |\n   = note: available fields are: `attrs`, `let_token`, `pat`, `init`, `semi_token`\n\nerror[E0026]: struct `TraitBound` does not have a field named `dyn_token`\n  --> src\\main.rs:37:79\n   |\n37 | ...                   if let TypeParamBound::Trait(TraitBound { ref mut dyn_token, .. }) = bound {\n   |                                                                         ^^^^^^^^^ struct `TraitBound` does not have this field\n\nerror[E0026]: struct `TraitBound` does not have a field named `dyn_token`\n  --> src\\main.rs:54:79\n   |\n54 | ...                   if let TypeParamBound::Trait(TraitBound { ref mut dyn_token, .. }) = bound {\n   |                                                                         ^^^^^^^^^ struct `TraitBound` does not have this field\n\nSome errors have detailed explanations: E0026, E0609.\nFor more information about an error, try `rustc --explain E0026`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Trait_Object_Syntax_394_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0560]: struct `Question` has no field named `span`\n  --> src\\main.rs:39:93\n   |\n39 | ...                   *modifier = TraitBoundModifier::Maybe(token::Question { span: Span::call_site() });\n   |                                                                               ^^^^ unknown field\n   |\nhelp: a field with a similar name exists\n   |\n39 |                                     *modifier = TraitBoundModifier::Maybe(token::Question { spans: Span::call_site() });\n   |                                                                                                 +\n\nerror[E0560]: struct `Question` has no field named `span`\n  --> src\\main.rs:56:93\n   |\n56 | ...                   *modifier = TraitBoundModifier::Maybe(token::Question { span: Span::call_site() });\n   |                                                                               ^^^^ unknown field\n   |\nhelp: a field with a similar name exists\n   |\n56 |                                     *modifier = TraitBoundModifier::Maybe(token::Question { spans: Span::call_site() });\n   |                                                                                                 +\n\nFor more information about this error, try `rustc --explain E0560`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Trait_Object_Syntax_394_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:37:71\n   |\n37 | ...                   if let TypeParamBound::Trait(TraitBound { ref mut modifier, .. }) = bound {\n   |                                                                 ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:37:36\n   |\n37 | ...                   if let TypeParamBound::Trait(TraitBound { ref mut modifier, .. }) = bound {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n37 -                             if let TypeParamBound::Trait(TraitBound { ref mut modifier, .. }) = bound {\n37 +                             if let TypeParamBound::Trait(TraitBound { modifier, .. }) = bound {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:51:35\n   |\n51 |                 if let Expr::Cast(ref mut expr_cast) = expr {\n   |                                   ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:51:24\n   |\n51 |                 if let Expr::Cast(ref mut expr_cast) = expr {\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n51 -                 if let Expr::Cast(ref mut expr_cast) = expr {\n51 +                 if let Expr::Cast(expr_cast) = expr {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:54:71\n   |\n54 | ...                   if let TypeParamBound::Trait(TraitBound { ref mut modifier, .. }) = bound {\n   |                                                                 ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:54:36\n   |\n54 | ...                   if let TypeParamBound::Trait(TraitBound { ref mut modifier, .. }) = bound {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n54 -                             if let TypeParamBound::Trait(TraitBound { ref mut modifier, .. }) = bound {\n54 +                             if let TypeParamBound::Trait(TraitBound { modifier, .. }) = bound {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Trait_Object_Syntax_394_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `VisitMut` in this scope\n  --> src\\main.rs:12:14\n   |\n12 |         impl VisitMut for TraitObjectMutator {\n   |              ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this trait\n   |\n1  + use syn::visit_mut::VisitMut;\n   |\n\nerror[E0412]: cannot find type `Local` in this scope\n  --> src\\main.rs:13:55\n   |\n13 |             fn visit_local_mut(&mut self, local: &mut Local) {\n   |                                                       ^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::Local;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Pat`\n  --> src\\main.rs:14:24\n   |\n14 |                 if let Pat::Type(PatType { ref mut ty, .. }) = local.pat {\n   |                        ^^^ use of undeclared type `Pat`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Pat;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `PatType` in this scope\n  --> src\\main.rs:14:34\n   |\n14 |                 if let Pat::Type(PatType { ref mut ty, .. }) = local.pat {\n   |                                  ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::PatType;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:15:28\n   |\n15 |                     if let Type::TraitObject(ref mut trait_object) = **ty {\n   |                            ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TypeParamBound`\n  --> src\\main.rs:17:36\n   |\n17 | ...                   if let TypeParamBound::Trait(TraitBound { modifier, .. }) = bound {\n   |                              ^^^^^^^^^^^^^^ use of undeclared type `TypeParamBound`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TypeParamBound;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TraitBound` in this scope\n  --> src\\main.rs:17:58\n   |\n17 | ...                   if let TypeParamBound::Trait(TraitBound { modifier, .. }) = bound {\n   |                                                    ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TraitBound;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TraitBoundModifier`\n  --> src\\main.rs:18:40\n   |\n18 | ...                   if let TraitBoundModifier::None = modifier {\n   |                              ^^^^^^^^^^^^^^^^^^ use of undeclared type `TraitBoundModifier`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TraitBoundModifier;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TraitBoundModifier`\n  --> src\\main.rs:19:49\n   |\n19 | ...                   *modifier = TraitBoundModifier::Maybe(token::Question { spans: [Span::call_site()] });\n   |                                   ^^^^^^^^^^^^^^^^^^ use of undeclared type `TraitBoundModifier`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TraitBoundModifier;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `token`\n  --> src\\main.rs:19:75\n   |\n19 | ...                   *modifier = TraitBoundModifier::Maybe(token::Question { spans: [Span::call_site()] });\n   |                                                             ^^^^^ use of unresolved module or unlinked crate `token`\n   |\n   = help: if you wanted to use a crate named `token`, use `cargo add token` to add it to your `Cargo.toml`\nhelp: consider importing this module\n   |\n1  + use syn::token;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:19:101\n   |\n19 | ...                   *modifier = TraitBoundModifier::Maybe(token::Question { spans: [Span::call_site()] });\n   |                                                                                       ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TraitBoundModifier`\n  --> src\\main.rs:21:49\n   |\n21 | ...                   *modifier = TraitBoundModifier::None;\n   |                                   ^^^^^^^^^^^^^^^^^^ use of undeclared type `TraitBoundModifier`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TraitBoundModifier;\n   |\n\nerror[E0412]: cannot find type `Expr` in this scope\n  --> src\\main.rs:30:53\n   |\n30 |             fn visit_expr_mut(&mut self, expr: &mut Expr) {\n   |                                                     ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:31:24\n   |\n31 |                 if let Expr::Cast(expr_cast) = expr {\n   |                        ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:32:28\n   |\n32 |                     if let Type::TraitObject(ref mut trait_object) = *expr_cast.ty {\n   |                            ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TypeParamBound`\n  --> src\\main.rs:34:36\n   |\n34 | ...                   if let TypeParamBound::Trait(TraitBound { modifier, .. }) = bound {\n   |                              ^^^^^^^^^^^^^^ use of undeclared type `TypeParamBound`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TypeParamBound;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TraitBound` in this scope\n  --> src\\main.rs:34:58\n   |\n34 | ...                   if let TypeParamBound::Trait(TraitBound { modifier, .. }) = bound {\n   |                                                    ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TraitBound;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TraitBoundModifier`\n  --> src\\main.rs:35:40\n   |\n35 | ...                   if let TraitBoundModifier::None = modifier {\n   |                              ^^^^^^^^^^^^^^^^^^ use of undeclared type `TraitBoundModifier`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TraitBoundModifier;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TraitBoundModifier`\n  --> src\\main.rs:36:49\n   |\n36 | ...                   *modifier = TraitBoundModifier::Maybe(token::Question { spans: [Span::call_site()] });\n   |                                   ^^^^^^^^^^^^^^^^^^ use of undeclared type `TraitBoundModifier`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TraitBoundModifier;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `token`\n  --> src\\main.rs:36:75\n   |\n36 | ...                   *modifier = TraitBoundModifier::Maybe(token::Question { spans: [Span::call_site()] });\n   |                                                             ^^^^^ use of unresolved module or unlinked crate `token`\n   |\n   = help: if you wanted to use a crate named `token`, use `cargo add token` to add it to your `Cargo.toml`\nhelp: consider importing this module\n   |\n1  + use syn::token;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:36:101\n   |\n36 | ...                   *modifier = TraitBoundModifier::Maybe(token::Question { spans: [Span::call_site()] });\n   |                                                                                       ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TraitBoundModifier`\n  --> src\\main.rs:38:49\n   |\n38 | ...                   *modifier = TraitBoundModifier::None;\n   |                                   ^^^^^^^^^^^^^^^^^^ use of undeclared type `TraitBoundModifier`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TraitBoundModifier;\n   |\n\nSome errors have detailed explanations: E0405, E0412, E0422, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 22 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Trait_Object_Syntax_394_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:8:6\n  |\n8 | impl Mutator for Alter_Trait_Object_Syntax_394 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\alter_trait_object_syntax_394.rs"
    },
    {
        "mutator_name": "Array_Index_Out_Of_Bounds_341",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\array_index_out_of_bounds_341.rs"
    },
    {
        "mutator_name": "Async_Function_Generic_Lifetime_356",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Async_Function_Generic_Lifetime_356_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:29\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                             ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n31 -             if let Item::Fn(ref mut func) = item {\n31 +             if let Item::Fn(func) = item {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Async_Function_Generic_Lifetime_356_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.86s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:36:67:\nexpected identifier\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\async_function_generic_lifetime_356.rs"
    },
    {
        "mutator_name": "Attribute_Misplacement_In_Let_Bindings_359",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Attribute_Misplacement_In_Let_Bindings_359_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:33:59\n   |\n33 |                     if let Stmt::Local(Local { init: Some((_, expr)), .. }) = stmt {\n   |                                                           ^^^^^^^^^           ---- this expression has type `&mut Stmt`\n   |                                                           |\n   |                                                           expected `LocalInit`, found `(_, _)`\n   |\n   = note: expected struct `LocalInit`\n               found tuple `(_, _)`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\attribute_misplacement_in_let_bindings_359.rs"
    },
    {
        "mutator_name": "Box_And_Yield_Interaction_278",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Box_And_Yield_Interaction_278_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:34:39\n   |\n34 |                     if let Stmt::Expr(Expr::Closure(ref closure)) = stmt {\n   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n34 |                     if let Stmt::Expr(Expr::Closure(ref closure), _) = stmt {\n   |                                                                 +++\n\nerror[E0609]: no field `stmts` on type `&ExprBlock`\n  --> src\\main.rs:36:38\n   |\n36 | ...                   if block.stmts.len() == 1 {\n   |                                ^^^^^ unknown field\n   |\nhelp: one of the expressions' fields has a field of the same name\n   |\n36 |                             if block.block.stmts.len() == 1 {\n   |                                      ++++++\n\nerror[E0609]: no field `stmts` on type `&ExprBlock`\n  --> src\\main.rs:37:75\n   |\n37 | ...                   if let Stmt::Expr(Expr::Yield(_)) = block.stmts[0] {\n   |                                                                 ^^^^^ unknown field\n   |\nhelp: one of the expressions' fields has a field of the same name\n   |\n37 |                                 if let Stmt::Expr(Expr::Yield(_)) = block.block.stmts[0] {\n   |                                                                           ++++++\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:37:51\n   |\n37 | ...                   if let Stmt::Expr(Expr::Yield(_)) = block.stmts[0] {\n   |                                         ^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n37 |                                 if let Stmt::Expr(Expr::Yield(_), _) = block.stmts[0] {\n   |                                                                 +++\n\nSome errors have detailed explanations: E0023, E0609.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Box_And_Yield_Interaction_278_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:29\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                             ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n31 -             if let Item::Fn(ref mut func) = item {\n31 +             if let Item::Fn(func) = item {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:34:53\n   |\n34 |                     if let Stmt::Expr(Expr::Closure(ref closure), _) = stmt {\n   |                                                     ^^^ binding modifier not allowed under `ref` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:34:28\n   |\n34 |                     if let Stmt::Expr(Expr::Closure(ref closure), _) = stmt {\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&_`\nhelp: remove the unnecessary binding modifier\n   |\n34 -                     if let Stmt::Expr(Expr::Closure(ref closure), _) = stmt {\n34 +                     if let Stmt::Expr(Expr::Closure(closure), _) = stmt {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\box_and_yield_interaction_278.rs"
    },
    {
        "mutator_name": "Change_Const_Generic_To_Integer_389",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Change_Const_Generic_To_Integer_389_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:32:24\n   |\n32 |                 if let Some((_, generics, _)) = &item_fn.sig.generics.split_for_impl() {\n   |                        ^^^^^^^^^^^^^^^^^^^^^^   -------------------------------------- this expression has type `&(ImplGenerics<'_>, TypeGenerics<'_>, Option<&WhereClause>)`\n   |                        |\n   |                        expected `(ImplGenerics<'_>, ..., ...)`, found `Option<_>`\n   |\n   = note: expected tuple `(ImplGenerics<'_>, TypeGenerics<'_>, Option<&WhereClause>)`\n               found enum `Option<_>`\n\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:35:65\n   |\n35 | ...                   if let Type::Reference(type_ref) = &*const_param.ty {\n   |                                                           ^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:38:58\n   |\n38 |   ...                   const_param.ty = Box::new(Type::Path(TypePath {\n   |  _______________________--------------___^\n   | |                       |\n   | |                       expected due to the type of this binding\n39 | | ...                       qself: None,\n40 | | ...                       path: parse_quote!(usize),\n41 | | ...                   }));\n   | |_________________________^ expected `Type`, found `Box<Type>`\n   |\n   = note: expected enum `syn::Type`\n            found struct `std::boxed::Box<syn::Type>`\nhelp: consider unboxing the value\n   |\n38 |                                         const_param.ty = *Box::new(Type::Path(TypePath {\n   |                                                          +\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Change_Const_Generic_To_Integer_389_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:20:47\n   |\n20 | ...                   path: parse_quote!(usize),\n   |                             ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:25:51\n   |\n25 | ...                   path: parse_quote!(usize),\n   |                             ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:28:64\n   |\n28 | ...                   item_fn.block.stmts = vec![parse_quote! {\n   |                                                  ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Fn(item_fn) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericParam`\n  --> src\\main.rs:14:28\n   |\n14 |                     if let GenericParam::Const(const_param) = param {\n   |                            ^^^^^^^^^^^^ use of undeclared type `GenericParam`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:15:32\n   |\n15 |                         if let Type::Reference(type_ref) = &const_param.ty {\n   |                                ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:16:36\n   |\n16 | ...                   if let Type::Path(type_path) = &type_ref.elem {\n   |                              ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:18:54\n   |\n18 | ...                   const_param.ty = Type::Path(TypePath {\n   |                                        ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypePath` in this scope\n  --> src\\main.rs:18:65\n   |\n18 | ...                   const_param.ty = Type::Path(TypePath {\n   |                                                   ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypePath;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `ReturnType`\n  --> src\\main.rs:22:44\n   |\n22 | ...                   if let ReturnType::Type(_, ret_type) = &mut item_fn.sig.output {\n   |                              ^^^^^^^^^^ use of undeclared type `ReturnType`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::ReturnType;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:23:62\n   |\n23 | ...                   *ret_type = Box::new(Type::Path(TypePath {\n   |                                            ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypePath` in this scope\n  --> src\\main.rs:23:73\n   |\n23 | ...                   *ret_type = Box::new(Type::Path(TypePath {\n   |                                                       ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypePath;\n   |\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 12 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Change_Const_Generic_To_Integer_389_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:17:36\n   |\n17 | ...                   if let Type::Path(type_path) = &type_ref.elem {\n   |                              ^^^^^^^^^^^^^^^^^^^^^   -------------- this expression has type `&std::boxed::Box<syn::Type>`\n   |                              |\n   |                              expected `Box<Type>`, found `Type`\n   |\n   = note: expected struct `std::boxed::Box<syn::Type>`\n                found enum `syn::Type`\nhelp: consider dereferencing to access the inner value using the Deref trait\n   |\n17 |                             if let Type::Path(type_path) = &*type_ref.elem {\n   |                                                             +\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Change_Const_Generic_To_Integer_389_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `generics.params` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:14:30\n   |\n14 |                 for param in generics.params.iter_mut() {\n   |                              ^^^^^^^^^^^^^^^ `generics` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n   |\nhelp: consider changing this to be a mutable reference\n   |\n13 |                 let generics = &mut item_fn.sig.generics;\n   |                                 +++\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Change_Const_Generic_To_Integer_389_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.92s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:29:64:\nunexpected end of input, expected semicolon\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\change_const_generic_to_integer_389.rs"
    },
    {
        "mutator_name": "Change_Const_Type_386",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Change_Const_Type_386_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:50:29\n   |\n50 |                   if let Some((_, generics)) = &mut func.sig.generics.params.iter_mut().find(|param| {\n   |  _____________________________^^^^^^^^^^^^^____-\n   | |                             |\n   | |                             expected `GenericParam`, found `(_, _)`\n51 | |                     if let GenericParam::Const(const_param) = param {\n52 | |                         if let Type::Path(TypePath { path, .. }) = &const_param.ty {\n53 | |                             if path.segments.last().unwrap().ident == \"usize\" {\n...  |\n58 | |                     false\n59 | |                 }) {\n   | |__________________- this expression has type `&mut Option<&mut GenericParam>`\n   |\n   = note: expected enum `GenericParam`\n             found tuple `(_, _)`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Change_Const_Type_386_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:23:34\n   |\n23 |             file.items.insert(0, parse_quote! {\n   |                                  ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:40:38\n   |\n40 |                     const_param.ty = parse_quote!(Dimension);\n   |                                      ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:42:48\n   |\n42 |                     func.block.stmts.insert(0, parse_quote! {\n   |                                                ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:11:32\n   |\n11 |         let custom_type_name = Ident::new(\"Dimension\", Span::call_site());\n   |                                ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:11:56\n   |\n11 |         let custom_type_name = Ident::new(\"Dimension\", Span::call_site());\n   |                                                        ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:14:20\n   |\n14 |             if let Item::Type(type_item) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:29:20\n   |\n29 |             if let Item::Fn(func) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericParam`\n  --> src\\main.rs:31:28\n   |\n31 |                     if let GenericParam::Const(const_param) = param {\n   |                            ^^^^^^^^^^^^ use of undeclared type `GenericParam`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:32:32\n   |\n32 |                         if let Type::Path(TypePath { path, .. }) = &const_param.ty {\n   |                                ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypePath` in this scope\n  --> src\\main.rs:32:43\n   |\n32 |                         if let Type::Path(TypePath { path, .. }) = &const_param.ty {\n   |                                           ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypePath;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericParam`\n  --> src\\main.rs:30:29\n   |\n30 |                 if let Some(GenericParam::Const(const_param)) = func.sig.generics.params.iter_mut().find_map(|param| {\n   |                             ^^^^^^^^^^^^ use of undeclared type `GenericParam`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 11 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Change_Const_Type_386_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:7:6\n  |\n7 | impl Mutator for Change_Const_Type_386 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\change_const_type_386.rs"
    },
    {
        "mutator_name": "Change_Deref_Target_327",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Change_Deref_Target_327_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:34:32\n   |\n34 |                         if let Some(bounds) = &mut type_param.bounds {\n   |                                ^^^^^^^^^^^^   ---------------------- this expression has type `&mut syn::punctuated::Punctuated<TypeParamBound, syn::token::Plus>`\n   |                                |\n   |                                expected `Punctuated<TypeParamBound, Plus>`, found `Option<_>`\n   |\n   = note: expected struct `syn::punctuated::Punctuated<TypeParamBound, syn::token::Plus>`\n                found enum `Option<_>`\n\nerror[E0599]: no variant or associated item named `Binding` found for enum `GenericArgument` in the current scope\n  --> src\\main.rs:41:77\n   |\n41 | ...                   if let GenericArgument::Binding(binding) = arg {\n   |                                               ^^^^^^^ variant or associated item not found in `GenericArgument`\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\change_deref_target_327.rs"
    },
    {
        "mutator_name": "Change_Dyn_Star_To_Concrete_392",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Change_Dyn_Star_To_Concrete_392_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:40:51\n   |\n40 | ...                   if let Stmt::Expr(Expr::Cast(ref mut cast_expr)) = stmt {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n40 |                                 if let Stmt::Expr(Expr::Cast(ref mut cast_expr), _) = stmt {\n   |                                                                                +++\n\nFor more information about this error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Change_Dyn_Star_To_Concrete_392_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:32:29\n   |\n32 |             if let Item::Fn(ref mut func) = item {\n   |                             ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:32:20\n   |\n32 |             if let Item::Fn(ref mut func) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n32 -             if let Item::Fn(ref mut func) = item {\n32 +             if let Item::Fn(func) = item {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:40:62\n   |\n40 | ...                   if let Stmt::Expr(Expr::Cast(ref mut cast_expr), _) = stmt {\n   |                                                    ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:40:40\n   |\n40 | ...                   if let Stmt::Expr(Expr::Cast(ref mut cast_expr), _) = stmt {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n40 -                                 if let Stmt::Expr(Expr::Cast(ref mut cast_expr), _) = stmt {\n40 +                                 if let Stmt::Expr(Expr::Cast(cast_expr), _) = stmt {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\change_dyn_star_to_concrete_392.rs"
    },
    {
        "mutator_name": "Change_Extern_Rust_Call_To_C_442",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Change_Extern_Rust_Call_To_C_442_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0609]: no field `abi` on type `&mut ItemFn`\n  --> src\\main.rs:32:42\n   |\n32 |                 if let Some(abi) = &func.abi {\n   |                                          ^^^ unknown field\n   |\nhelp: one of the expressions' fields has a field of the same name\n   |\n32 |                 if let Some(abi) = &func.sig.abi {\n   |                                          ++++\n\nerror[E0609]: no field `abi` on type `&mut ItemFn`\n  --> src\\main.rs:34:30\n   |\n34 |                         func.abi = Some(syn::Abi {\n   |                              ^^^ unknown field\n   |\nhelp: one of the expressions' fields has a field of the same name\n   |\n34 |                         func.sig.abi = Some(syn::Abi {\n   |                              ++++\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Change_Extern_Rust_Call_To_C_442_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:29\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                             ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n31 -             if let Item::Fn(ref mut func) = item {\n31 +             if let Item::Fn(func) = item {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\change_extern_rust_call_to_c_442.rs"
    },
    {
        "mutator_name": "Change_Repr_Packed_To_C_330",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Change_Repr_Packed_To_C_330_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: could not find `NestedMeta` in `syn`\n  --> src\\main.rs:37:49\n   |\n37 | ...                   if let syn::NestedMeta::Meta(syn::Meta::Path(path)) = nested {\n   |                                   ^^^^^^^^^^ could not find `NestedMeta` in `syn`\n\nerror[E0615]: attempted to take value of method `path` on type `&mut Attribute`\n  --> src\\main.rs:33:29\n   |\n33 |                     if attr.path.is_ident(\"repr\") {\n   |                             ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n33 |                     if attr.path().is_ident(\"repr\") {\n   |                                 ++\n\nerror[E0599]: no method named `parse_meta` found for mutable reference `&mut Attribute` in the current scope\n   --> src\\main.rs:34:48\n    |\n34  |                         if let Ok(meta) = attr.parse_meta() {\n    |                                                ^^^^^^^^^^\n    |\nhelp: there is a method `parse_nested_meta` with a similar name, but with different arguments\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\attr.rs:391:5\n    |\n391 | /     pub fn parse_nested_meta(\n392 | |         &self,\n393 | |         logic: impl FnMut(ParseNestedMeta) -> Result<()>,\n394 | |     ) -> Result<()> {\n    | |___________________^\n\nerror[E0609]: no field `nested` on type `MetaList`\n  --> src\\main.rs:36:46\n   |\n36 | ...                   if meta_list.nested.iter().any(|nested| {\n   |                                    ^^^^^^ unknown field\n   |\n   = note: available fields are: `path`, `delimiter`, `tokens`\n\nSome errors have detailed explanations: E0433, E0599, E0609, E0615.\nFor more information about an error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Change_Repr_Packed_To_C_330_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0432]: unresolved import `syn::NestedMeta`\n --> src\\main.rs:8:89\n  |\n8 |     Item, ItemEnum, ItemFn, ItemStruct, Lifetime, LifetimeParam, Local, Meta, MetaList, NestedMeta,\n  |                                                                                         ^^^^^^^^^^ no `NestedMeta` in the root\n\nerror[E0599]: no method named `parse_meta` found for mutable reference `&mut Attribute` in the current scope\n   --> src\\main.rs:28:65\n    |\n28  |                         if let Ok(Meta::List(meta_list)) = attr.parse_meta() {\n    |                                                                 ^^^^^^^^^^\n    |\nhelp: there is a method `parse_nested_meta` with a similar name, but with different arguments\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\attr.rs:391:5\n    |\n391 | /     pub fn parse_nested_meta(\n392 | |         &self,\n393 | |         logic: impl FnMut(ParseNestedMeta) -> Result<()>,\n394 | |     ) -> Result<()> {\n    | |___________________^\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Change_Repr_Packed_To_C_330_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `parse_meta` found for mutable reference `&mut Attribute` in the current scope\n   --> src\\main.rs:27:65\n    |\n27  |                         if let Ok(Meta::List(meta_list)) = attr.parse_meta() {\n    |                                                                 ^^^^^^^^^^\n    |\nhelp: there is a method `parse_nested_meta` with a similar name, but with different arguments\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\attr.rs:391:5\n    |\n391 | /     pub fn parse_nested_meta(\n392 | |         &self,\n393 | |         logic: impl FnMut(ParseNestedMeta) -> Result<()>,\n394 | |     ) -> Result<()> {\n    | |___________________^\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\change_repr_packed_to_c_330.rs"
    },
    {
        "mutator_name": "Closure_Parameter_Variance_298",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Closure_Parameter_Variance_298_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:41:48\n   |\n41 | ...                   *pat_type.ty = Box::new(closure_type);\n   |                       ------------   ^^^^^^^^^^^^^^^^^^^^^^ expected `Type`, found `Box<Type>`\n   |                       |\n   |                       expected due to the type of this binding\n   |\n   = note: expected enum `syn::Type`\n            found struct `std::boxed::Box<syn::Type>`\nhelp: consider unboxing the value\n   |\n41 |                                 *pat_type.ty = *Box::new(closure_type);\n   |                                                +\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:46:55\n   |\n46 | ...                   if let Stmt::Expr(Expr::Path(expr_path)) = stmt {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n46 |                                     if let Stmt::Expr(Expr::Path(expr_path), _) = stmt {\n   |                                                                            +++\n\nerror[E0277]: the trait bound `std::boxed::Box<Pat>: AsRef<str>` is not satisfied\n  --> src\\main.rs:47:68\n   |\n47 | ...                   if expr_path.path.is_ident(&pat_type.pat) {\n   |                                         -------- ^^^^^^^^^^^^^ the trait `AsRef<str>` is not implemented for `std::boxed::Box<Pat>`\n   |                                         |\n   |                                         required by a bound introduced by this call\n   |\n   = help: the trait `AsRef<str>` is not implemented for `std::boxed::Box<Pat>`\n           but trait `AsRef<Pat>` is implemented for it\n   = help: for that trait implementation, expected `Pat`, found `str`\n   = note: required for `proc_macro2::Ident` to implement `PartialEq<std::boxed::Box<Pat>>`\nnote: required by a bound in `syn::Path::is_ident`\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\path.rs:66:16\n   |\n63 |     pub fn is_ident<I>(&self, ident: &I) -> bool\n   |            -------- required by a bound in this associated function\n...\n66 |         Ident: PartialEq<I>,\n   |                ^^^^^^^^^^^^ required by this bound in `Path::is_ident`\n\nerror[E0061]: this enum variant takes 2 arguments but 1 argument was supplied\n  --> src\\main.rs:51:60\n   |\n51 | ...                   new_stmts.push(Stmt::Expr(call_expr));\n   |                                      ^^^^^^^^^^----------- argument #2 of type `Option<Semi>` is missing\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:9\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |         ^^^^\nhelp: provide the argument\n   |\n51 |                                             new_stmts.push(Stmt::Expr(call_expr, /* Option<Semi> */));\n   |                                                                                ++++++++++++++++++++\n\nSome errors have detailed explanations: E0023, E0061, E0277, E0308.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Closure_Parameter_Variance_298_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:18:58\n   |\n18 | ...                   let closure_type: Type = parse_quote! {\n   |                                                ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:22:49\n   |\n22 | ...                   *pat_type.pat = parse_quote! { #new_ident };\n   |                                       ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:28:67\n   |\n28 | ...                   let call_expr: Expr = parse_quote! {\n   |                                             ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Fn(item_fn) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `FnArg`\n  --> src\\main.rs:14:32\n   |\n14 |                         if let FnArg::Typed(pat_type) = input {\n   |                                ^^^^^ use of undeclared type `FnArg`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::FnArg;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:15:36\n   |\n15 | ...                   if let Type::Reference(type_ref) = &*pat_type.ty {\n   |                              ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:17:49\n   |\n17 | ...                   let new_ident = Ident::new(\"closure_input\", Span::call_site());\n   |                                       ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:17:77\n   |\n17 | ...                   let new_ident = Ident::new(\"closure_input\", Span::call_site());\n   |                                                                   ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0412]: cannot find type `Type` in this scope\n  --> src\\main.rs:18:51\n   |\n18 | ...                   let closure_type: Type = parse_quote! {\n   |                                         ^^^^ not found in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:26:44\n   |\n26 | ...                   if let Stmt::Expr(Expr::Path(expr_path), _) = stmt {\n   |                              ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:26:55\n   |\n26 | ...                   if let Stmt::Expr(Expr::Path(expr_path), _) = stmt {\n   |                                         ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0412]: cannot find type `Expr` in this scope\n  --> src\\main.rs:28:60\n   |\n28 | ...                   let call_expr: Expr = parse_quote! {\n   |                                      ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:31:60\n   |\n31 | ...                   new_stmts.push(Stmt::Expr(call_expr, None));\n   |                                      ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 13 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Closure_Parameter_Variance_298_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:28:55\n   |\n28 | ...                   if let Stmt::Expr(Expr::Path(expr_path)) = stmt {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n28 |                                     if let Stmt::Expr(Expr::Path(expr_path), _) = stmt {\n   |                                                                            +++\n\nerror[E0061]: this enum variant takes 2 arguments but 1 argument was supplied\n  --> src\\main.rs:33:60\n   |\n33 | ...                   new_stmts.push(Stmt::Expr(call_expr));\n   |                                      ^^^^^^^^^^----------- argument #2 of type `Option<Semi>` is missing\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:9\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |         ^^^^\nhelp: provide the argument\n   |\n33 |                                             new_stmts.push(Stmt::Expr(call_expr, /* Option<Semi> */));\n   |                                                                                ++++++++++++++++++++\n\nSome errors have detailed explanations: E0023, E0061.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\closure_parameter_variance_298.rs"
    },
    {
        "mutator_name": "Closure_With_Type_Alias_370",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Closure_With_Type_Alias_370_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:40:63\n   |\n40 | ...                   if let Stmt::Expr(Expr::Closure(closure)) = stmt {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n40 |                                             if let Stmt::Expr(Expr::Closure(closure), _) = stmt {\n   |                                                                                     +++\n\nerror[E0061]: this enum variant takes 2 arguments but 1 argument was supplied\n  --> src\\main.rs:48:57\n   |\n48 | ...                   *stmt = Stmt::Expr(new_closure_body);\n   |                               ^^^^^^^^^^------------------ argument #2 of type `Option<Semi>` is missing\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:9\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |         ^^^^\nhelp: provide the argument\n   |\n48 |                                                 *stmt = Stmt::Expr(new_closure_body, /* Option<Semi> */);\n   |                                                                                    ++++++++++++++++++++\n\nSome errors have detailed explanations: E0023, E0061.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Closure_With_Type_Alias_370_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:21:79\n   |\n21 | ...                   let captured_var_decl: Stmt = parse_quote! {\n   |                                                     ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:24:78\n   |\n24 | ...                   let new_closure_body: Expr = parse_quote! {\n   |                                                    ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Type(type_alias) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:12:24\n   |\n12 |                 if let Type::ImplTrait(_) = *type_alias.ty {\n   |                        ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:15:32\n   |\n15 |                         if let Item::Fn(func) = item {\n   |                                ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `ReturnType`\n  --> src\\main.rs:16:36\n   |\n16 | ...                   if let ReturnType::Type(_, ret_type) = &func.sig.output {\n   |                              ^^^^^^^^^^ use of undeclared type `ReturnType`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::ReturnType;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:17:40\n   |\n17 | ...                   if let Type::Path(TypePath { path, .. }) = &**ret_type {\n   |                              ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypePath` in this scope\n  --> src\\main.rs:17:51\n   |\n17 | ...                   if let Type::Path(TypePath { path, .. }) = &**ret_type {\n   |                                         ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypePath;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:20:52\n   |\n20 | ...                   if let Stmt::Expr(Expr::Closure(closure), _) = stmt {\n   |                              ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:20:63\n   |\n20 | ...                   if let Stmt::Expr(Expr::Closure(closure), _) = stmt {\n   |                                         ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0412]: cannot find type `Stmt` in this scope\n  --> src\\main.rs:21:72\n   |\n21 | ...                   let captured_var_decl: Stmt = parse_quote! {\n   |                                              ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0412]: cannot find type `Expr` in this scope\n  --> src\\main.rs:24:71\n   |\n24 | ...                   let new_closure_body: Expr = parse_quote! {\n   |                                             ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:28:57\n   |\n28 | ...                   *stmt = Stmt::Expr(new_closure_body, None);\n   |                               ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nSome errors have detailed explanations: E0412, E0422, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 13 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Closure_With_Type_Alias_370_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Closure_With_Type_Alias_370 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Closure_With_Type_Alias_370_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:21:63\n   |\n21 | ...                   if let Stmt::Expr(Expr::Closure(closure)) = stmt {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n21 |                                             if let Stmt::Expr(Expr::Closure(closure), _) = stmt {\n   |                                                                                     +++\n\nerror[E0061]: this enum variant takes 2 arguments but 1 argument was supplied\n  --> src\\main.rs:29:57\n   |\n29 | ...                   *stmt = Stmt::Expr(new_closure_body);\n   |                               ^^^^^^^^^^------------------ argument #2 of type `Option<Semi>` is missing\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:9\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |         ^^^^\nhelp: provide the argument\n   |\n29 |                                                 *stmt = Stmt::Expr(new_closure_body, /* Option<Semi> */);\n   |                                                                                    ++++++++++++++++++++\n\nSome errors have detailed explanations: E0023, E0061.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Closure_With_Type_Alias_370_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0499]: cannot borrow `file.items` as mutable more than once at a time\n  --> src\\main.rs:15:33\n   |\n11 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     first mutable borrow occurs here\n   |                     first borrow later used here\n...\n15 |                     for item in &mut file.items {\n   |                                 ^^^^^^^^^^^^^^^ second mutable borrow occurs here\n\nerror[E0499]: cannot borrow `func.block.stmts` as mutable more than once at a time\n  --> src\\main.rs:28:49\n   |\n20 | ...                   if let Some(stmt) = func.block.stmts.first_mut() {\n   |                                           ---------------- first mutable borrow occurs here\n...\n28 | ...                           func.block.stmts.insert(0, captured_var_decl);\n   |                               ^^^^^^^^^^^^^^^^ second mutable borrow occurs here\n29 | ...                           *stmt = Stmt::Expr(new_closure_body, None);\n   |                               ----- first borrow later used here\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Closure_With_Type_Alias_370_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:28:55\n   |\n28 | ...                   if let Stmt::Expr(Expr::Closure(closure)) = stmt {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n28 |                                     if let Stmt::Expr(Expr::Closure(closure), _) = stmt {\n   |                                                                             +++\n\nerror[E0061]: this enum variant takes 2 arguments but 1 argument was supplied\n  --> src\\main.rs:36:49\n   |\n36 | ...                   *stmt = Stmt::Expr(new_closure_body);\n   |                               ^^^^^^^^^^------------------ argument #2 of type `Option<Semi>` is missing\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:9\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |         ^^^^\nhelp: provide the argument\n   |\n36 |                                         *stmt = Stmt::Expr(new_closure_body, /* Option<Semi> */);\n   |                                                                            ++++++++++++++++++++\n\nSome errors have detailed explanations: E0023, E0061.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Closure_With_Type_Alias_370_compling_err_7.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0499]: cannot borrow `func.block.stmts` as mutable more than once at a time\n  --> src\\main.rs:35:41\n   |\n27 | ...                   if let Some(stmt) = func.block.stmts.first_mut() {\n   |                                           ---------------- first mutable borrow occurs here\n...\n35 | ...                           func.block.stmts.insert(0, captured_var_decl);\n   |                               ^^^^^^^^^^^^^^^^ second mutable borrow occurs here\n36 | ...                           *stmt = Stmt::Expr(new_closure_body, None);\n   |                               ----- first borrow later used here\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Closure_With_Type_Alias_370_compling_err_8.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:28:55\n   |\n28 | ...                   if let Stmt::Expr(Expr::Closure(closure)) = stmt {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n28 |                                     if let Stmt::Expr(Expr::Closure(closure), _) = stmt {\n   |                                                                             +++\n\nerror[E0061]: this enum variant takes 2 arguments but 1 argument was supplied\n  --> src\\main.rs:35:49\n   |\n35 | ...                   *stmt = Stmt::Expr(new_closure_body);\n   |                               ^^^^^^^^^^------------------ argument #2 of type `Option<Semi>` is missing\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:9\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |         ^^^^\nhelp: provide the argument\n   |\n35 |                                         *stmt = Stmt::Expr(new_closure_body, /* Option<Semi> */);\n   |                                                                            ++++++++++++++++++++\n\nSome errors have detailed explanations: E0023, E0061.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\closure_with_type_alias_370.rs"
    },
    {
        "mutator_name": "Const_Generic_Lifetimes_382",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Const_Generic_Lifetimes_382_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:46:38\n   |\n46 |                         colon_token: Some(token::Colon(Span::call_site())),\n   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Colon`, found `Option<Colon>`\n   |\n   = note: expected struct `syn::token::Colon`\n                found enum `Option<syn::token::Colon>`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:47:29\n   |\n47 |                           ty: Box::new(Type::Reference(TypeReference {\n   |  _____________________________^\n48 | |                             and_token: token::And(Span::call_site()),\n49 | |                             lifetime: Some(lifetime),\n50 | |                             mutability: None,\n...  |\n54 | |                             })),\n55 | |                         })),\n   | |___________________________^ expected `Type`, found `Box<Type>`\n   |\n   = note: expected enum `syn::Type`\n            found struct `std::boxed::Box<syn::Type>`\nhelp: consider unboxing the value\n   |\n47 |                         ty: *Box::new(Type::Reference(TypeReference {\n   |                             +\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\const_generic_lifetimes_382.rs"
    },
    {
        "mutator_name": "Const_Generic_Parameter_Modification_268",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Const_Generic_Parameter_Modification_268_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:34:32\n   |\n34 |                         if let Some((_, ref mut generic_params)) = trait_type.generics.split_for_impl() {\n   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ------------------------------------ this expression has type `(ImplGenerics<'_>, TypeGenerics<'_>, Option<&WhereClause>)`\n   |                                |\n   |                                expected `(ImplGenerics<'_>, ..., ...)`, found `Option<_>`\n   |\n   = note: expected tuple `(ImplGenerics<'_>, TypeGenerics<'_>, Option<&WhereClause>)`\n               found enum `Option<_>`\n\nerror[E0282]: type annotations needed\n  --> src\\main.rs:35:57\n   |\n35 | ...                   for param in generic_params.iter_mut() {\n   |                                                   ^^^^^^^^ cannot infer type\n\nSome errors have detailed explanations: E0282, E0308.\nFor more information about an error, try `rustc --explain E0282`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Const_Generic_Parameter_Modification_268_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Trait(item_trait) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TraitItem`\n  --> src\\main.rs:13:28\n   |\n13 |                     if let TraitItem::Type(trait_type) = item {\n   |                            ^^^^^^^^^ use of undeclared type `TraitItem`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TraitItem;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericParam`\n  --> src\\main.rs:16:36\n   |\n16 | ...                   if let GenericParam::Const(const_param) = param {\n   |                              ^^^^^^^^^^^^ use of undeclared type `GenericParam`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:17:40\n   |\n17 | ...                   if let Type::Path(TypePath { path, .. }) = &const_param.ty {\n   |                              ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypePath` in this scope\n  --> src\\main.rs:17:51\n   |\n17 | ...                   if let Type::Path(TypePath { path, .. }) = &const_param.ty {\n   |                                         ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypePath;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:20:70\n   |\n20 | ...                   \"i32\" => segment.ident = Ident::new(\"u32\", Span::call_site()),\n   |                                                ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:20:88\n   |\n20 | ...                   \"i32\" => segment.ident = Ident::new(\"u32\", Span::call_site()),\n   |                                                                  ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:21:70\n   |\n21 | ...                   \"u32\" => segment.ident = Ident::new(\"usize\", Span::call_site()),\n   |                                                ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:21:90\n   |\n21 | ...                   \"u32\" => segment.ident = Ident::new(\"usize\", Span::call_site()),\n   |                                                                    ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 9 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Const_Generic_Parameter_Modification_268_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:6:6\n  |\n6 | impl Mutator for Const_Generic_Parameter_Modification_268 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Const_Generic_Parameter_Modification_268_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `path.segments` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:20:60\n   |\n20 | ...                   if let Some(segment) = path.segments.last_mut() {\n   |                                              ^^^^^^^^^^^^^ `path` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\const_generic_parameter_modification_268.rs"
    },
    {
        "mutator_name": "Convert_Safe_Function_Pointers_To_Unsafe_343",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Convert_Safe_Function_Pointers_To_Unsafe_343_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0609]: no field `ty` on type `&mut syn::Local`\n  --> src\\main.rs:34:55\n   |\n34 |                         if let Some((_, ty)) = &local.ty {\n   |                                                       ^^ unknown field\n   |\n   = note: available fields are: `attrs`, `let_token`, `pat`, `init`, `semi_token`\n\nerror[E0609]: no field `ty` on type `&mut syn::Local`\n  --> src\\main.rs:40:47\n   |\n40 | ...                   local.ty = Some((token::Colon::default(), Box::new(Type::Path(new_type_path))));\n   |                             ^^ unknown field\n   |\n   = note: available fields are: `attrs`, `let_token`, `pat`, `init`, `semi_token`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Convert_Safe_Function_Pointers_To_Unsafe_343_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:34:32\n   |\n34 |                         if let Some((Pat::Type(pat_type), _)) = &local.pat {\n   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ---------- this expression has type `&Pat`\n   |                                |\n   |                                expected `Pat`, found `Option<_>`\n   |\n   = note: expected enum `Pat`\n              found enum `Option<_>`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Convert_Safe_Function_Pointers_To_Unsafe_343_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0594]: cannot assign to `pat_type.ty`, which is behind a `&` reference\n  --> src\\main.rs:40:41\n   |\n40 | ...                   pat_type.ty = Box::new(Type::Path(new_type_path));\n   |                       ^^^^^^^^^^^ `pat_type` is a `&` reference, so the data it refers to cannot be written\n\nFor more information about this error, try `rustc --explain E0594`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\convert_safe_function_pointers_to_unsafe_343.rs"
    },
    {
        "mutator_name": "Duplicate_Const_Parameter_In_Trait_Definition_270",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Duplicate_Const_Parameter_In_Trait_Definition_270_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.94s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:40:47:\nexpected identifier, found keyword `const`\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\duplicate_const_parameter_in_trait_definition_270.rs"
    },
    {
        "mutator_name": "Duplicate_Match_Arms_367",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\duplicate_match_arms_367.rs"
    },
    {
        "mutator_name": "Enum_Discriminant_Overlap_430",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\enum_discriminant_overlap_430.rs"
    },
    {
        "mutator_name": "Enum_Lifetime_Mismatch_364",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Enum_Lifetime_Mismatch_364_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:35:28\n   |\n35 |                     if let Some((_, ref fields)) = &variant.fields {\n   |                            ^^^^^^^^^^^^^^^^^^^^^   --------------- this expression has type `&Fields`\n   |                            |\n   |                            expected `Fields`, found `Option<_>`\n   |\n   = note: expected enum `Fields`\n              found enum `Option<_>`\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:52:51\n   |\n52 | ...                   if let Stmt::Expr(Expr::Match(expr_match)) = stmt {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n52 |                                 if let Stmt::Expr(Expr::Match(expr_match), _) = stmt {\n   |                                                                          +++\n\nSome errors have detailed explanations: E0023, E0308.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Enum_Lifetime_Mismatch_364_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0499]: cannot borrow `file.items` as mutable more than once at a time\n  --> src\\main.rs:49:33\n   |\n31 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     first mutable borrow occurs here\n   |                     first borrow later used here\n...\n49 |                     for item in &mut file.items {\n   |                                 ^^^^^^^^^^^^^^^ second mutable borrow occurs here\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Enum_Lifetime_Mismatch_364_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:15:20\n   |\n15 |             if let Item::Enum(item_enum) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Fields`\n  --> src\\main.rs:17:28\n   |\n17 |                     if let Fields::Named(fields_named) = &variant.fields {\n   |                            ^^^^^^ use of undeclared type `Fields`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Fields;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:19:36\n   |\n19 | ...                   if let Type::Ptr(type_ptr) = &field.ty {\n   |                              ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:20:40\n   |\n20 | ...                   if let Type::Reference(type_ref) = &*type_ptr.elem {\n   |                              ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:37:28\n   |\n37 |                     if let Item::Fn(item_fn) = item {\n   |                            ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:39:36\n   |\n39 | ...                   if let Stmt::Expr(Expr::Match(expr_match), _) = stmt {\n   |                              ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:39:47\n   |\n39 | ...                   if let Stmt::Expr(Expr::Match(expr_match), _) = stmt {\n   |                                         ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Pat`\n  --> src\\main.rs:41:44\n   |\n41 | ...                   if let Pat::TupleStruct(pat_tuple_struct) = &mut arm.pat {\n   |                              ^^^ use of undeclared type `Pat`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Pat;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:45:65\n   |\n45 | ...                   segment.ident = Ident::new(\"NonExistentVariant\", segment.ident.span());\n   |                                       ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nFor more information about this error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 9 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Enum_Lifetime_Mismatch_364_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `mutate` found for struct `Enum_Lifetime_Mismatch_364` in the current scope\n  --> src\\main.rs:85:40\n   |\n4  | pub struct Enum_Lifetime_Mismatch_364;\n   | ------------------------------------- method `mutate` not found for this struct\n...\n85 |             Enum_Lifetime_Mismatch_364.mutate(&mut file_ast);\n   |                                        ^^^^^^ method not found in `Enum_Lifetime_Mismatch_364`\n   |\n  ::: src\\mutator.rs:15:8\n   |\n15 |     fn mutate(&self, file: &mut syn::File);\n   |        ------ the method is available for `Enum_Lifetime_Mismatch_364` here\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: trait `Mutator` which provides `mutate` is implemented but not in scope; perhaps you want to import it\n   |\n1  + use crate::mutator::Mutator;\n   |\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Enum_Lifetime_Mismatch_364_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:39:47\n   |\n39 | ...                   if let Stmt::Expr(Expr::Match(expr_match)) = stmt {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n39 |                             if let Stmt::Expr(Expr::Match(expr_match), _) = stmt {\n   |                                                                      +++\n\nFor more information about this error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\enum_lifetime_mismatch_364.rs"
    },
    {
        "mutator_name": "Enum_With_Default_Const_Generics_Modification_267",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Enum_With_Default_Const_Generics_Modification_267_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0615]: attempted to take value of method `path` on type `&&Attribute`\n  --> src\\main.rs:32:82\n   |\n32 |                 if let Some(repr_attr) = item_enum.attrs.iter().find(|attr| attr.path.is_ident(\"repr\")) {\n   |                                                                                  ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n32 |                 if let Some(repr_attr) = item_enum.attrs.iter().find(|attr| attr.path().is_ident(\"repr\")) {\n   |                                                                                      ++\n\nerror[E0599]: no method named `parse_meta` found for reference `&Attribute` in the current scope\n   --> src\\main.rs:33:49\n    |\n33  |                     if let Ok(meta) = repr_attr.parse_meta() {\n    |                                                 ^^^^^^^^^^\n    |\nhelp: there is a method `parse_nested_meta` with a similar name, but with different arguments\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\attr.rs:391:5\n    |\n391 | /     pub fn parse_nested_meta(\n392 | |         &self,\n393 | |         logic: impl FnMut(ParseNestedMeta) -> Result<()>,\n394 | |     ) -> Result<()> {\n    | |___________________^\n\nerror[E0609]: no field `nested` on type `MetaList`\n  --> src\\main.rs:35:42\n   |\n35 | ...                   if meta_list.nested.iter().any(|nested| matches!(nested, NestedMeta::Meta(Meta::Path(p)) if p.is_ident(\"u8\"))) {\n   |                                    ^^^^^^ unknown field\n   |\n   = note: available fields are: `path`, `delimiter`, `tokens`\n\nerror[E0433]: failed to resolve: use of undeclared type `NestedMeta`\n  --> src\\main.rs:35:86\n   |\n35 | ...                   if meta_list.nested.iter().any(|nested| matches!(nested, NestedMeta::Meta(Meta::Path(p)) if p.is_ident(\"u8\"))) {\n   |                                                                                ^^^^^^^^^^ use of undeclared type `NestedMeta`\n\nSome errors have detailed explanations: E0433, E0599, E0609, E0615.\nFor more information about an error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Enum_With_Default_Const_Generics_Modification_267_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0432]: unresolved import `syn::NestedMeta`\n  --> src\\main.rs:19:32\n   |\n19 |     Attribute, Meta, MetaList, NestedMeta,\n   |                                ^^^^^^^^^^ no `NestedMeta` in the root\n\nerror[E0599]: no method named `parse_meta` found for reference `&Attribute` in the current scope\n   --> src\\main.rs:34:49\n    |\n34  |                     if let Ok(meta) = repr_attr.parse_meta() {\n    |                                                 ^^^^^^^^^^\n    |\nhelp: there is a method `parse_nested_meta` with a similar name, but with different arguments\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\attr.rs:391:5\n    |\n391 | /     pub fn parse_nested_meta(\n392 | |         &self,\n393 | |         logic: impl FnMut(ParseNestedMeta) -> Result<()>,\n394 | |     ) -> Result<()> {\n    | |___________________^\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Enum_With_Default_Const_Generics_Modification_267_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0505]: cannot move out of `const_param` because it is borrowed\n  --> src\\main.rs:40:58\n   |\n38 | ...                   if let GenericParam::Const(const_param) = param {\n   |                                                  ----------- binding `const_param` declared here\n39 | ...                       if let Some(default) = &const_param.default {\n   |                                                  -------------------- borrow of `const_param.default` occurs here\n40 | ...                           return Some((const_param, default.clone()));\n   |                                            ^^^^^^^^^^^  ------- borrow later used here\n   |                                            |\n   |                                            move out of `const_param` occurs here\n   |\nhelp: consider cloning the value if the performance cost is acceptable\n   |\n39 |                                         if let Some(default) = &const_param.default.clone() {\n   |                                                                                    ++++++++\n\nFor more information about this error, try `rustc --explain E0505`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\enum_with_default_const_generics_modification_267.rs"
    },
    {
        "mutator_name": "Function_Call_Async_Await_351",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Function_Call_Async_Await_351_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.00s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:35:42:\nunexpected token\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Function_Call_Async_Await_351_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.67s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' has overflowed its stack\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 0xc00000fd, STATUS_STACK_OVERFLOW)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Function_Call_Async_Await_351_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.80s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' has overflowed its stack\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 0xc00000fd, STATUS_STACK_OVERFLOW)\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\function_call_async_await_351.rs"
    },
    {
        "mutator_name": "Generic_Type_Modifier_290",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Generic_Type_Modifier_290_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `syn::TraitItem` in the current scope\n  --> src\\main.rs:44:43\n   |\n44 |                         if let TraitItem::Method(method_item) = item {\n   |                                           ^^^^^^ variant or associated item not found in `TraitItem`\n\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:47:73\n   |\n47 | ...                   if let Type::Path(type_path) = &mut **ty {\n   |                                                           ^^^^ can't be dereferenced\n\nSome errors have detailed explanations: E0599, E0614.\nFor more information about an error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Generic_Type_Modifier_290_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0432]: unresolved import `syn::TraitItemMethod`\n  --> src\\main.rs:19:31\n   |\n19 |     TraitItem, TraitItemType, TraitItemMethod,\n   |                               ^^^^^^^^^^^^^^^\n   |                               |\n   |                               no `TraitItemMethod` in the root\n   |                               help: a similar name exists in the module: `TraitItemMacro`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `TraitItem` in the current scope\n  --> src\\main.rs:45:43\n   |\n45 |                         if let TraitItem::Method(method_item) = item {\n   |                                           ^^^^^^ variant or associated item not found in `TraitItem`\n\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:47:69\n   |\n47 | ...                   if let Type::Path(type_path) = &mut **ty {\n   |                                                           ^^^^ can't be dereferenced\n\nSome errors have detailed explanations: E0432, E0599, E0614.\nFor more information about an error, try `rustc --explain E0432`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Generic_Type_Modifier_290_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `TraitItem` in the current scope\n  --> src\\main.rs:45:43\n   |\n45 |                         if let TraitItem::Method(method_item) = item {\n   |                                           ^^^^^^ variant or associated item not found in `TraitItem`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Generic_Type_Modifier_290_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0432]: unresolved import `syn::TraitItemMethod`\n  --> src\\main.rs:19:31\n   |\n19 |     TraitItem, TraitItemType, TraitItemMethod,\n   |                               ^^^^^^^^^^^^^^^\n   |                               |\n   |                               no `TraitItemMethod` in the root\n   |                               help: a similar name exists in the module: `TraitItemMacro`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `TraitItem` in the current scope\n  --> src\\main.rs:45:43\n   |\n45 |                         if let TraitItem::Method(method_item) = item {\n   |                                           ^^^^^^ variant or associated item not found in `TraitItem`\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Generic_Type_Modifier_290_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `TraitItem` in the current scope\n  --> src\\main.rs:45:43\n   |\n45 |                         if let TraitItem::Method(method_item) = item {\n   |                                           ^^^^^^ variant or associated item not found in `TraitItem`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Generic_Type_Modifier_290_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0432]: unresolved import `syn::TraitItemMethod`\n  --> src\\main.rs:19:31\n   |\n19 |     TraitItem, TraitItemType, TraitItemMethod,\n   |                               ^^^^^^^^^^^^^^^\n   |                               |\n   |                               no `TraitItemMethod` in the root\n   |                               help: a similar name exists in the module: `TraitItemMacro`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `TraitItem` in the current scope\n  --> src\\main.rs:45:43\n   |\n45 |                         if let TraitItem::Method(method_item) = item {\n   |                                           ^^^^^^ variant or associated item not found in `TraitItem`\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Generic_Type_Modifier_290_compling_err_7.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:47:40\n   |\n47 | ...                   if let Type::Path(type_path) = &mut *ty {\n   |                              ^^^^^^^^^^^^^^^^^^^^^   -------- this expression has type `&mut std::boxed::Box<syn::Type>`\n   |                              |\n   |                              expected `Box<Type>`, found `Type`\n   |\n   = note: expected struct `std::boxed::Box<syn::Type>`\n                found enum `syn::Type`\nhelp: consider dereferencing to access the inner value using the Deref trait\n   |\n47 -                                 if let Type::Path(type_path) = &mut *ty {\n47 +                                 if let Type::Path(type_path) = &**ty {\n   |\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\generic_type_modifier_290.rs"
    },
    {
        "mutator_name": "Incorrect_Use_Of_Generic_Type_Parameters_303",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Incorrect_Use_Of_Generic_Type_Parameters_303_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0063]: missing field `qself` in initializer of `TypePath`\n  --> src\\main.rs:41:63\n   |\n41 | ...                   *ty = Box::new(Type::Path(TypePath {\n   |                                                 ^^^^^^^^ missing `qself`\n\nerror[E0063]: missing field `qself` in initializer of `TypePath`\n  --> src\\main.rs:55:63\n   |\n55 | ...                   *ty = Box::new(Type::Path(TypePath {\n   |                                                 ^^^^^^^^ missing `qself`\n\nFor more information about this error, try `rustc --explain E0063`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Incorrect_Use_Of_Generic_Type_Parameters_303_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:29\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                             ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n31 -             if let Item::Fn(ref mut func) = item {\n31 +             if let Item::Fn(func) = item {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\incorrect_use_of_generic_type_parameters_303.rs"
    },
    {
        "mutator_name": "Inject_Generator_Closure_Iterating_274",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Inject_Generator_Closure_Iterating_274_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0061]: this enum variant takes 2 arguments but 1 argument was supplied\n  --> src\\main.rs:54:46\n   |\n54 |                     item_fn.block.stmts.push(syn::Stmt::Expr(syn::Expr::Closure(closure)));\n   |                                              ^^^^^^^^^^^^^^^----------------------------- argument #2 of type `Option<Semi>` is missing\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:9\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |         ^^^^\nhelp: provide the argument\n   |\n54 |                     item_fn.block.stmts.push(syn::Stmt::Expr(syn::Expr::Closure(closure), /* Option<Semi> */));\n   |                                                                                         ++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0061`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\inject_generator_closure_iterating_274.rs"
    },
    {
        "mutator_name": "Inject_Static_Lifetime_309",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\inject_static_lifetime_309.rs"
    },
    {
        "mutator_name": "Inline_Assembly_Faulty_Const_317",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Inline_Assembly_Faulty_Const_317_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:32\n   |\n31 |             if let Item::Macro(ref mut macro_item) = item {\n   |                                ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Macro(ref mut macro_item) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n31 -             if let Item::Macro(ref mut macro_item) = item {\n31 +             if let Item::Macro(macro_item) = item {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\inline_assembly_faulty_const_317.rs"
    },
    {
        "mutator_name": "Introduce_Closure_With_Unknown_Var_252",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Introduce_Closure_With_Unknown_Var_252_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:34:47\n   |\n34 |                         if let syn::ImplItem::Method(method) = item {\n   |                                               ^^^^^^ variant or associated item not found in `ImplItem`\n\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:36:61\n   |\n36 | ...                   if let Type::ImplTrait(_) = **ty {\n   |                                                   ^^^^ can't be dereferenced\n\nerror[E0061]: this enum variant takes 2 arguments but 1 argument was supplied\n  --> src\\main.rs:41:54\n   |\n41 | ...                   block.stmts.push(Stmt::Expr(closure_expr));\n   |                                        ^^^^^^^^^^-------------- argument #2 of type `Option<Semi>` is missing\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:9\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |         ^^^^\nhelp: provide the argument\n   |\n41 |                                     block.stmts.push(Stmt::Expr(closure_expr, /* Option<Semi> */));\n   |                                                                             ++++++++++++++++++++\n\nSome errors have detailed explanations: E0061, E0599, E0614.\nFor more information about an error, try `rustc --explain E0061`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\introduce_closure_with_unknown_var_252.rs"
    },
    {
        "mutator_name": "Introduce_Inherent_Associated_Type_248",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Introduce_Inherent_Associated_Type_248_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: could not find `NestedMeta` in `syn`\n  --> src\\main.rs:39:45\n   |\n39 | ...                   if let syn::NestedMeta::Meta(syn::Meta::Path(path)) = nested_meta {\n   |                                   ^^^^^^^^^^ could not find `NestedMeta` in `syn`\n\nerror[E0615]: attempted to take value of method `path` on type `&Attribute`\n  --> src\\main.rs:34:39\n   |\n34 |             if let Some(ident) = attr.path.get_ident() {\n   |                                       ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n34 |             if let Some(ident) = attr.path().get_ident() {\n   |                                           ++\n\nerror[E0599]: no method named `parse_meta` found for reference `&Attribute` in the current scope\n   --> src\\main.rs:36:44\n    |\n36  |                     if let Ok(meta) = attr.parse_meta() {\n    |                                            ^^^^^^^^^^\n    |\nhelp: there is a method `parse_nested_meta` with a similar name, but with different arguments\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\attr.rs:391:5\n    |\n391 | /     pub fn parse_nested_meta(\n392 | |         &self,\n393 | |         logic: impl FnMut(ParseNestedMeta) -> Result<()>,\n394 | |     ) -> Result<()> {\n    | |___________________^\n\nerror[E0609]: no field `nested` on type `MetaList`\n  --> src\\main.rs:38:58\n   |\n38 | ...                   for nested_meta in meta_list.nested.iter() {\n   |                                                    ^^^^^^ unknown field\n   |\n   = note: available fields are: `path`, `delimiter`, `tokens`\n\nerror[E0308]: mismatched types\n   --> src\\main.rs:68:52\n    |\n68  |                     items.push(syn::ImplItem::Type(new_associated_type));\n    |                                ------------------- ^^^^^^^^^^^^^^^^^^^ expected `ImplItemType`, found `Item`\n    |                                |\n    |                                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\item.rs:706:9\n    |\n706 |         Type(ImplItemType),\n    |         ^^^^\n\nSome errors have detailed explanations: E0308, E0433, E0599, E0609, E0615.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 5 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Introduce_Inherent_Associated_Type_248_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0432]: unresolved import `syn::NestedMeta`\n  --> src\\main.rs:19:32\n   |\n19 |     Attribute, Meta, MetaList, NestedMeta, ImplItem, ImplItemType,\n   |                                ^^^^^^^^^^ no `NestedMeta` in the root\n\nerror[E0599]: no method named `parse_meta` found for reference `&Attribute` in the current scope\n   --> src\\main.rs:37:61\n    |\n37  |                     if let Ok(Meta::List(meta_list)) = attr.parse_meta() {\n    |                                                             ^^^^^^^^^^\n    |\nhelp: there is a method `parse_nested_meta` with a similar name, but with different arguments\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\attr.rs:391:5\n    |\n391 | /     pub fn parse_nested_meta(\n392 | |         &self,\n393 | |         logic: impl FnMut(ParseNestedMeta) -> Result<()>,\n394 | |     ) -> Result<()> {\n    | |___________________^\n\nerror[E0609]: no field `nested` on type `MetaList`\n  --> src\\main.rs:38:54\n   |\n38 |                         for nested_meta in meta_list.nested.iter() {\n   |                                                      ^^^^^^ unknown field\n   |\n   = note: available fields are: `path`, `delimiter`, `tokens`\n\nSome errors have detailed explanations: E0432, E0599, E0609.\nFor more information about an error, try `rustc --explain E0432`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Introduce_Inherent_Associated_Type_248_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0252]: the name `parse_quote` is defined multiple times\n --> src\\main.rs:5:46\n  |\n2 |     Attribute, Meta, MetaList, ImplItem, ImplItemType, parse_quote,\n  |                                                        ----------- previous import of the macro `parse_quote` here\n...\n5 |     TypeImplTrait, TypeParamBound, TypePath, parse_quote, token::Comma, token::{Paren, Plus},\n  |                                              ^^^^^^^^^^^--\n  |                                              |\n  |                                              `parse_quote` reimported here\n  |                                              help: remove unnecessary import\n  |\n  = note: `parse_quote` must be defined only once in the macro namespace of this module\n\nerror[E0433]: failed to resolve: use of undeclared type `TokenTree`\n  --> src\\main.rs:25:36\n   |\n25 | ...                   if let TokenTree::Ident(ident) = token {\n   |                              ^^^^^^^^^ use of undeclared type `TokenTree`\n   |\nhelp: consider importing this enum\n   |\n1  + use proc_macro2::TokenTree;\n   |\n\nerror[E0599]: no method named `parse_meta` found for reference `&Attribute` in the current scope\n   --> src\\main.rs:23:61\n    |\n23  |                     if let Ok(Meta::List(meta_list)) = attr.parse_meta() {\n    |                                                             ^^^^^^^^^^\n    |\nhelp: there is a method `parse_nested_meta` with a similar name, but with different arguments\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\attr.rs:391:5\n    |\n391 | /     pub fn parse_nested_meta(\n392 | |         &self,\n393 | |         logic: impl FnMut(ParseNestedMeta) -> Result<()>,\n394 | |     ) -> Result<()> {\n    | |___________________^\n\nSome errors have detailed explanations: E0252, E0433, E0599.\nFor more information about an error, try `rustc --explain E0252`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Introduce_Inherent_Associated_Type_248_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `parse_meta` found for reference `&Attribute` in the current scope\n   --> src\\main.rs:23:61\n    |\n23  |                     if let Ok(Meta::List(meta_list)) = attr.parse_meta() {\n    |                                                             ^^^^^^^^^^\n    |\nhelp: there is a method `parse_nested_meta` with a similar name, but with different arguments\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\attr.rs:391:5\n    |\n391 | /     pub fn parse_nested_meta(\n392 | |         &self,\n393 | |         logic: impl FnMut(ParseNestedMeta) -> Result<()>,\n394 | |     ) -> Result<()> {\n    | |___________________^\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Introduce_Inherent_Associated_Type_248_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0499]: cannot borrow `file.items` as mutable more than once at a time\n  --> src\\main.rs:58:21\n   |\n39 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     first mutable borrow occurs here\n   |                     first borrow later used here\n...\n58 |                     file.items.push(example_function);\n   |                     ^^^^^^^^^^ second mutable borrow occurs here\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\introduce_inherent_associated_type_248.rs"
    },
    {
        "mutator_name": "Invalid_Generic_Parameters_In_Method_Signatures_253",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Invalid_Generic_Parameters_In_Method_Signatures_253_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:40:70\n   |\n40 | ...                   if let GenericArgument::Type(ref mut typ) = arg {\n   |                                                    ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:40:48\n   |\n40 | ...                   if let GenericArgument::Type(ref mut typ) = arg {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n40 -                                         if let GenericArgument::Type(ref mut typ) = arg {\n40 +                                         if let GenericArgument::Type(typ) = arg {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\invalid_generic_parameters_in_method_signatures_253.rs"
    },
    {
        "mutator_name": "Lifetime_Parameter_Conflict_258",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [],
        "label": "Negative",
        "file": ".\\mutators\\lifetime_parameter_conflict_258.rs"
    },
    {
        "mutator_name": "Merge_Async_Function_Lifetimes_266",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Merge_Async_Function_Lifetimes_266_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Lifetime` cannot be dereferenced\n  --> src\\main.rs:67:61\n   |\n67 | ...                   if lifetime_def.lifetime == *first_lifetime {\n   |                                                   ^^^^^^^^^^^^^^^ can't be dereferenced\n\nFor more information about this error, try `rustc --explain E0614`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\merge_async_function_lifetimes_266.rs"
    },
    {
        "mutator_name": "Misplaced_Await_311",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Misplaced_Await_311_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:76:43\n   |\n76 |                         if let Stmt::Expr(Expr::Call(call)) = stmt {\n   |                                           ^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n76 |                         if let Stmt::Expr(Expr::Call(call), _) = stmt {\n   |                                                           +++\n\nFor more information about this error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Misplaced_Await_311_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0282]: type annotations needed\n  --> src\\main.rs:64:17\n   |\n64 |             let misplaced_await = parse_quote! {\n   |                 ^^^^^^^^^^^^^^^\n   |\nhelp: consider giving `misplaced_await` an explicit type\n   |\n64 |             let misplaced_await: /* Type */ = parse_quote! {\n   |                                ++++++++++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\misplaced_await_311.rs"
    },
    {
        "mutator_name": "Modify_Associated_Constants_295",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_associated_constants_295.rs"
    },
    {
        "mutator_name": "Modify_Associated_Types_363",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_associated_types_363.rs"
    },
    {
        "mutator_name": "Modify_Associated_Type_Constraints_256",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Associated_Type_Constraints_256_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:35:32\n   |\n35 |                         if let Some((_, bounds)) = &mut type_item.bounds {\n   |                                ^^^^^^^^^^^^^^^^^   --------------------- this expression has type `&mut syn::punctuated::Punctuated<TypeParamBound, syn::token::Plus>`\n   |                                |\n   |                                expected `Punctuated<TypeParamBound, Plus>`, found `Option<_>`\n   |\n   = note: expected struct `syn::punctuated::Punctuated<TypeParamBound, syn::token::Plus>`\n                found enum `Option<_>`\n\nerror[E0282]: type annotations needed\n  --> src\\main.rs:37:36\n   |\n37 | ...                   bounds.push(new_trait.clone());\n   |                              ^^^^ cannot infer type\n\nSome errors have detailed explanations: E0282, E0308.\nFor more information about an error, try `rustc --explain E0282`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_associated_type_constraints_256.rs"
    },
    {
        "mutator_name": "Modify_Associated_Type_In_Trait_Bounds_415",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Associated_Type_In_Trait_Bounds_415_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0658]: box pattern syntax is experimental\n  --> src\\main.rs:44:56\n   |\n44 | ...                   if let ReturnType::Type(_, box Type::ImplTrait(impl_trait)) = &fn_item.sig.output {\n   |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: see issue #29641 <https://github.com/rust-lang/rust/issues/29641> for more information\n   = help: add `#![feature(box_patterns)]` to the crate attributes to enable\n   = note: this compiler was built on 2025-05-09; consider upgrading it if it is out of date\n\nerror[E0499]: cannot borrow `file.items` as mutable more than once at a time\n  --> src\\main.rs:42:33\n   |\n30 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     first mutable borrow occurs here\n   |                     first borrow later used here\n...\n42 |                     for item in &mut file.items {\n   |                                 ^^^^^^^^^^^^^^^ second mutable borrow occurs here\n\nerror[E0596]: cannot borrow `impl_trait.bounds` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:46:46\n   |\n46 | ...                   for bound in &mut impl_trait.bounds {\n   |                                    ^^^^^^^^^^^^^^^^^^^^^^ `impl_trait` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nSome errors have detailed explanations: E0499, E0596, E0658.\nFor more information about an error, try `rustc --explain E0499`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_associated_type_in_trait_bounds_415.rs"
    },
    {
        "mutator_name": "Modify_Associated_Type_With_Default_Impl_419",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Associated_Type_With_Default_Impl_419_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:55:33\n   |\n55 |                     if let Some((_, ref mut where_clause)) = i.generics.where_clause {\n   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^    ----------------------- this expression has type `Option<WhereClause>`\n   |                                 |\n   |                                 expected `WhereClause`, found `(_, _)`\n   |\n   = note: expected struct `WhereClause`\n               found tuple `(_, _)`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_associated_type_with_default_impl_419.rs"
    },
    {
        "mutator_name": "Modify_Closure_Invocation_And_Output_441",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Closure_Invocation_And_Output_441_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:45:47\n   |\n45 |                         if let syn::ImplItem::Method(method) = item {\n   |                                               ^^^^^^ variant or associated item not found in `ImplItem`\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:47:51\n   |\n47 | ...                   if let Stmt::Expr(expr) = stmt {\n   |                                         ^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n47 |                                 if let Stmt::Expr(expr, _) = stmt {\n   |                                                       +++\n\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:49:85\n   |\n49 | ...                   if let Expr::Path(ExprPath { path, .. }) = &**func {\n   |                                                                   ^^^^^^ can't be dereferenced\n\nSome errors have detailed explanations: E0023, E0599, E0614.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Closure_Invocation_And_Output_441_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:49:48\n   |\n49 | ...                   if let Expr::Path(ExprPath { path, .. }) = &*func {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ------ this expression has type `&std::boxed::Box<syn::Expr>`\n   |                              |\n   |                              expected `Box<Expr>`, found `Expr`\n   |\n   = note: expected struct `std::boxed::Box<syn::Expr>`\n                found enum `syn::Expr`\nhelp: consider dereferencing to access the inner value using the Deref trait\n   |\n49 |                                         if let Expr::Path(ExprPath { path, .. }) = &**func {\n   |                                                                                      +\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Closure_Invocation_And_Output_441_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0382]: use of moved value\n  --> src\\main.rs:58:41\n   |\n58 | ...                   if let Some(expr) = closure_invocation {\n   |                                   ^^^^ value moved here, in previous iteration of loop\n   |\nnote: these 2 reinitializations might get skipped\n  --> src\\main.rs:34:65\n   |\n34 |                 let mut closure_invocation: Option<&mut Expr> = None;\n   |                                                                 ^^^^\n...\n51 |                                                 closure_invocation = Some(expr);\n   |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   = note: move occurs because value has type `&mut syn::Expr`, which does not implement the `Copy` trait\nhelp: borrow this binding in the pattern to avoid moving the value\n   |\n58 |                             if let Some(ref expr) = closure_invocation {\n   |                                         +++\n\nFor more information about this error, try `rustc --explain E0382`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Closure_Invocation_And_Output_441_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:39:41\n   |\n39 | ...                   *expr = parse_quote! {\n   |                               ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:12:20\n   |\n12 |             if let Item::Impl(item_impl) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0412]: cannot find type `Expr` in this scope\n  --> src\\main.rs:14:57\n   |\n14 |                 let mut closure_invocation: Option<&mut Expr> = None;\n   |                                                         ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:27:40\n   |\n27 | ...                   if let Stmt::Expr(expr, _) = stmt {\n   |                              ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:28:44\n   |\n28 | ...                   if let Expr::Call(ExprCall { func, .. }) = expr {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `ExprCall` in this scope\n  --> src\\main.rs:28:55\n   |\n28 | ...                   if let Expr::Call(ExprCall { func, .. }) = expr {\n   |                                         ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::ExprCall;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:29:48\n   |\n29 | ...                   if let Expr::Path(ExprPath { path, .. }) = &**func {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `ExprPath` in this scope\n  --> src\\main.rs:29:59\n   |\n29 | ...                   if let Expr::Path(ExprPath { path, .. }) = &**func {\n   |                                         ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::ExprPath;\n   |\n\nSome errors have detailed explanations: E0412, E0422, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 8 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Closure_Invocation_And_Output_441_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Modify_Closure_Invocation_And_Output_441 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Closure_Invocation_And_Output_441_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:27:51\n   |\n27 | ...                   if let Stmt::Expr(expr) = stmt {\n   |                                         ^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n27 |                                 if let Stmt::Expr(expr, _) = stmt {\n   |                                                       +++\n\nerror[E0277]: the trait bound `&mut syn::Expr: syn::parse_quote::ParseQuote` is not satisfied\n   --> src\\main.rs:39:41\n    |\n39  |   ...                   *expr = parse_quote! {\n    |  _______________________________^\n40  | | ...                       let _ = async { #expr };\n41  | | ...                   };\n    | |_______________________^ the trait `Parse` is not implemented for `&mut syn::Expr`\n    |\n    = help: the trait `Parse` is implemented for `syn::Expr`\n    = note: required for `&mut syn::Expr` to implement `syn::parse_quote::ParseQuote`\nnote: required by a bound in `parse_quote`\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\parse_quote.rs:117:17\n    |\n117 | pub fn parse<T: ParseQuote>(token_stream: TokenStream) -> T {\n    |                 ^^^^^^^^^^ required by this bound in `parse`\n    = note: this error originates in the macro `parse_quote` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0023, E0277.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Closure_Invocation_And_Output_441_compling_err_7.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0425]: cannot find value `stmt` in this scope\n  --> src\\main.rs:42:34\n   |\n42 | ...                   *stmt = Stmt::Expr(new_expr, None);\n   |                        ^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_closure_invocation_and_output_441.rs"
    },
    {
        "mutator_name": "Modify_Constant_Array_Elements_388",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Constant_Array_Elements_388_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `shuffle` found for struct `syn::punctuated::Punctuated` in the current scope\n  --> src\\main.rs:36:35\n   |\n36 |                         new_elems.shuffle(&mut rng);\n   |                                   ^^^^^^^ method not found in `Punctuated<Expr, Comma>`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_constant_array_elements_388.rs"
    },
    {
        "mutator_name": "Modify_Constant_Parameters_In_Structs_297",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Constant_Parameters_In_Structs_297_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0422]: cannot find struct, variant or union type `LifetimeDef` in this scope\n  --> src\\main.rs:47:82\n   |\n47 |                     item_struct.generics.params.insert(0, GenericParam::Lifetime(LifetimeDef {\n   |                                                                                  ^^^^^^^^^^^ help: a struct with a similar name exists: `Lifetime`\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\lifetime.rs:18:1\n   |\n18 | pub struct Lifetime {\n   | ------------------- similarly named struct `Lifetime` defined here\n\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:35:61\n   |\n35 |                         if let Type::Reference(type_ref) = &*const_param.ty {\n   |                                                             ^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:38:50\n   |\n38 |   ...                   const_param.ty = Box::new(Type::Reference(TypeReference {\n   |  _______________________--------------___^\n   | |                       |\n   | |                       expected due to the type of this binding\n39 | | ...                       lifetime: Some(Lifetime::new(\"'a\", Span::call_site())),\n40 | | ...                       ..type_ref.clone()\n41 | | ...                   }));\n   | |_________________________^ expected `Type`, found `Box<Type>`\n   |\n   = note: expected enum `syn::Type`\n            found struct `std::boxed::Box<syn::Type>`\nhelp: consider unboxing the value\n   |\n38 |                                 const_param.ty = *Box::new(Type::Reference(TypeReference {\n   |                                                  +\n\nSome errors have detailed explanations: E0308, E0422, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Constant_Parameters_In_Structs_297_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `as_ref` found for enum `syn::Type` in the current scope\n  --> src\\main.rs:35:75\n   |\n35 |                         if let Type::Reference(type_ref) = const_param.ty.as_ref() {\n   |                                                                           ^^^^^^ method not found in `syn::Type`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Constant_Parameters_In_Structs_297_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:35:61\n   |\n35 |                         if let Type::Reference(type_ref) = &*const_param.ty {\n   |                                                             ^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:38:50\n   |\n38 |   ...                   const_param.ty = Box::new(Type::Reference(TypeReference {\n   |  _______________________--------------___^\n   | |                       |\n   | |                       expected due to the type of this binding\n39 | | ...                       lifetime: Some(Lifetime::new(\"'a\", Span::call_site())),\n40 | | ...                       ..type_ref.clone()\n41 | | ...                   }));\n   | |_________________________^ expected `Type`, found `Box<Type>`\n   |\n   = note: expected enum `syn::Type`\n            found struct `std::boxed::Box<syn::Type>`\nhelp: consider unboxing the value\n   |\n38 |                                 const_param.ty = *Box::new(Type::Reference(TypeReference {\n   |                                                  +\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Constant_Parameters_In_Structs_297_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `as_ref` found for enum `syn::Type` in the current scope\n  --> src\\main.rs:35:75\n   |\n35 |                         if let Type::Reference(type_ref) = const_param.ty.as_ref() {\n   |                                                                           ^^^^^^ method not found in `syn::Type`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Constant_Parameters_In_Structs_297_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:35:61\n   |\n35 |                         if let Type::Reference(type_ref) = &*const_param.ty {\n   |                                                             ^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:38:50\n   |\n38 |   ...                   const_param.ty = Box::new(Type::Reference(TypeReference {\n   |  _______________________--------------___^\n   | |                       |\n   | |                       expected due to the type of this binding\n39 | | ...                       lifetime: Some(Lifetime::new(\"'a\", Span::call_site())),\n40 | | ...                       ..type_ref.clone()\n41 | | ...                   }));\n   | |_________________________^ expected `Type`, found `Box<Type>`\n   |\n   = note: expected enum `syn::Type`\n            found struct `std::boxed::Box<syn::Type>`\nhelp: consider unboxing the value\n   |\n38 |                                 const_param.ty = *Box::new(Type::Reference(TypeReference {\n   |                                                  +\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Constant_Parameters_In_Structs_297_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `as_ref` found for enum `syn::Type` in the current scope\n  --> src\\main.rs:35:75\n   |\n35 |                         if let Type::Reference(type_ref) = const_param.ty.as_ref() {\n   |                                                                           ^^^^^^ method not found in `syn::Type`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Constant_Parameters_In_Structs_297_compling_err_7.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:35:61\n   |\n35 |                         if let Type::Reference(type_ref) = &*const_param.ty {\n   |                                                             ^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:38:50\n   |\n38 |   ...                   const_param.ty = Box::new(Type::Reference(TypeReference {\n   |  _______________________--------------___^\n   | |                       |\n   | |                       expected due to the type of this binding\n39 | | ...                       lifetime: Some(Lifetime::new(\"'a\", Span::call_site())),\n40 | | ...                       ..type_ref.clone()\n41 | | ...                   }));\n   | |_________________________^ expected `Type`, found `Box<Type>`\n   |\n   = note: expected enum `syn::Type`\n            found struct `std::boxed::Box<syn::Type>`\nhelp: consider unboxing the value\n   |\n38 |                                 const_param.ty = *Box::new(Type::Reference(TypeReference {\n   |                                                  +\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Constant_Parameters_In_Structs_297_compling_err_8.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `as_ref` found for enum `syn::Type` in the current scope\n  --> src\\main.rs:35:75\n   |\n35 |                         if let Type::Reference(type_ref) = const_param.ty.as_ref() {\n   |                                                                           ^^^^^^ method not found in `syn::Type`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_constant_parameters_in_structs_297.rs"
    },
    {
        "mutator_name": "Modify_Const_Declaration_With_Unicode_Character_357",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Declaration_With_Unicode_Character_357_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:47:38\n   |\n47 |                 let new_expr: Expr = parse_str(&mutated_expr).unwrap_or_else(|_| const_value.clone());\n   |                               ----   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Expr`, found `Box<Expr>`\n   |                               |\n   |                               expected due to this\n   |\n   = note: expected enum `syn::Expr`\n            found struct `std::boxed::Box<syn::Expr>`\nhelp: consider unboxing the value\n   |\n47 |                 let new_expr: Expr = *parse_str(&mutated_expr).unwrap_or_else(|_| const_value.clone());\n   |                                      +\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_const_declaration_with_unicode_character_357.rs"
    },
    {
        "mutator_name": "Modify_Const_Generics_Invalid_Type_385",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generics_Invalid_Type_385_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:32:24\n   |\n32 |                 if let Some((_, ref mut generics, _)) = func.sig.generics.split_for_impl() {\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ---------------------------------- this expression has type `(ImplGenerics<'_>, TypeGenerics<'_>, Option<&WhereClause>)`\n   |                        |\n   |                        expected `(ImplGenerics<'_>, ..., ...)`, found `Option<_>`\n   |\n   = note: expected tuple `(ImplGenerics<'_>, TypeGenerics<'_>, Option<&WhereClause>)`\n               found enum `Option<_>`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generics_Invalid_Type_385_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:29\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                             ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n31 -             if let Item::Fn(ref mut func) = item {\n31 +             if let Item::Fn(func) = item {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:34:48\n   |\n34 |                     if let GenericParam::Const(ref mut const_param) = param {\n   |                                                ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:34:28\n   |\n34 |                     if let GenericParam::Const(ref mut const_param) = param {\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n34 -                     if let GenericParam::Const(ref mut const_param) = param {\n34 +                     if let GenericParam::Const(const_param) = param {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generics_Invalid_Type_385_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Fn(func) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericParam`\n  --> src\\main.rs:14:28\n   |\n14 |                     if let GenericParam::Const(const_param) = param {\n   |                            ^^^^^^^^^^^^ use of undeclared type `GenericParam`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:15:32\n   |\n15 |                         if let Type::Path(type_path) = &mut const_param.ty {\n   |                                ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:18:53\n   |\n18 | ...                   segment.ident = Ident::new(\"String\", segment.ident.span());\n   |                                       ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nFor more information about this error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generics_Invalid_Type_385_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `mutate` found for struct `Modify_Const_Generics_Invalid_Type_385` in the current scope\n  --> src\\main.rs:54:52\n   |\n4  | pub struct Modify_Const_Generics_Invalid_Type_385;\n   | ------------------------------------------------- method `mutate` not found for this struct\n...\n54 |             Modify_Const_Generics_Invalid_Type_385.mutate(&mut file_ast);\n   |                                                    ^^^^^^ method not found in `Modify_Const_Generics_Invalid_Type_385`\n   |\n  ::: src\\mutator.rs:15:8\n   |\n15 |     fn mutate(&self, file: &mut syn::File);\n   |        ------ the method is available for `Modify_Const_Generics_Invalid_Type_385` here\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: trait `Mutator` which provides `mutate` is implemented but not in scope; perhaps you want to import it\n   |\n1  + use crate::mutator::Mutator;\n   |\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_const_generics_invalid_type_385.rs"
    },
    {
        "mutator_name": "Modify_Const_Generics_In_Function_Constraints_410",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generics_In_Function_Constraints_410_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `first_mut` found for enum `PathArguments` in the current scope\n  --> src\\main.rs:41:79\n   |\n41 | ...                   .and_then(|segment| segment.arguments.first_mut())\n   |                                                             ^^^^^^^^^ method not found in `PathArguments`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generics_In_Function_Constraints_410_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0594]: cannot assign to `*ident`, which is behind a `&` reference\n  --> src\\main.rs:44:65\n   |\n42 | ...                   if let Some(ident) = expr_path.path.get_ident() {\n   |                                   ----- consider changing this binding's type to be: `&mut proc_macro2::Ident`\n43 | ...                       if ident == \"usize\" {\n44 | ...                           *ident = Ident::new(\"u8\", ident.span());\n   |                               ^^^^^^ `ident` is a `&` reference, so the data it refers to cannot be written\n\nerror[E0499]: cannot borrow `trait_bound.path.segments` as mutable more than once at a time\n  --> src\\main.rs:45:93\n   |\n37 | ...                   if let Some(segment) = trait_bound.path.segments.first_mut() {\n   |                                              ------------------------- first mutable borrow occurs here\n38 | ...                       if let PathArguments::AngleBracketed(angle_bracketed_args) = &mut segment.arguments {\n39 | ...                           for arg in &mut angle_bracketed_args.args {\n   |                                          ------------------------------ first borrow later used here\n...\n45 | ...                                               if let Some(last_segment) = trait_bound.path.segments.last_mut() {\n   |                                                                               ^^^^^^^^^^^^^^^^^^^^^^^^^ second mutable borrow occurs here\n\nSome errors have detailed explanations: E0499, E0594.\nFor more information about an error, try `rustc --explain E0499`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generics_In_Function_Constraints_410_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0499]: cannot borrow `trait_bound.path.segments` as mutable more than once at a time\n  --> src\\main.rs:46:93\n   |\n37 | ...                   if let Some(segment) = trait_bound.path.segments.first_mut() {\n   |                                              ------------------------- first mutable borrow occurs here\n38 | ...                       if let PathArguments::AngleBracketed(angle_bracketed_args) = &mut segment.arguments {\n39 | ...                           for arg in &mut angle_bracketed_args.args {\n   |                                          ------------------------------ first borrow later used here\n...\n46 | ...                                               if let Some(last_segment) = trait_bound.path.segments.last_mut() {\n   |                                                                               ^^^^^^^^^^^^^^^^^^^^^^^^^ second mutable borrow occurs here\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_const_generics_in_function_constraints_410.rs"
    },
    {
        "mutator_name": "Modify_Const_Generics_Type_319",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generics_Type_319_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:32:24\n   |\n32 |                 if let Some((_, generics, _)) = &item_fn.sig.generics.split_for_impl() {\n   |                        ^^^^^^^^^^^^^^^^^^^^^^   -------------------------------------- this expression has type `&(ImplGenerics<'_>, TypeGenerics<'_>, Option<&WhereClause>)`\n   |                        |\n   |                        expected `(ImplGenerics<'_>, ..., ...)`, found `Option<_>`\n   |\n   = note: expected tuple `(ImplGenerics<'_>, TypeGenerics<'_>, Option<&WhereClause>)`\n               found enum `Option<_>`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generics_Type_319_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `generics.params` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:33:30\n   |\n33 |                 for param in &mut generics.params {\n   |                              ^^^^^^^^^^^^^^^^^^^^ `generics` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n   |\nhelp: consider changing this to be a mutable reference\n   |\n32 |                 let generics = &mut item_fn.sig.generics;\n   |                                 +++\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generics_Type_319_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:18:54\n   |\n18 | ...                   const_param.ty = parse_quote! { u32 };\n   |                                        ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Fn(item_fn) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericParam`\n  --> src\\main.rs:14:28\n   |\n14 |                     if let GenericParam::Const(const_param) = param {\n   |                            ^^^^^^^^^^^^ use of undeclared type `GenericParam`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:15:32\n   |\n15 |                         if let Type::Path(type_path) = &const_param.ty {\n   |                                ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nFor more information about this error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generics_Type_319_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Modify_Const_Generics_Type_319 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_const_generics_type_319.rs"
    },
    {
        "mutator_name": "Modify_Const_Generic_Parameter_In_Struct_381",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Generic_Parameter_In_Struct_381_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:33:24\n   |\n33 |                 if let Some((_, generics, _)) = &item_struct.generics.split_for_impl() {\n   |                        ^^^^^^^^^^^^^^^^^^^^^^   -------------------------------------- this expression has type `&(ImplGenerics<'_>, TypeGenerics<'_>, Option<&WhereClause>)`\n   |                        |\n   |                        expected `(ImplGenerics<'_>, ..., ...)`, found `Option<_>`\n   |\n   = note: expected tuple `(ImplGenerics<'_>, TypeGenerics<'_>, Option<&WhereClause>)`\n               found enum `Option<_>`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_const_generic_parameter_in_struct_381.rs"
    },
    {
        "mutator_name": "Modify_Const_Params_433",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Params_433_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:32:29\n   |\n32 |             if let Item::Fn(ref mut func) = item {\n   |                             ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:32:20\n   |\n32 |             if let Item::Fn(ref mut func) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n32 -             if let Item::Fn(ref mut func) = item {\n32 +             if let Item::Fn(func) = item {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Params_433_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:24:69\n   |\n24 | ...                   *expr = parse_quote!({ false });\n   |                               ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:12:20\n   |\n12 |             if let Item::Fn(func) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TypeParamBound`\n  --> src\\main.rs:17:40\n   |\n17 | ...                   if let TypeParamBound::Trait(trait_bound) = bound {\n   |                              ^^^^^^^^^^^^^^ use of undeclared type `TypeParamBound`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TypeParamBound;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `PathArguments`\n  --> src\\main.rs:19:48\n   |\n19 | ...                   if let PathArguments::AngleBracketed(ref mut data) = segment.arguments {\n   |                              ^^^^^^^^^^^^^ use of undeclared type `PathArguments`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::PathArguments;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericArgument`\n  --> src\\main.rs:21:56\n   |\n21 | ...                   if let GenericArgument::Const(expr) = arg {\n   |                              ^^^^^^^^^^^^^^^ use of undeclared type `GenericArgument`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericArgument;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:22:60\n   |\n22 | ...                   if let Expr::Lit(expr_lit) = expr {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nFor more information about this error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 6 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Params_433_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Modify_Const_Params_433 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_const_params_433.rs"
    },
    {
        "mutator_name": "Modify_Enum_Variant_Pattern_293",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Enum_Variant_Pattern_293_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:35:37\n   |\n35 |                         if let Some((_, expr)) = &local.init {\n   |                                     ^^^^^^^^^    ----------- this expression has type `&Option<LocalInit>`\n   |                                     |\n   |                                     expected `LocalInit`, found `(_, _)`\n   |\n   = note: expected struct `LocalInit`\n               found tuple `(_, _)`\n\nerror[E0614]: type `Pat` cannot be dereferenced\n  --> src\\main.rs:36:74\n   |\n36 | ...                   if let Pat::TupleStruct(pat_tuple_struct) = &*local.pat {\n   |                                                                    ^^^^^^^^^^ can't be dereferenced\n\nerror[E0063]: missing field `attrs` in initializer of `PatIdent`\n  --> src\\main.rs:43:66\n   |\n43 | ...                   pat: Box::new(Pat::Ident(syn::PatIdent {\n   |                                                ^^^^^^^^^^^^^ missing `attrs`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:43:46\n   |\n43 |   ...                   pat: Box::new(Pat::Ident(syn::PatIdent {\n   |  ____________________________^\n44 | | ...                       ident: Ident::new(\"e_variant\", Span::call_site()),\n45 | | ...                       subpat: None,\n46 | | ...                       by_ref: None,\n47 | | ...                       mutability: None,\n48 | | ...                   })),\n   | |_________________________^ expected `Pat`, found `Box<Pat>`\n   |\n   = note: expected enum `Pat`\n            found struct `std::boxed::Box<Pat>`\nhelp: consider unboxing the value\n   |\n43 |                                         pat: *Box::new(Pat::Ident(syn::PatIdent {\n   |                                              +\n\nerror[E0308]: mismatched types\n   --> src\\main.rs:49:52\n    |\n49  | ...                   init: Some((token::Eq::default(), Box::new(new_expr))),\n    |                             ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `LocalInit`, found `(Eq, Box<_>)`\n    |                             |\n    |                             arguments to this enum variant are incorrect\n    |\n    = note: expected struct `LocalInit`\n                found tuple `(syn::token::Eq, std::boxed::Box<_>)`\nhelp: the type constructed contains `(syn::token::Eq, std::boxed::Box<_>)` due to the type of the argument passed\n   --> src\\main.rs:49:47\n    |\n49  | ...                   init: Some((token::Eq::default(), Box::new(new_expr))),\n    |                             ^^^^^------------------------------------------^\n    |                                  |\n    |                                  this argument influences the type of `Some`\nnote: tuple variant defined here\n   --> C:\\Users\\love\\.rustup\\toolchains\\nightly-2025-05-10-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\option.rs:597:5\n    |\n597 |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    |     ^^^^\n\nSome errors have detailed explanations: E0063, E0308, E0614.\nFor more information about an error, try `rustc --explain E0063`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 5 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_enum_variant_pattern_293.rs"
    },
    {
        "mutator_name": "Modify_Enum_Variant_With_PhantomData_322",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Enum_Variant_With_PhantomData_322_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0283]: type annotations needed\n  --> src\\main.rs:36:46\n   |\n36 | ...                   fields.unnamed = Punctuated::from_iter(vec![parse_quote!(#phantom_type)]);\n   |                                        ^^^^^^^^^^^^^^^^^^^^^ cannot infer type of the type parameter `T` declared on the associated function `from_iter`\n   |\n   = note: multiple `impl`s satisfying `syn::punctuated::Punctuated<syn::Field, syn::token::Comma>: FromIterator<_>` found in the `syn` crate:\n           - impl<T, P> FromIterator<Pair<T, P>> for syn::punctuated::Punctuated<T, P>;\n           - impl<T, P> FromIterator<T> for syn::punctuated::Punctuated<T, P>\n             where P: std::default::Default;\nhelp: consider specifying the generic argument\n   |\n36 |                             fields.unnamed = Punctuated::from_iter::<Vec<_>>(vec![parse_quote!(#phantom_type)]);\n   |                                                                   ++++++++++\n\nFor more information about this error, try `rustc --explain E0283`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Enum_Variant_With_PhantomData_322_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:13:54\n   |\n13 | ...                   let phantom_type: Type = parse_quote!(std::marker::PhantomData<i32>);\n   |                                                ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:14:94\n   |\n14 | ...                   fields.unnamed = Punctuated::<syn::Field, Comma>::from_iter(vec![parse_quote!(#phantom_type)]);\n   |                                                                                        ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:3:6\n  |\n3 | impl Mutator for Modify_Enum_Variant_With_PhantomData_322 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n --> src\\main.rs:9:20\n  |\n9 |             if let Item::Enum(item_enum) = item {\n  |                    ^^^^ use of undeclared type `Item`\n  |\nhelp: consider importing this enum\n  |\n1 + use syn::Item;\n  |\n\nerror[E0412]: cannot find type `Type` in this scope\n  --> src\\main.rs:13:47\n   |\n13 | ...                   let phantom_type: Type = parse_quote!(std::marker::PhantomData<i32>);\n   |                                         ^^^^ not found in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Punctuated`\n  --> src\\main.rs:14:46\n   |\n14 | ...                   fields.unnamed = Punctuated::<syn::Field, Comma>::from_iter(vec![parse_quote!(#phantom_type)]);\n   |                                        ^^^^^^^^^^ use of undeclared type `Punctuated`\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::punctuated::Punctuated;\n   |\n\nerror[E0412]: cannot find type `Comma` in this scope\n  --> src\\main.rs:14:71\n   |\n14 | ...                   fields.unnamed = Punctuated::<syn::Field, Comma>::from_iter(vec![parse_quote!(#phantom_type)]);\n   |                                                                 ^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::token::Comma;\n   |\n\nSome errors have detailed explanations: E0405, E0412, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 7 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Enum_Variant_With_PhantomData_322_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0283]: type annotations needed\n  --> src\\main.rs:21:46\n   |\n21 | ...                   fields.unnamed = Punctuated::<syn::Field, Comma>::from_iter(vec![parse_quote!(#phantom_type)]);\n   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type of the type parameter `T` declared on the associated function `from_iter`\n   |\n   = note: multiple `impl`s satisfying `syn::punctuated::Punctuated<syn::Field, syn::token::Comma>: FromIterator<_>` found in the `syn` crate:\n           - impl<T, P> FromIterator<Pair<T, P>> for syn::punctuated::Punctuated<T, P>;\n           - impl<T, P> FromIterator<T> for syn::punctuated::Punctuated<T, P>\n             where P: std::default::Default;\nhelp: consider specifying the generic argument\n   |\n21 |                             fields.unnamed = Punctuated::<syn::Field, Comma>::from_iter::<Vec<_>>(vec![parse_quote!(#phantom_type)]);\n   |                                                                                        ++++++++++\n\nFor more information about this error, try `rustc --explain E0283`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Enum_Variant_With_PhantomData_322_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0283]: type annotations needed\n  --> src\\main.rs:21:46\n   |\n21 | ...                   fields.unnamed = Punctuated::<syn::Field, Comma>::from_iter(vec![parse_quote!(#phantom_type)].into_iter());\n   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type of the type parameter `T` declared on the associated function `from_iter`\n   |\n   = note: multiple `impl`s satisfying `syn::punctuated::Punctuated<syn::Field, syn::token::Comma>: FromIterator<_>` found in the `syn` crate:\n           - impl<T, P> FromIterator<Pair<T, P>> for syn::punctuated::Punctuated<T, P>;\n           - impl<T, P> FromIterator<T> for syn::punctuated::Punctuated<T, P>\n             where P: std::default::Default;\nhelp: consider specifying the generic argument\n   |\n21 |                             fields.unnamed = Punctuated::<syn::Field, Comma>::from_iter::<std::vec::IntoIter<T>>(vec![parse_quote!(#phantom_type)].into_iter());\n   |                                                                                        +++++++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0283`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Enum_Variant_With_PhantomData_322_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0283]: type annotations needed\n  --> src\\main.rs:21:46\n   |\n21 | ...                   fields.unnamed = Punctuated::<syn::Field, Comma>::from_iter(vec![parse_quote!(#phantom_type)].into_iter());\n   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type of the type parameter `T` declared on the associated function `from_iter`\n   |\n   = note: multiple `impl`s satisfying `syn::punctuated::Punctuated<syn::Field, syn::token::Comma>: FromIterator<_>` found in the `syn` crate:\n           - impl<T, P> FromIterator<Pair<T, P>> for syn::punctuated::Punctuated<T, P>;\n           - impl<T, P> FromIterator<T> for syn::punctuated::Punctuated<T, P>\n             where P: std::default::Default;\nhelp: consider specifying the generic argument\n   |\n21 |                             fields.unnamed = Punctuated::<syn::Field, Comma>::from_iter::<std::vec::IntoIter<T>>(vec![parse_quote!(#phantom_type)].into_iter());\n   |                                                                                        +++++++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0283`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Enum_Variant_With_PhantomData_322_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0063]: missing field `mutability` in initializer of `syn::Field`\n  --> src\\main.rs:21:144\n   |\n21 | ...[parse_quote!(#phantom_type)].into_iter().map(|ty| syn::Field {\n   |                                                       ^^^^^^^^^^ missing `mutability`\n\nFor more information about this error, try `rustc --explain E0063`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Enum_Variant_With_PhantomData_322_compling_err_7.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:26:45\n   |\n26 | ...                   mutability: None,\n   |                                   ^^^^ expected `FieldMutability`, found `Option<_>`\n   |\n   = note: expected enum `FieldMutability`\n              found enum `Option<_>`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_enum_variant_with_phantomdata_322.rs"
    },
    {
        "mutator_name": "Modify_Function_Parameter_Type_339",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Function_Parameter_Type_339_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:40:39\n   |\n40 | ...                   ..input.clone()\n   |                         ^^^^^^^^^^^^^ expected `PatType`, found `FnArg`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Function_Parameter_Type_339_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:29\n   |\n31 |             if let Item::Fn(ref mut item_fn) = item {\n   |                             ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Fn(ref mut item_fn) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n31 -             if let Item::Fn(ref mut item_fn) = item {\n31 +             if let Item::Fn(item_fn) = item {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Function_Parameter_Type_339_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:17:54\n   |\n17 | ...                   let box_type: Type = parse_quote! { Box<[T]> };\n   |                                            ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Fn(item_fn) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Punctuated`\n  --> src\\main.rs:12:38\n   |\n12 |                 let mut new_inputs = Punctuated::new();\n   |                                      ^^^^^^^^^^ use of undeclared type `Punctuated`\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::punctuated::Punctuated;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `FnArg`\n  --> src\\main.rs:14:28\n   |\n14 |                     if let FnArg::Typed(PatType { pat, ty, attrs, colon_token }) = input {\n   |                            ^^^^^ use of undeclared type `FnArg`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::FnArg;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `PatType` in this scope\n  --> src\\main.rs:14:41\n   |\n14 |                     if let FnArg::Typed(PatType { pat, ty, attrs, colon_token }) = input {\n   |                                         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::PatType;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:15:32\n   |\n15 |                         if let Type::Reference(type_reference) = &**ty {\n   |                                ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:16:36\n   |\n16 | ...                   if let Type::Slice(_) = &*type_reference.elem {\n   |                              ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0412]: cannot find type `Type` in this scope\n  --> src\\main.rs:17:47\n   |\n17 | ...                   let box_type: Type = parse_quote! { Box<[T]> };\n   |                                     ^^^^ not found in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `FnArg`\n  --> src\\main.rs:18:49\n   |\n18 | ...                   let new_input = FnArg::Typed(PatType {\n   |                                       ^^^^^ use of undeclared type `FnArg`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::FnArg;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `PatType` in this scope\n  --> src\\main.rs:18:62\n   |\n18 | ...                   let new_input = FnArg::Typed(PatType {\n   |                                                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::PatType;\n   |\n\nSome errors have detailed explanations: E0412, E0422, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 10 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Function_Parameter_Type_339_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n  --> src\\main.rs:10:6\n   |\n10 | impl Mutator for Modify_Function_Parameter_Type_339 {\n   |      ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this trait\n   |\n1  + use crate::mutator::Mutator;\n   |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_function_parameter_type_339.rs"
    },
    {
        "mutator_name": "Modify_Function_Return_Type_265",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Function_Return_Type_265_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:29\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                             ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n31 -             if let Item::Fn(ref mut func) = item {\n31 +             if let Item::Fn(func) = item {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Function_Return_Type_265_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.84s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:33:49:\nunexpected end of input, expected identifier\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_function_return_type_265.rs"
    },
    {
        "mutator_name": "Modify_Function_Return_Type_With_Generics_335",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Function_Return_Type_With_Generics_335_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:34:43\n   |\n34 |                     if let syn::ImplItem::Method(method) = impl_item {\n   |                                           ^^^^^^ variant or associated item not found in `ImplItem`\n\nerror[E0599]: no variant or associated item named `Binding` found for enum `GenericArgument` in the current scope\n  --> src\\main.rs:42:73\n   |\n42 | ...                   if let GenericArgument::Binding(binding) = arg {\n   |                                               ^^^^^^^ variant or associated item not found in `GenericArgument`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Function_Return_Type_With_Generics_335_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `path.segments` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:37:61\n   |\n37 | ...                   if let Some(last_segment) = path.segments.last_mut() {\n   |                                                   ^^^^^^^^^^^^^ `path` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_function_return_type_with_generics_335.rs"
    },
    {
        "mutator_name": "Modify_Function_Return_Type_With_Incomplete_Impl_Trait_277",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Function_Return_Type_With_Incomplete_Impl_Trait_277_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `type_impl_trait.bounds` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:36:29\n   |\n36 | ...                   type_impl_trait.bounds.clear();\n   |                       ^^^^^^^^^^^^^^^^^^^^^^ `type_impl_trait` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_function_return_type_with_incomplete_impl_trait_277.rs"
    },
    {
        "mutator_name": "Modify_Function_Signature_In_Trait_Impl_424",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Function_Signature_In_Trait_Impl_424_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0432]: unresolved import `syn::TraitItemMethod`\n --> src\\main.rs:9:38\n  |\n9 |     PathArguments, ReturnType, Stmt, TraitItemMethod, Type, TypeImplTrait,\n  |                                      ^^^^^^^^^^^^^^^\n  |                                      |\n  |                                      no `TraitItemMethod` in the root\n  |                                      help: a similar name exists in the module: `TraitItemMacro`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:33:43\n   |\n33 |                     if let syn::ImplItem::Method(method) = item {\n   |                                           ^^^^^^ variant or associated item not found in `ImplItem`\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_function_signature_in_trait_impl_424.rs"
    },
    {
        "mutator_name": "Modify_Function_Signature_Reference_315",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_function_signature_reference_315.rs"
    },
    {
        "mutator_name": "Modify_Trait_Bound_In_Impl_379",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_bound_in_impl_379.rs"
    },
    {
        "mutator_name": "Modify_Function_Trait_Bound_438",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_function_trait_bound_438.rs"
    },
    {
        "mutator_name": "Modify_GAT_Lifetime_Constraints_283",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_GAT_Lifetime_Constraints_283_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:36:36\n   |\n36 | ...                   if let Some((_, ref generics, _)) = &item_impl.generics.split_for_impl() {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^   ------------------------------------ this expression has type `&(ImplGenerics<'_>, TypeGenerics<'_>, Option<&WhereClause>)`\n   |                              |\n   |                              expected `(ImplGenerics<'_>, ..., ...)`, found `Option<_>`\n   |\n   = note: expected tuple `(ImplGenerics<'_>, TypeGenerics<'_>, Option<&WhereClause>)`\n               found enum `Option<_>`\n\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:40:98\n   |\n40 | ...                   if let syn::Type::Path(TypePath { path, .. }) = &mut *impl_type.ty {\n   |                                                                            ^^^^^^^^^^^^^ can't be dereferenced\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_GAT_Lifetime_Constraints_283_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:12:20\n   |\n12 |             if let Item::Impl(item_impl) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypePath` in this scope\n  --> src\\main.rs:19:64\n   |\n19 | ...                   if let syn::Type::Path(TypePath { path, .. }) = &impl_type.ty {\n   |                                              ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypePath;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `PathArguments`\n  --> src\\main.rs:21:56\n   |\n21 | ...                   if let PathArguments::AngleBracketed(ref mut data) = last_segment.arguments {\n   |                              ^^^^^^^^^^^^^ use of undeclared type `PathArguments`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::PathArguments;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericArgument`\n  --> src\\main.rs:23:64\n   |\n23 | ...                   if let GenericArgument::Lifetime(lifetime) = arg {\n   |                              ^^^^^^^^^^^^^^^ use of undeclared type `GenericArgument`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericArgument;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Lifetime`\n  --> src\\main.rs:25:73\n   |\n25 | ...                   *lifetime = Lifetime::new(\"'b\", Span::call_site());\n   |                                   ^^^^^^^^ use of undeclared type `Lifetime`\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::Lifetime;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:25:93\n   |\n25 | ...                   *lifetime = Lifetime::new(\"'b\", Span::call_site());\n   |                                                       ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 6 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_GAT_Lifetime_Constraints_283_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:6:6\n  |\n6 | impl Mutator for Modify_GAT_Lifetime_Constraints_283 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_GAT_Lifetime_Constraints_283_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `path.segments` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:22:73\n   |\n22 | ...                   if let Some(last_segment) = path.segments.last_mut() {\n   |                                                   ^^^^^^^^^^^^^ `path` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_GAT_Lifetime_Constraints_283_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0594]: cannot assign to `*path`, which is behind a `&` reference\n  --> src\\main.rs:32:45\n   |\n32 | ...                   *path = syn::Path { segments: path_segments, ..path.clone() };\n   |                       ^^^^^ `path` is a `&` reference, so the data it refers to cannot be written\n\nFor more information about this error, try `rustc --explain E0594`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_GAT_Lifetime_Constraints_283_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:33:45\n   |\n33 | ...                   *impl_type.ty = syn::Type::Path(TypePath { path: new_path, ..*impl_type.ty.clone() });\n   |                       ^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:33:106\n   |\n33 | ...                   *impl_type.ty = syn::Type::Path(TypePath { path: new_path, ..*impl_type.ty.clone() });\n   |                                                                                    ^^^^^^^^^^^^^^^^^^^^^ can't be dereferenced\n\nFor more information about this error, try `rustc --explain E0614`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_GAT_Lifetime_Constraints_283_compling_err_7.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0063]: missing field `qself` in initializer of `TypePath`\n  --> src\\main.rs:33:71\n   |\n33 | ...                   impl_type.ty = Type::Path(TypePath { path: new_path });\n   |                                                 ^^^^^^^^ missing `qself`\n\nFor more information about this error, try `rustc --explain E0063`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_gat_lifetime_constraints_283.rs"
    },
    {
        "mutator_name": "Modify_Generator_To_Undefined_Var_273",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Generator_To_Undefined_Var_273_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:36:41\n   |\n36 | ...                   if let Some((_, expr)) = &mut local.init {\n   |                                   ^^^^^^^^^    --------------- this expression has type `&mut Option<LocalInit>`\n   |                                   |\n   |                                   expected `LocalInit`, found `(_, _)`\n   |\n   = note: expected struct `LocalInit`\n               found tuple `(_, _)`\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:53:27\n   |\n53 |         if let Stmt::Expr(Expr::Yield(_)) = stmt {\n   |                           ^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n53 |         if let Stmt::Expr(Expr::Yield(_), _) = stmt {\n   |                                         +++\n\nSome errors have detailed explanations: E0023, E0308.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Generator_To_Undefined_Var_273_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:17:54\n   |\n17 | ...                   init.expr = Box::new(parse_quote!(undefined_var));\n   |                                            ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:12:20\n   |\n12 |             if let Item::Fn(item_fn) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:15:32\n   |\n15 |                         if let Stmt::Local(local) = stmt {\n   |                                ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0412]: cannot find type `ItemFn` in this scope\n  --> src\\main.rs:31:36\n   |\n31 | fn is_generator_function(item_fn: &ItemFn) -> bool {\n   |                                    ^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::ItemFn;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:33:16\n   |\n33 |         if let Stmt::Expr(Expr::Yield(_, _)) = stmt {\n   |                ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:33:27\n   |\n33 |         if let Stmt::Expr(Expr::Yield(_, _)) = stmt {\n   |                           ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 6 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Generator_To_Undefined_Var_273_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Modify_Generator_To_Undefined_Var_273 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Generator_To_Undefined_Var_273_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:17:41\n   |\n17 | ...                   if let Some((_, init)) = &mut local.init {\n   |                                   ^^^^^^^^^    --------------- this expression has type `&mut Option<LocalInit>`\n   |                                   |\n   |                                   expected `LocalInit`, found `(_, _)`\n   |\n   = note: expected struct `LocalInit`\n               found tuple `(_, _)`\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:34:27\n   |\n34 |         if let Stmt::Expr(Expr::Yield { .. }) = stmt {\n   |                           ^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n34 |         if let Stmt::Expr(Expr::Yield { .. }, _) = stmt {\n   |                                             +++\n\nSome errors have detailed explanations: E0023, E0308.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_generator_to_undefined_var_273.rs"
    },
    {
        "mutator_name": "Modify_Generator_Trait_And_Box_Usage_279",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Generator_Trait_And_Box_Usage_279_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `syn::ImplItem` in the current scope\n  --> src\\main.rs:56:46\n   |\n56 | ...                   if let ImplItem::Method(method) = item {\n   |                                        ^^^^^^ variant or associated item not found in `ImplItem`\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:58:55\n   |\n58 | ...                   if let Stmt::Expr(Expr::Closure(closure)) = &mut method.block.stmts[0] {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n58 |                                     if let Stmt::Expr(Expr::Closure(closure), _) = &mut method.block.stmts[0] {\n   |                                                                             +++\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:60:52\n   |\n60 | ...                   if let Expr::Path(expr_path) = &mut expr_match.expr {\n   |                              ^^^^^^^^^^^^^^^^^^^^^   -------------------- this expression has type `&mut std::boxed::Box<syn::Expr>`\n   |                              |\n   |                              expected `Box<Expr>`, found `Expr`\n   |\n   = note: expected struct `std::boxed::Box<syn::Expr>`\n                found enum `syn::Expr`\nhelp: consider dereferencing to access the inner value using the Deref trait\n   |\n60 -                                             if let Expr::Path(expr_path) = &mut expr_match.expr {\n60 +                                             if let Expr::Path(expr_path) = &*expr_match.expr {\n   |\n\nSome errors have detailed explanations: E0023, E0308, E0599.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Generator_Trait_And_Box_Usage_279_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:24:37\n   |\n24 | ...                   parse_quote! { <Box<G::Gen>> }\n   |                       ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Struct(item_struct) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:14:32\n   |\n14 |                         if let Type::Path(TypePath { path, .. }) = &f.ty {\n   |                                ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypePath` in this scope\n  --> src\\main.rs:14:43\n   |\n14 |                         if let Type::Path(TypePath { path, .. }) = &f.ty {\n   |                                           ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypePath;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:20:32\n   |\n20 |                         if let Type::Path(type_path) = &mut field.ty {\n   |                                ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:22:49\n   |\n22 | ...                   segment.ident = Ident::new(\"Option\", segment.ident.span());\n   |                                       ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `PathArguments`\n  --> src\\main.rs:23:53\n   |\n23 | ...                   segment.arguments = PathArguments::AngleBracketed(\n   |                                           ^^^^^^^^^^^^^ use of undeclared type `PathArguments`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::PathArguments;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:32:20\n   |\n32 |             if let Item::Impl(item_impl) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:38:44\n   |\n38 | ...                   if let Stmt::Expr(Expr::Closure(closure), _) = &mut method.block.stmts[0] {\n   |                              ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:38:55\n   |\n38 | ...                   if let Stmt::Expr(Expr::Closure(closure), _) = &mut method.block.stmts[0] {\n   |                                         ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:39:48\n   |\n39 | ...                   if let Expr::Match(expr_match) = &mut *closure.body {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:40:52\n   |\n40 | ...                   if let Expr::Path(expr_path) = &mut *expr_match.expr {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:42:69\n   |\n42 | ...                   segment.ident = Ident::new(\"Some\", segment.ident.span());\n   |                                       ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 13 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Generator_Trait_And_Box_Usage_279_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:6:6\n  |\n6 | impl Mutator for Modify_Generator_Trait_And_Box_Usage_279 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Generator_Trait_And_Box_Usage_279_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:40:55\n   |\n40 | ...                   if let Stmt::Expr(Expr::Closure(closure)) = &mut method.block.stmts[0] {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n40 |                                     if let Stmt::Expr(Expr::Closure(closure), _) = &mut method.block.stmts[0] {\n   |                                                                             +++\n\nFor more information about this error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_generator_trait_and_box_usage_279.rs"
    },
    {
        "mutator_name": "Modify_Generator_Usage_307",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Generator_Usage_307_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `split_last_mut` found for struct `syn::punctuated::Punctuated` in the current scope\n  --> src\\main.rs:34:74\n   |\n34 |                         if let Some((_, bounds)) = &mut type_item.bounds.split_last_mut() {\n   |                                                                          ^^^^^^^^^^^^^^\n   |\nhelp: there is a method `last_mut` with a similar name\n   |\n34 -                         if let Some((_, bounds)) = &mut type_item.bounds.split_last_mut() {\n34 +                         if let Some((_, bounds)) = &mut type_item.bounds.last_mut() {\n   |\n\nerror[E0599]: no variant or associated item named `Binding` found for enum `GenericArgument` in the current scope\n  --> src\\main.rs:42:81\n   |\n42 | ...                   if let GenericArgument::Binding(binding) = arg {\n   |                                               ^^^^^^^ variant or associated item not found in `GenericArgument`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:69:51\n   |\n69 | ...                   if let syn::ImplItem::Method(method) = item {\n   |                                             ^^^^^^ variant or associated item not found in `ImplItem`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_generator_usage_307.rs"
    },
    {
        "mutator_name": "Modify_Generator_Yield_Points_275",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Generator_Yield_Points_275_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:32:24\n   |\n32 |                 if let Some(block) = &mut item_fn.block {\n   |                        ^^^^^^^^^^^   ------------------ this expression has type `&mut std::boxed::Box<syn::Block>`\n   |                        |\n   |                        expected `Box<Block>`, found `Option<_>`\n   |\n   = note: expected struct `std::boxed::Box<syn::Block>`\n                found enum `Option<_>`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Generator_Yield_Points_275_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:32:24\n   |\n32 |                 if let Some(block) = item_fn.block.as_mut() {\n   |                        ^^^^^^^^^^^   ---------------------- this expression has type `&mut syn::Block`\n   |                        |\n   |                        expected `Block`, found `Option<_>`\n   |\n   = note: expected struct `syn::Block`\n                found enum `Option<_>`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Generator_Yield_Points_275_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:32:24\n   |\n32 |                 if let Some(ref mut block) = item_fn.block {\n   |                        ^^^^^^^^^^^^^^^^^^^   ------------- this expression has type `std::boxed::Box<syn::Block>`\n   |                        |\n   |                        expected `Box<Block>`, found `Option<_>`\n   |\n   = note: expected struct `std::boxed::Box<syn::Block>`\n                found enum `Option<_>`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_generator_yield_points_275.rs"
    },
    {
        "mutator_name": "Modify_Generic_Arguments_In_Struct_Instantiation_355",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Generic_Arguments_In_Struct_Instantiation_355_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.25s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\punctuated.rs:195:9:\nPunctuated::push_punct: cannot push punctuation if Punctuated is empty or already has trailing punctuation\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Generic_Arguments_In_Struct_Instantiation_355_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.77s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\punctuated.rs:179:9:\nPunctuated::push_value: cannot push value if Punctuated is missing trailing punctuation\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Generic_Arguments_In_Struct_Instantiation_355_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.71s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\punctuated.rs:195:9:\nPunctuated::push_punct: cannot push punctuation if Punctuated is empty or already has trailing punctuation\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Generic_Arguments_In_Struct_Instantiation_355_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.72s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\punctuated.rs:179:9:\nPunctuated::push_value: cannot push value if Punctuated is missing trailing punctuation\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Generic_Arguments_In_Struct_Instantiation_355_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.69s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\punctuated.rs:195:9:\nPunctuated::push_punct: cannot push punctuation if Punctuated is empty or already has trailing punctuation\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Generic_Arguments_In_Struct_Instantiation_355_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:21:61\n   |\n21 | ...                   let new_type: GenericArgument = parse_quote!(i32);\n   |                                                       ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0412]: cannot find type `HashSet` in this scope\n  --> src\\main.rs:12:24\n   |\n12 |             types: &'a HashSet<String>,\n   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use std::collections::HashSet;\n   |\n\nerror[E0405]: cannot find trait `VisitMut` in this scope\n  --> src\\main.rs:15:18\n   |\n15 |         impl<'a> VisitMut for StructInstantiationVisitor<'a> {\n   |                  ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this trait\n   |\n1  + use syn::visit_mut::VisitMut;\n   |\n\nerror[E0412]: cannot find type `ExprPath` in this scope\n  --> src\\main.rs:16:55\n   |\n16 |             fn visit_expr_path_mut(&mut self, i: &mut ExprPath) {\n   |                                                       ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::ExprPath;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `PathArguments`\n  --> src\\main.rs:18:28\n   |\n18 |                     if let PathArguments::AngleBracketed(ref mut args) = last_segment.arguments {\n   |                            ^^^^^^^^^^^^^ use of undeclared type `PathArguments`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::PathArguments;\n   |\n\nerror[E0412]: cannot find type `GenericArgument` in this scope\n  --> src\\main.rs:19:50\n   |\n19 |                         let existing_types: Vec<&GenericArgument> = args.args.iter().collect();\n   |                                                  ^^^^^^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericArgument;\n   |\n\nerror[E0412]: cannot find type `GenericArgument` in this scope\n  --> src\\main.rs:21:43\n   |\n21 | ...                   let new_type: GenericArgument = parse_quote!(i32);\n   |                                     ^^^^^^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericArgument;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Comma`\n  --> src\\main.rs:23:54\n   |\n23 | ...                   args.args.push_punct(Comma::default());\n   |                                            ^^^^^ use of undeclared type `Comma`\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::token::Comma;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `visit_mut`\n  --> src\\main.rs:29:17\n   |\n29 |                 visit_mut::visit_expr_path_mut(self, i);\n   |                 ^^^^^^^^^ use of unresolved module or unlinked crate `visit_mut`\n   |\n   = help: if you wanted to use a crate named `visit_mut`, use `cargo add visit_mut` to add it to your `Cargo.toml`\nhelp: consider importing this module\n   |\n1  + use syn::visit_mut;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n  --> src\\main.rs:33:25\n   |\n33 |         let mut types = HashSet::new();\n   |                         ^^^^^^^ use of undeclared type `HashSet`\n   |\nhelp: consider importing this struct\n   |\n1  + use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:35:20\n   |\n35 |             if let Item::Struct(ItemStruct { ident, .. }) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `ItemStruct` in this scope\n  --> src\\main.rs:35:33\n   |\n35 |             if let Item::Struct(ItemStruct { ident, .. }) = item {\n   |                                 ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::ItemStruct;\n   |\n\nSome errors have detailed explanations: E0405, E0412, E0422, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 12 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Generic_Arguments_In_Struct_Instantiation_355_compling_err_7.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:9:6\n  |\n9 | impl Mutator for Modify_Generic_Arguments_In_Struct_Instantiation_355 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_generic_arguments_in_struct_instantiation_355.rs"
    },
    {
        "mutator_name": "Modify_Generic_Associated_Types_Remove_Const_Expressions_292",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Generic_Associated_Types_Remove_Const_Expressions_292_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `retain` found for struct `syn::punctuated::Punctuated` in the current scope\n  --> src\\main.rs:35:53\n   |\n35 | ...                   where_clause.predicates.retain(|predicate| {\n   |                       ------------------------^^^^^^ method not found in `Punctuated<WherePredicate, Comma>`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_generic_associated_types_remove_const_expressions_292.rs"
    },
    {
        "mutator_name": "Modify_Generic_Constants_401",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Generic_Constants_401_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:29\n   |\n31 |             if let Item::Fn(ref mut item_fn) = item {\n   |                             ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Fn(ref mut item_fn) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n31 -             if let Item::Fn(ref mut item_fn) = item {\n31 +             if let Item::Fn(item_fn) = item {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:40:89\n   |\n40 | ...                   if let GenericArgument::Const(Expr::Lit(ref mut expr_lit)) = arg {\n   |                                                               ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:40:56\n   |\n40 | ...                   if let GenericArgument::Const(Expr::Lit(ref mut expr_lit)) = arg {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n40 -                                                 if let GenericArgument::Const(Expr::Lit(ref mut expr_lit)) = arg {\n40 +                                                 if let GenericArgument::Const(Expr::Lit(expr_lit)) = arg {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Generic_Constants_401_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Fn(item_fn) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `PathArguments`\n  --> src\\main.rs:18:48\n   |\n18 | ...                   if let PathArguments::AngleBracketed(ref mut args) = generic_argument.arguments {\n   |                              ^^^^^^^^^^^^^ use of undeclared type `PathArguments`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::PathArguments;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericArgument`\n  --> src\\main.rs:20:56\n   |\n20 | ...                   if let GenericArgument::Const(Expr::Lit(expr_lit)) = arg {\n   |                              ^^^^^^^^^^^^^^^ use of undeclared type `GenericArgument`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericArgument;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:20:79\n   |\n20 | ...                   if let GenericArgument::Const(Expr::Lit(expr_lit)) = arg {\n   |                                                     ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nFor more information about this error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Generic_Constants_401_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Modify_Generic_Constants_401 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_generic_constants_401.rs"
    },
    {
        "mutator_name": "Modify_Inline_Asm_318",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Inline_Asm_318_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Semi` found for enum `Stmt` in the current scope\n  --> src\\main.rs:33:34\n   |\n33 |                     if let Stmt::Semi(Expr::Macro(ref mut mac), _) = stmt {\n   |                                  ^^^^ variant or associated item not found in `Stmt`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Inline_Asm_318_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:33:39\n   |\n33 |                     if let Stmt::Expr(Expr::Macro(ref mut mac)) = stmt {\n   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n33 |                     if let Stmt::Expr(Expr::Macro(ref mut mac), _) = stmt {\n   |                                                               +++\n\nFor more information about this error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Inline_Asm_318_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:29\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                             ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n31 -             if let Item::Fn(ref mut func) = item {\n31 +             if let Item::Fn(func) = item {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:33:51\n   |\n33 |                     if let Stmt::Expr(Expr::Macro(ref mut mac), _) = stmt {\n   |                                                   ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:33:28\n   |\n33 |                     if let Stmt::Expr(Expr::Macro(ref mut mac), _) = stmt {\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n33 -                     if let Stmt::Expr(Expr::Macro(ref mut mac), _) = stmt {\n33 +                     if let Stmt::Expr(Expr::Macro(mac), _) = stmt {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:36:60\n   |\n36 | ...                   if let Some(TokenTree::Literal(ref mut lit)) = tokens.get_mut(0) {\n   |                                                      ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:36:41\n   |\n36 | ...                   if let Some(TokenTree::Literal(ref mut lit)) = tokens.get_mut(0) {\n   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n36 -                             if let Some(TokenTree::Literal(ref mut lit)) = tokens.get_mut(0) {\n36 +                             if let Some(TokenTree::Literal(lit)) = tokens.get_mut(0) {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Inline_Asm_318_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Fn(func) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:13:28\n   |\n13 |                     if let Stmt::Expr(Expr::Macro(mac), _) = stmt {\n   |                            ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:13:39\n   |\n13 |                     if let Stmt::Expr(Expr::Macro(mac), _) = stmt {\n   |                                       ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TokenTree`\n  --> src\\main.rs:16:41\n   |\n16 | ...                   if let Some(TokenTree::Literal(lit)) = tokens.get_mut(0) {\n   |                                   ^^^^^^^^^ use of undeclared type `TokenTree`\n   |\nhelp: consider importing this enum\n   |\n1  + use proc_macro2::TokenTree;\n   |\n\nFor more information about this error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Inline_Asm_318_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:4:6\n  |\n4 | impl Mutator for Modify_Inline_Asm_318 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nerror[E0412]: cannot find type `Modify_Inline_Asm_318` in this scope\n --> src\\main.rs:4:18\n  |\n4 | impl Mutator for Modify_Inline_Asm_318 {\n  |                  ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Modify_Inline_Asm_318` in this scope\n  --> src\\main.rs:53:13\n   |\n53 |             Modify_Inline_Asm_318.mutate(&mut file_ast);\n   |             ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nSome errors have detailed explanations: E0405, E0412, E0425.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Inline_Asm_318_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:15:39\n   |\n15 |                     if let Stmt::Expr(Expr::Macro(mac)) = stmt {\n   |                                       ^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n15 |                     if let Stmt::Expr(Expr::Macro(mac), _) = stmt {\n   |                                                       +++\n\nFor more information about this error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_inline_asm_318.rs"
    },
    {
        "mutator_name": "Modify_Inline_Asm_Directives_313",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Inline_Asm_Directives_313_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:32:32\n   |\n32 |             if let Item::Macro(ref mut mac) = item {\n   |                                ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:32:20\n   |\n32 |             if let Item::Macro(ref mut mac) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n32 -             if let Item::Macro(ref mut mac) = item {\n32 +             if let Item::Macro(mac) = item {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Inline_Asm_Directives_313_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `quote` in this scope\n  --> src\\main.rs:26:46\n   |\n26 | ...                   mac.mac.tokens = quote! { #mutated_code };\n   |                                        ^^^^^\n   |\n   = note: `quote` is in scope, but it is a crate, not a macro\nhelp: consider importing this macro\n   |\n1  + use quote::quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:12:20\n   |\n12 |             if let Item::Macro(mac) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TokenTree`\n  --> src\\main.rs:15:32\n   |\n15 |                         if let TokenTree::Literal(lit) = tt {\n   |                                ^^^^^^^^^ use of undeclared type `TokenTree`\n   |\nhelp: consider importing this enum\n   |\n1  + use proc_macro2::TokenTree;\n   |\n\nerror[E0425]: cannot find function `thread_rng` in this scope\n  --> src\\main.rs:17:43\n   |\n17 | ...                   let mut rng = thread_rng();\n   |                                     ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  + use rand::thread_rng;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Regex`\n  --> src\\main.rs:18:48\n   |\n18 | ...                   let mutated_code = Regex::new(r\"\\b(MOV|ADD|SUB|MUL|DIV)\\b\")\n   |                                          ^^^^^ use of undeclared type `Regex`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use regex::Regex;\n   |\n1  + use regex::bytes::Regex;\n   |\n\nerror[E0599]: no method named `shuffle` found for struct `Vec<char>` in the current scope\n  --> src\\main.rs:23:43\n   |\n23 | ...                   chars.shuffle(&mut rng);\n   |                             ^^^^^^^ method not found in `Vec<char>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: trait `SliceRandom` which provides `shuffle` is implemented but not in scope; perhaps you want to import it\n   |\n1  + use rand::prelude::SliceRandom;\n   |\n\nSome errors have detailed explanations: E0425, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 6 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Inline_Asm_Directives_313_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n  --> src\\main.rs:10:6\n   |\n10 | impl Mutator for Modify_Inline_Asm_Directives_313 {\n   |      ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this trait\n   |\n1  + use crate::mutator::Mutator;\n   |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_inline_asm_directives_313.rs"
    },
    {
        "mutator_name": "Modify_Inline_Assembly_Operand_314",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Inline_Assembly_Operand_314_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Semi` found for enum `Stmt` in the current scope\n  --> src\\main.rs:33:34\n   |\n33 |                     if let Stmt::Semi(Expr::Macro(ref mut mac), _) = stmt {\n   |                                  ^^^^ variant or associated item not found in `Stmt`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Inline_Assembly_Operand_314_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `quote` in this scope\n  --> src\\main.rs:22:59\n   |\n22 | ...                   new_tokens.extend(quote! { #new_lit });\n   |                                         ^^^^^\n   |\n   = note: `quote` is in scope, but it is a crate, not a macro\nhelp: consider importing this macro\n   |\n1  + use quote::quote;\n   |\n\nerror: cannot find macro `quote` in this scope\n  --> src\\main.rs:24:59\n   |\n24 | ...                   new_tokens.extend(quote! { #lit });\n   |                                         ^^^^^\n   |\n   = note: `quote` is in scope, but it is a crate, not a macro\nhelp: consider importing this macro\n   |\n1  + use quote::quote;\n   |\n\nerror: cannot find macro `quote` in this scope\n  --> src\\main.rs:27:55\n   |\n27 | ...                   new_tokens.extend(quote! { #token });\n   |                                         ^^^^^\n   |\n   = note: `quote` is in scope, but it is a crate, not a macro\nhelp: consider importing this macro\n   |\n1  + use quote::quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Fn(ref mut func) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:13:28\n   |\n13 |                     if let Stmt::Expr(Expr::Macro(ref mut mac)) = stmt {\n   |                            ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:13:39\n   |\n13 |                     if let Stmt::Expr(Expr::Macro(ref mut mac)) = stmt {\n   |                                       ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TokenStream`\n  --> src\\main.rs:16:50\n   |\n16 | ...                   let mut new_tokens = TokenStream::new();\n   |                                            ^^^^^^^^^^^ use of undeclared type `TokenStream`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::TokenStream;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TokenTree`\n  --> src\\main.rs:18:40\n   |\n18 | ...                   if let TokenTree::Literal(ref lit) = token {\n   |                              ^^^^^^^^^ use of undeclared type `TokenTree`\n   |\nhelp: consider importing this enum\n   |\n1  + use proc_macro2::TokenTree;\n   |\n\nFor more information about this error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 8 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Inline_Assembly_Operand_314_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:7:6\n  |\n7 | impl Mutator for Modify_Inline_Assembly_Operand_314 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Inline_Assembly_Operand_314_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:16:39\n   |\n16 |                     if let Stmt::Expr(Expr::Macro(ref mut mac)) = stmt {\n   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n16 |                     if let Stmt::Expr(Expr::Macro(ref mut mac), _) = stmt {\n   |                                                               +++\n\nFor more information about this error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Inline_Assembly_Operand_314_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:14:29\n   |\n14 |             if let Item::Fn(ref mut func) = item {\n   |                             ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:14:20\n   |\n14 |             if let Item::Fn(ref mut func) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n14 -             if let Item::Fn(ref mut func) = item {\n14 +             if let Item::Fn(func) = item {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:16:51\n   |\n16 |                     if let Stmt::Expr(Expr::Macro(ref mut mac), _) = stmt {\n   |                                                   ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:16:28\n   |\n16 |                     if let Stmt::Expr(Expr::Macro(ref mut mac), _) = stmt {\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n16 -                     if let Stmt::Expr(Expr::Macro(ref mut mac), _) = stmt {\n16 +                     if let Stmt::Expr(Expr::Macro(mac), _) = stmt {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_inline_assembly_operand_314.rs"
    },
    {
        "mutator_name": "Modify_Lifetime_Annotations_262",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Lifetime_Annotations_262_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0502]: cannot borrow `generics.params` as mutable because it is also borrowed as immutable\n  --> src\\main.rs:38:38\n   |\n34 |                     if let Some(lifetime) = generics.lifetimes().next() {\n   |                                             -------- immutable borrow occurs here\n...\n38 |                         for param in &mut generics.params {\n   |                                      ^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n39 |                             if let GenericParam::Lifetime(LifetimeParam { lifetime, .. }) = param {\n40 |                                 if lifetime == original_lifetime {\n   |                                                ----------------- immutable borrow later used here\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_lifetime_annotations_262.rs"
    },
    {
        "mutator_name": "Modify_Lifetime_Parameters_In_Trait_Bound_306",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Lifetime_Parameters_In_Trait_Bound_306_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:51:86\n   |\n51 | ...                   if let GenericArgument::Lifetime(ref mut lt) = arg {\n   |                                                        ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:51:60\n   |\n51 | ...                   if let GenericArgument::Lifetime(ref mut lt) = arg {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n51 -                                                     if let GenericArgument::Lifetime(ref mut lt) = arg {\n51 +                                                     if let GenericArgument::Lifetime(lt) = arg {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:74:82\n   |\n74 | ...                   if let GenericArgument::Lifetime(ref mut lt) = arg {\n   |                                                        ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:74:56\n   |\n74 | ...                   if let GenericArgument::Lifetime(ref mut lt) = arg {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n74 -                                                 if let GenericArgument::Lifetime(ref mut lt) = arg {\n74 +                                                 if let GenericArgument::Lifetime(lt) = arg {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_lifetime_parameters_in_trait_bound_306.rs"
    },
    {
        "mutator_name": "Modify_Macro_Invocation_And_Constant_Definition_304",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Macro_Invocation_And_Constant_Definition_304_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:35:43\n   |\n35 |                         if let Stmt::Expr(Expr::Macro(expr_macro)) = stmt {\n   |                                           ^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n35 |                         if let Stmt::Expr(Expr::Macro(expr_macro), _) = stmt {\n   |                                                                  +++\n\nerror[E0609]: no field `tts` on type `syn::Macro`\n  --> src\\main.rs:40:44\n   |\n40 | ...                   expr_macro.mac.tts = new_macro_content;\n   |                                      ^^^ unknown field\n   |\n   = note: available fields are: `path`, `bang_token`, `delimiter`, `tokens`\n\nSome errors have detailed explanations: E0023, E0609.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Macro_Invocation_And_Constant_Definition_304_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0594]: cannot assign to `expr_macro.mac.tokens`, which is behind a `&` reference\n  --> src\\main.rs:39:29\n   |\n39 | ...                   expr_macro.mac.tokens = new_macro_content;\n   |                       ^^^^^^^^^^^^^^^^^^^^^ `expr_macro` is a `&` reference, so the data it refers to cannot be written\n\nFor more information about this error, try `rustc --explain E0594`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Macro_Invocation_And_Constant_Definition_304_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:34:43\n   |\n34 |                         if let Stmt::Expr(Expr::Macro(expr_macro)) = stmt {\n   |                                           ^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n34 |                         if let Stmt::Expr(Expr::Macro(expr_macro), _) = stmt {\n   |                                                                  +++\n\nFor more information about this error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Macro_Invocation_And_Constant_Definition_304_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `expr_block.block.stmts` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:33:33\n   |\n33 |                     for stmt in &mut expr_block.block.stmts {\n   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ `expr_block` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Macro_Invocation_And_Constant_Definition_304_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:34:43\n   |\n34 |                         if let Stmt::Expr(Expr::Macro(ref mut expr_macro)) = stmt {\n   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n34 |                         if let Stmt::Expr(Expr::Macro(ref mut expr_macro), _) = stmt {\n   |                                                                          +++\n\nFor more information about this error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Macro_Invocation_And_Constant_Definition_304_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:32:36\n   |\n32 |                 if let Expr::Block(ref mut expr_block) = &mut *item_const.expr {\n   |                                    ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:32:24\n   |\n32 |                 if let Expr::Block(ref mut expr_block) = &mut *item_const.expr {\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n32 -                 if let Expr::Block(ref mut expr_block) = &mut *item_const.expr {\n32 +                 if let Expr::Block(expr_block) = &mut *item_const.expr {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:34:55\n   |\n34 |                         if let Stmt::Expr(Expr::Macro(ref mut expr_macro), _) = stmt {\n   |                                                       ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:34:32\n   |\n34 |                         if let Stmt::Expr(Expr::Macro(ref mut expr_macro), _) = stmt {\n   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n34 -                         if let Stmt::Expr(Expr::Macro(ref mut expr_macro), _) = stmt {\n34 +                         if let Stmt::Expr(Expr::Macro(expr_macro), _) = stmt {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_macro_invocation_and_constant_definition_304.rs"
    },
    {
        "mutator_name": "Modify_Macro_Pattern_To_Trigger_Delim_Mismatch_352",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Macro_Pattern_To_Trigger_Delim_Mismatch_352_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:33:29\n   |\n33 |                 if let Some((_, ref mut tokens)) = &mut macro_item.mac.tokens.clone().into_iter().next() {\n   |                             ^^^^^^^^^^^^^^^^^^^    ----------------------------------------------------- this expression has type `&mut Option<proc_macro2::TokenTree>`\n   |                             |\n   |                             expected `TokenTree`, found `(_, _)`\n   |\n   = note: expected enum `proc_macro2::TokenTree`\n             found tuple `(_, _)`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Macro_Pattern_To_Trigger_Delim_Mismatch_352_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:32:32\n   |\n32 |             if let Item::Macro(ref mut macro_item) = item {\n   |                                ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:32:20\n   |\n32 |             if let Item::Macro(ref mut macro_item) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n32 -             if let Item::Macro(ref mut macro_item) = item {\n32 +             if let Item::Macro(macro_item) = item {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_macro_pattern_to_trigger_delim_mismatch_352.rs"
    },
    {
        "mutator_name": "Modify_Macro_Rules_Remove_Unsupported_Syntax_358",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [],
        "label": "Negative",
        "file": ".\\mutators\\modify_macro_rules_remove_unsupported_syntax_358.rs"
    },
    {
        "mutator_name": "Modify_Packed_Union_Alignment_321",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Packed_Union_Alignment_321_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0615]: attempted to take value of method `path` on type `&&mut Attribute`\n  --> src\\main.rs:32:82\n   |\n32 |                 if let Some(attr) = item_union.attrs.iter_mut().find(|attr| attr.path.is_ident(\"repr\")) {\n   |                                                                                  ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n32 |                 if let Some(attr) = item_union.attrs.iter_mut().find(|attr| attr.path().is_ident(\"repr\")) {\n   |                                                                                      ++\n\nerror[E0599]: no method named `parse_meta` found for mutable reference `&mut Attribute` in the current scope\n   --> src\\main.rs:33:44\n    |\n33  |                     if let Ok(meta) = attr.parse_meta() {\n    |                                            ^^^^^^^^^^\n    |\nhelp: there is a method `parse_nested_meta` with a similar name, but with different arguments\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\attr.rs:391:5\n    |\n391 | /     pub fn parse_nested_meta(\n392 | |         &self,\n393 | |         logic: impl FnMut(ParseNestedMeta) -> Result<()>,\n394 | |     ) -> Result<()> {\n    | |___________________^\n\nerror[E0609]: no field `nested` on type `MetaList`\n  --> src\\main.rs:35:105\n   |\n35 | ...                   if let Some(NestedMeta::Meta(Meta::NameValue(meta_name_value))) = meta_list.nested.first() {\n   |                                                                                                   ^^^^^^ unknown field\n   |\n   = note: available fields are: `path`, `delimiter`, `tokens`\n\nerror[E0609]: no field `lit` on type `MetaNameValue`\n  --> src\\main.rs:37:81\n   |\n37 | ...                   if let Lit::Int(lit_int) = &meta_name_value.lit {\n   |                                                                   ^^^ unknown field\n   |\n   = note: available fields are: `path`, `eq_token`, `value`\n\nerror[E0609]: no field `tokens` on type `&mut Attribute`\n  --> src\\main.rs:41:50\n   |\n41 | ...                   attr.tokens = quote!((packed(#lit_int_new)));\n   |                            ^^^^^^ unknown field\n   |\n   = note: available fields are: `pound_token`, `style`, `bracket_token`, `meta`\n\nerror[E0433]: failed to resolve: use of undeclared type `NestedMeta`\n  --> src\\main.rs:35:41\n   |\n35 | ...                   if let Some(NestedMeta::Meta(Meta::NameValue(meta_name_value))) = meta_list.nested.first() {\n   |                                   ^^^^^^^^^^ use of undeclared type `NestedMeta`\n\nSome errors have detailed explanations: E0433, E0599, E0609, E0615.\nFor more information about an error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 6 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Packed_Union_Alignment_321_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n   --> src\\main.rs:34:111\n    |\n34  | ...ue)) = meta_list.parse_nested_meta(|meta| Ok(meta)).ok().and_then(|_| meta_list.nested.first()) {\n    |                                              -- ^^^^ expected `()`, found `ParseNestedMeta<'_>`\n    |                                              |\n    |                                              arguments to this enum variant are incorrect\n    |\nhelp: the type constructed contains `ParseNestedMeta<'_>` due to the type of the argument passed\n   --> src\\main.rs:34:108\n    |\n34  | ...ue)) = meta_list.parse_nested_meta(|meta| Ok(meta)).ok().and_then(|_| meta_list.nested.first()) {\n    |                                              ^^^----^\n    |                                                 |\n    |                                                 this argument influences the type of `Ok`\nnote: tuple variant defined here\n   --> C:\\Users\\love\\.rustup\\toolchains\\nightly-2025-05-10-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\result.rs:552:5\n    |\n552 |     Ok(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    |     ^^\n\nerror[E0609]: no field `nested` on type `&MetaList`\n  --> src\\main.rs:34:146\n   |\n34 | ...nested_meta(|meta| Ok(meta)).ok().and_then(|_| meta_list.nested.first()) {\n   |                                                             ^^^^^^ unknown field\n   |\n   = note: available fields are: `path`, `delimiter`, `tokens`\n\nSome errors have detailed explanations: E0308, E0609.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Packed_Union_Alignment_321_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `parse_meta` found for mutable reference `&mut Attribute` in the current scope\n   --> src\\main.rs:33:57\n    |\n33  |                     if let Meta::List(meta_list) = attr.parse_meta().ok() {\n    |                                                         ^^^^^^^^^^\n    |\nhelp: there is a method `parse_nested_meta` with a similar name, but with different arguments\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\attr.rs:391:5\n    |\n391 | /     pub fn parse_nested_meta(\n392 | |         &self,\n393 | |         logic: impl FnMut(ParseNestedMeta) -> Result<()>,\n394 | |     ) -> Result<()> {\n    | |___________________^\n\nerror[E0609]: no field `nested` on type `MetaList`\n  --> src\\main.rs:34:101\n   |\n34 |                         if let Some(NestedMeta::Meta(Meta::NameValue(meta_name_value))) = meta_list.nested.first() {\n   |                                                                                                     ^^^^^^ unknown field\n   |\n   = note: available fields are: `path`, `delimiter`, `tokens`\n\nerror[E0609]: no field `lit` on type `MetaNameValue`\n  --> src\\main.rs:36:82\n   |\n36 | ...                   if let syn::Lit::Int(lit_int) = &meta_name_value.lit {\n   |                                                                        ^^^ unknown field\n   |\n   = note: available fields are: `path`, `eq_token`, `value`\n\nerror[E0609]: no field `tokens` on type `&mut Attribute`\n  --> src\\main.rs:40:46\n   |\n40 | ...                   attr.tokens = quote!((packed(#lit_int_new)));\n   |                            ^^^^^^ unknown field\n   |\n   = note: available fields are: `pound_token`, `style`, `bracket_token`, `meta`\n\nerror[E0433]: failed to resolve: use of undeclared type `NestedMeta`\n  --> src\\main.rs:34:37\n   |\n34 |                         if let Some(NestedMeta::Meta(Meta::NameValue(meta_name_value))) = meta_list.nested.first() {\n   |                                     ^^^^^^^^^^ use of undeclared type `NestedMeta`\n\nSome errors have detailed explanations: E0433, E0599, E0609.\nFor more information about an error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 5 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Packed_Union_Alignment_321_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0609]: no field `tokens` on type `&mut Attribute`\n  --> src\\main.rs:40:42\n   |\n40 | ...                   attr.tokens = tokens.into();\n   |                            ^^^^^^ unknown field\n   |\n   = note: available fields are: `pound_token`, `style`, `bracket_token`, `meta`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Packed_Union_Alignment_321_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0500]: closure requires unique access to `attr.meta` but it is already borrowed\n  --> src\\main.rs:33:44\n   |\n33 |                     attr.parse_nested_meta(|meta| {\n   |                     ---- ----------------- ^^^^^^ closure construction occurs here\n   |                     |    |\n   |                     |    first borrow later used by call\n   |                     borrow occurs here\n...\n40 |                                     attr.meta = parse_quote!(#tokens);\n   |                                     --------- second borrow occurs due to use of `attr.meta` in closure\n\nFor more information about this error, try `rustc --explain E0500`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Packed_Union_Alignment_321_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `quote` in this scope\n  --> src\\main.rs:20:50\n   |\n20 | ...                   let tokens = quote!((packed(#lit_int_new)));\n   |                                    ^^^^^\n   |\n   = note: `quote` is in scope, but it is a crate, not a macro\nhelp: consider importing this macro\n   |\n1  + use quote::quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:21:53\n   |\n21 | ...                   new_meta = Some(parse_quote!(#tokens));\n   |                                       ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Union(item_union) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0412]: cannot find type `Lit` in this scope\n  --> src\\main.rs:16:96\n   |\n16 | ...                   if let Ok(Lit::Int(lit_int)) = meta.value().and_then(|v| v.parse::<Lit>()) {\n   |                                                                                          ^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Lit;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Lit`\n  --> src\\main.rs:16:39\n   |\n16 | ...                   if let Ok(Lit::Int(lit_int)) = meta.value().and_then(|v| v.parse::<Lit>()) {\n   |                                 ^^^ use of undeclared type `Lit`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Lit;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `LitInt`\n  --> src\\main.rs:19:55\n   |\n19 | ...                   let lit_int_new = LitInt::new(&new_n.to_string(), lit_int.span());\n   |                                         ^^^^^^ use of undeclared type `LitInt`\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::LitInt;\n   |\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 6 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Packed_Union_Alignment_321_compling_err_7.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:6:6\n  |\n6 | impl Mutator for Modify_Packed_Union_Alignment_321 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Packed_Union_Alignment_321_compling_err_8.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0615]: attempted to take value of method `path` on type `&&mut Attribute`\n  --> src\\main.rs:14:82\n   |\n14 |                 if let Some(attr) = item_union.attrs.iter_mut().find(|attr| attr.path.is_ident(\"repr\")) {\n   |                                                                                  ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n14 |                 if let Some(attr) = item_union.attrs.iter_mut().find(|attr| attr.path().is_ident(\"repr\")) {\n   |                                                                                      ++\n\nFor more information about this error, try `rustc --explain E0615`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_packed_union_alignment_321.rs"
    },
    {
        "mutator_name": "Modify_Panic_Behavior_276",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Panic_Behavior_276_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0615]: attempted to take value of method `path` on type `&Attribute`\n  --> src\\main.rs:32:57\n   |\n32 |                 if item_fn.attrs.iter().any(|attr| attr.path.is_ident(\"no_mangle\")) {\n   |                                                         ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n32 |                 if item_fn.attrs.iter().any(|attr| attr.path().is_ident(\"no_mangle\")) {\n   |                                                             ++\n\nFor more information about this error, try `rustc --explain E0615`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_panic_behavior_276.rs"
    },
    {
        "mutator_name": "Modify_Pattern_Matching_366",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [],
        "label": "Negative",
        "file": ".\\mutators\\modify_pattern_matching_366.rs"
    },
    {
        "mutator_name": "Modify_PhantomData_Usage_247",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_PhantomData_Usage_247_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `path.segments` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:35:82\n   |\n35 | ...                   if let PathArguments::AngleBracketed(ref mut args) = path.segments.last_mut().unwrap().arguments {\n   |                                                                            ^^^^^^^^^^^^^ `path` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_phantomdata_usage_247.rs"
    },
    {
        "mutator_name": "Modify_Proc_Macro_Attribute_336",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Proc_Macro_Attribute_336_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0615]: attempted to take value of method `path` on type `&Attribute`\n  --> src\\main.rs:34:57\n   |\n34 |                 if item_fn.attrs.iter().any(|attr| attr.path.is_ident(\"proc_macro_attribute\")) {\n   |                                                         ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n34 |                 if item_fn.attrs.iter().any(|attr| attr.path().is_ident(\"proc_macro_attribute\")) {\n   |                                                             ++\n\nerror[E0599]: no variant or associated item named `Semi` found for enum `Stmt` in the current scope\n  --> src\\main.rs:36:38\n   |\n36 |                         if let Stmt::Semi(Expr::Macro(ref mut expr_macro), _) = stmt {\n   |                                      ^^^^ variant or associated item not found in `Stmt`\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:67:25\n   |\n67 |         if let Item::Fn(ref item_fn) = item {\n   |                         ^^^ binding modifier not allowed under `ref` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:67:16\n   |\n67 |         if let Item::Fn(ref item_fn) = item {\n   |                ^^^^^^^^^^^^^^^^^^^^^ this matches on type `&_`\nhelp: remove the unnecessary binding modifier\n   |\n67 -         if let Item::Fn(ref item_fn) = item {\n67 +         if let Item::Fn(item_fn) = item {\n   |\n\nSome errors have detailed explanations: E0599, E0615.\nFor more information about an error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Proc_Macro_Attribute_336_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:36:43\n   |\n36 |                         if let Stmt::Expr(Expr::Macro(ref mut expr_macro)) = stmt {\n   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n36 |                         if let Stmt::Expr(Expr::Macro(ref mut expr_macro), _) = stmt {\n   |                                                                          +++\n\nFor more information about this error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Proc_Macro_Attribute_336_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:33:29\n   |\n33 |             if let Item::Fn(ref mut item_fn) = item {\n   |                             ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:33:20\n   |\n33 |             if let Item::Fn(ref mut item_fn) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n33 -             if let Item::Fn(ref mut item_fn) = item {\n33 +             if let Item::Fn(item_fn) = item {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:36:55\n   |\n36 |                         if let Stmt::Expr(Expr::Macro(ref mut expr_macro), _) = stmt {\n   |                                                       ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:36:32\n   |\n36 |                         if let Stmt::Expr(Expr::Macro(ref mut expr_macro), _) = stmt {\n   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n36 -                         if let Stmt::Expr(Expr::Macro(ref mut expr_macro), _) = stmt {\n36 +                         if let Stmt::Expr(Expr::Macro(expr_macro), _) = stmt {\n   |\n\nerror[E0502]: cannot borrow `*file` as immutable because it is also borrowed as mutable\n  --> src\\main.rs:38:83\n   |\n32 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     mutable borrow occurs here\n   |                     mutable borrow later used here\n...\n38 |                                 if let Some(existing_fn) = find_existing_function(file) {\n   |                                                                                   ^^^^ immutable borrow occurs here\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Proc_Macro_Attribute_336_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:22:59\n   |\n22 | ...                   expr_macro.mac.path = parse_quote!(identity_function);\n   |                                             ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:33:29\n   |\n33 |             file.items.push(parse_quote! {\n   |                             ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:14:20\n   |\n14 |             if let Item::Fn(item_fn) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:17:32\n   |\n17 |                         if let Stmt::Expr(Expr::Macro(expr_macro), _) = stmt {\n   |                                ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:17:43\n   |\n17 |                         if let Stmt::Expr(Expr::Macro(expr_macro), _) = stmt {\n   |                                           ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0412]: cannot find type `SynPath` in this scope\n  --> src\\main.rs:46:55\n   |\n46 | fn find_existing_function(file: &syn::File) -> Option<SynPath> {\n   |                                                       ^^^^^^^ not found in this scope\n   |\nhelp: you might be missing a type parameter\n   |\n46 | fn find_existing_function<SynPath>(file: &syn::File) -> Option<SynPath> {\n   |                          +++++++++\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:48:16\n   |\n48 |         if let Item::Fn(item_fn) = item {\n   |                ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `ReturnType`\n  --> src\\main.rs:49:20\n   |\n49 |             if let ReturnType::Type(_, ref ty) = item_fn.sig.output {\n   |                    ^^^^^^^^^^ use of undeclared type `ReturnType`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::ReturnType;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:50:24\n   |\n50 |                 if let Type::Path(TypePath { path, .. }) = &**ty {\n   |                        ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypePath` in this scope\n  --> src\\main.rs:50:35\n   |\n50 |                 if let Type::Path(TypePath { path, .. }) = &**ty {\n   |                                   ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypePath;\n   |\n\nerror[E0282]: type annotations needed\n  --> src\\main.rs:20:71\n   |\n20 | ...                   expr_macro.mac.path = existing_fn.clone();\n   |                                                         ^^^^^ cannot infer type for type parameter `T` declared on the enum `Option`\n\nSome errors have detailed explanations: E0282, E0412, E0422, E0433.\nFor more information about an error, try `rustc --explain E0282`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 11 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Proc_Macro_Attribute_336_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Modify_Proc_Macro_Attribute_336 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Proc_Macro_Attribute_336_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:18:43\n   |\n18 |                         if let Stmt::Expr(Expr::Macro(expr_macro)) = stmt {\n   |                                           ^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n18 |                         if let Stmt::Expr(Expr::Macro(expr_macro), _) = stmt {\n   |                                                                  +++\n\nFor more information about this error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_proc_macro_attribute_336.rs"
    },
    {
        "mutator_name": "Modify_Return_Type_434",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_return_type_434.rs"
    },
    {
        "mutator_name": "Modify_Specialization_Constraint_423",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Specialization_Constraint_423_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.73s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:57:77:\nexpected identifier\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Specialization_Constraint_423_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:20:35\n   |\n20 |             let new_trait: Item = parse_quote! {\n   |                                   ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:35:77\n   |\n35 | ...                   let new_bound: TypeParamBound = parse_quote!(AnotherTrait);\n   |                                                       ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:3:6\n  |\n3 | impl Mutator for Modify_Specialization_Constraint_423 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Trait(trait_item) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0412]: cannot find type `Item` in this scope\n  --> src\\main.rs:20:28\n   |\n20 |             let new_trait: Item = parse_quote! {\n   |                            ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:27:20\n   |\n27 |             if let Item::Impl(impl_block) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TypeParamBound`\n  --> src\\main.rs:34:48\n   |\n34 | ...                   if let TypeParamBound::Trait(trait_bound) = bound {\n   |                              ^^^^^^^^^^^^^^ use of undeclared type `TypeParamBound`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TypeParamBound;\n   |\n\nerror[E0412]: cannot find type `TypeParamBound` in this scope\n  --> src\\main.rs:35:60\n   |\n35 | ...                   let new_bound: TypeParamBound = parse_quote!(AnotherTrait);\n   |                                      ^^^^^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TypeParamBound;\n   |\n\nSome errors have detailed explanations: E0405, E0412, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 8 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_specialization_constraint_423.rs"
    },
    {
        "mutator_name": "Modify_Struct_Array_Const_324",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Struct_Array_Const_324_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: in expressions, `_` can only be used on the left-hand side of an assignment\n  --> src\\main.rs:35:48\n   |\n35 | ...                   lit: syn::Lit::Int(_),\n   |                                          ^ `_` not allowed here\n\nerror[E0797]: base expression required after `..`\n  --> src\\main.rs:36:31\n   |\n36 | ...                   ..\n   |                         ^\n   |\nhelp: add a base expression here\n   |\n36 |                             ../* expr */\n   |                               ++++++++++\n\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:50:51\n   |\n50 | ...                   if let syn::ImplItem::Method(method) = item {\n   |                                             ^^^^^^ variant or associated item not found in `ImplItem`\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:52:60\n   |\n52 | ...                   if let syn::Stmt::Expr(Expr::Struct(expr_struct)) = &mut method.block.stmts[0] {\n   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n52 |                                     if let syn::Stmt::Expr(Expr::Struct(expr_struct), _) = &mut method.block.stmts[0] {\n   |                                                                                     +++\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:53:102\n   |\n53 | ...                   if let Some((_, expr)) = expr_struct.fields.iter_mut().find(|(ident, _)| ident == \"elements\") {\n   |                                                                                    ^^^^^^^^^^\n   |                                                                                    |\n   |                                                                                    expected `FieldValue`, found `(_, _)`\n   |                                                                                    expected due to this\n   |\n   = note: expected struct `FieldValue`\n               found tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:53:53\n   |\n53 | ...                   if let Some((_, expr)) = expr_struct.fields.iter_mut().find(|(ident, _)| ident == \"elements\") {\n   |                                   ^^^^^^^^^    -------------------------------------------------------------------- this expression has type `Option<&mut FieldValue>`\n   |                                   |\n   |                                   expected `FieldValue`, found `(_, _)`\n   |\n   = note: expected struct `FieldValue`\n               found tuple `(_, _)`\n\nSome errors have detailed explanations: E0023, E0308, E0599, E0797.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 6 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Struct_Array_Const_324_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:21:42\n   |\n21 |                         type_array.len = parse_quote!(6); // Introduce mismatch\n   |                                          ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:33:68\n   |\n33 | ...                   expr_array.elems = parse_quote!([0; 6]); // Intentional size mismatch\n   |                                          ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:3:6\n  |\n3 | impl Mutator for Modify_Struct_Array_Const_324 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n --> src\\main.rs:9:20\n  |\n9 |             if let Item::Struct(item_struct) = item {\n  |                    ^^^^ use of undeclared type `Item`\n  |\nhelp: consider importing this enum\n  |\n1 + use syn::Item;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:11:28\n   |\n11 |                     if let Type::Array(type_array) = &field.ty {\n   |                            ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:12:32\n   |\n12 |                         if let Expr::Lit(expr_lit) = &type_array.len {\n   |                                ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:20:28\n   |\n20 |                     if let Type::Array(type_array) = &mut array_field.ty {\n   |                            ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:24:27\n   |\n24 |             } else if let Item::Impl(item_impl) = item {\n   |                           ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:30:60\n   |\n30 | ...                   if let syn::Stmt::Expr(Expr::Struct(expr_struct), _) = &mut method.block.stmts[0] {\n   |                                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:32:52\n   |\n32 | ...                   if let Expr::Array(expr_array) = &mut field_value.expr {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nSome errors have detailed explanations: E0405, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 10 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Struct_Array_Const_324_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:34:139\n   |\n34 | ...                   if let Some(field_value) = expr_struct.fields.iter_mut().find(|field_value| field_value.member == \"elements\") {\n   |                                                                                                   ------------------    ^^^^^^^^^^ expected `Member`, found `&str`\n   |                                                                                                   |\n   |                                                                                                   expected because this is `Member`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_struct_array_const_324.rs"
    },
    {
        "mutator_name": "Modify_Struct_Uninhabited_Type_337",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_struct_uninhabited_type_337.rs"
    },
    {
        "mutator_name": "Modify_Struct_Union_Alignments_326",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Struct_Union_Alignments_326_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0615]: attempted to take value of method `path` on type `&Attribute`\n  --> src\\main.rs:33:27\n   |\n33 |                     !attr.path.is_ident(\"repr\") || !attr.tokens.to_string().contains(\"packed\")\n   |                           ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n33 |                     !attr.path().is_ident(\"repr\") || !attr.tokens.to_string().contains(\"packed\")\n   |                               ++\n\nerror[E0609]: no field `tokens` on type `&Attribute`\n  --> src\\main.rs:33:58\n   |\n33 |                     !attr.path.is_ident(\"repr\") || !attr.tokens.to_string().contains(\"packed\")\n   |                                                          ^^^^^^ unknown field\n   |\n   = note: available fields are: `pound_token`, `style`, `bracket_token`, `meta`\n\nerror[E0615]: attempted to take value of method `path` on type `&Attribute`\n  --> src\\main.rs:38:27\n   |\n38 |                     !attr.path.is_ident(\"repr\") || !attr.tokens.to_string().contains(\"packed\")\n   |                           ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n38 |                     !attr.path().is_ident(\"repr\") || !attr.tokens.to_string().contains(\"packed\")\n   |                               ++\n\nerror[E0609]: no field `tokens` on type `&Attribute`\n  --> src\\main.rs:38:58\n   |\n38 |                     !attr.path.is_ident(\"repr\") || !attr.tokens.to_string().contains(\"packed\")\n   |                                                          ^^^^^^ unknown field\n   |\n   = note: available fields are: `pound_token`, `style`, `bracket_token`, `meta`\n\nSome errors have detailed explanations: E0609, E0615.\nFor more information about an error, try `rustc --explain E0609`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Struct_Union_Alignments_326_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:33\n   |\n31 |             if let Item::Struct(ref mut item_struct) = item {\n   |                                 ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Struct(ref mut item_struct) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n31 -             if let Item::Struct(ref mut item_struct) = item {\n31 +             if let Item::Struct(item_struct) = item {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:36:32\n   |\n36 |             if let Item::Union(ref mut item_union) = item {\n   |                                ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:36:20\n   |\n36 |             if let Item::Union(ref mut item_union) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n36 -             if let Item::Union(ref mut item_union) = item {\n36 +             if let Item::Union(item_union) = item {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Struct_Union_Alignments_326_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Struct(item_struct) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:16:20\n   |\n16 |             if let Item::Union(item_union) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nFor more information about this error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Struct_Union_Alignments_326_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Modify_Struct_Union_Alignments_326 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Struct_Union_Alignments_326_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0432]: unresolved import `syn::NestedMeta`\n --> src\\main.rs:2:33\n  |\n2 | use syn::{Item, Meta, MetaList, NestedMeta};\n  |                                 ^^^^^^^^^^ no `NestedMeta` in the root\n\nerror[E0599]: no method named `parse_meta` found for reference `&Attribute` in the current scope\n   --> src\\main.rs:15:79\n    |\n15  |                         if let Ok(Meta::List(MetaList { nested, .. })) = attr.parse_meta() {\n    |                                                                               ^^^^^^^^^^\n    |\nhelp: there is a method `parse_nested_meta` with a similar name, but with different arguments\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\attr.rs:391:5\n    |\n391 | /     pub fn parse_nested_meta(\n392 | |         &self,\n393 | |         logic: impl FnMut(ParseNestedMeta) -> Result<()>,\n394 | |     ) -> Result<()> {\n    | |___________________^\n\nerror[E0026]: struct `MetaList` does not have a field named `nested`\n  --> src\\main.rs:15:57\n   |\n15 |                         if let Ok(Meta::List(MetaList { nested, .. })) = attr.parse_meta() {\n   |                                                         ^^^^^^ struct `MetaList` does not have this field\n\nerror[E0599]: no method named `parse_meta` found for reference `&Attribute` in the current scope\n   --> src\\main.rs:31:79\n    |\n31  |                         if let Ok(Meta::List(MetaList { nested, .. })) = attr.parse_meta() {\n    |                                                                               ^^^^^^^^^^\n    |\nhelp: there is a method `parse_nested_meta` with a similar name, but with different arguments\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\attr.rs:391:5\n    |\n391 | /     pub fn parse_nested_meta(\n392 | |         &self,\n393 | |         logic: impl FnMut(ParseNestedMeta) -> Result<()>,\n394 | |     ) -> Result<()> {\n    | |___________________^\n\nerror[E0026]: struct `MetaList` does not have a field named `nested`\n  --> src\\main.rs:31:57\n   |\n31 |                         if let Ok(Meta::List(MetaList { nested, .. })) = attr.parse_meta() {\n   |                                                         ^^^^^^ struct `MetaList` does not have this field\n\nSome errors have detailed explanations: E0026, E0432, E0599.\nFor more information about an error, try `rustc --explain E0026`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 5 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Struct_Union_Alignments_326_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:17:36\n   |\n17 | ...                   if let Meta::Path(path) = meta {\n   |                              ^^^^^^^^^^^^^^^^   ---- this expression has type `ParseNestedMeta<'_>`\n   |                              |\n   |                              expected `ParseNestedMeta<'_>`, found `Meta`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:34:36\n   |\n34 | ...                   if let Meta::Path(path) = meta {\n   |                              ^^^^^^^^^^^^^^^^   ---- this expression has type `ParseNestedMeta<'_>`\n   |                              |\n   |                              expected `ParseNestedMeta<'_>`, found `Meta`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Struct_Union_Alignments_326_compling_err_7.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0432]: unresolved import `syn::NestedMeta`\n --> src\\main.rs:2:34\n  |\n2 | use syn::{Item, Attribute, Meta, NestedMeta};\n  |                                  ^^^^^^^^^^ no `NestedMeta` in the root\n\nerror[E0615]: attempted to take value of method `path` on type `&Attribute`\n  --> src\\main.rs:14:29\n   |\n14 |                     if attr.path.is_ident(\"repr\") {\n   |                             ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n14 |                     if attr.path().is_ident(\"repr\") {\n   |                                 ++\n\nerror[E0599]: no method named `parse_meta` found for reference `&Attribute` in the current scope\n   --> src\\main.rs:16:65\n    |\n16  |                         if let Ok(Meta::List(meta_list)) = attr.parse_meta() {\n    |                                                                 ^^^^^^^^^^\n    |\nhelp: there is a method `parse_nested_meta` with a similar name, but with different arguments\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\attr.rs:391:5\n    |\n391 | /     pub fn parse_nested_meta(\n392 | |         &self,\n393 | |         logic: impl FnMut(ParseNestedMeta) -> Result<()>,\n394 | |     ) -> Result<()> {\n    | |___________________^\n\nerror[E0609]: no field `nested` on type `MetaList`\n  --> src\\main.rs:17:58\n   |\n17 | ...                   for nested_meta in meta_list.nested {\n   |                                                    ^^^^^^ unknown field\n   |\n   = note: available fields are: `path`, `delimiter`, `tokens`\n\nerror[E0615]: attempted to take value of method `path` on type `&Attribute`\n  --> src\\main.rs:32:29\n   |\n32 |                     if attr.path.is_ident(\"repr\") {\n   |                             ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n32 |                     if attr.path().is_ident(\"repr\") {\n   |                                 ++\n\nerror[E0599]: no method named `parse_meta` found for reference `&Attribute` in the current scope\n   --> src\\main.rs:34:65\n    |\n34  |                         if let Ok(Meta::List(meta_list)) = attr.parse_meta() {\n    |                                                                 ^^^^^^^^^^\n    |\nhelp: there is a method `parse_nested_meta` with a similar name, but with different arguments\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\attr.rs:391:5\n    |\n391 | /     pub fn parse_nested_meta(\n392 | |         &self,\n393 | |         logic: impl FnMut(ParseNestedMeta) -> Result<()>,\n394 | |     ) -> Result<()> {\n    | |___________________^\n\nerror[E0609]: no field `nested` on type `MetaList`\n  --> src\\main.rs:35:58\n   |\n35 | ...                   for nested_meta in meta_list.nested {\n   |                                                    ^^^^^^ unknown field\n   |\n   = note: available fields are: `path`, `delimiter`, `tokens`\n\nSome errors have detailed explanations: E0432, E0599, E0609, E0615.\nFor more information about an error, try `rustc --explain E0432`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 7 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Struct_Union_Alignments_326_compling_err_8.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `parse_meta` found for reference `&Attribute` in the current scope\n   --> src\\main.rs:16:65\n    |\n16  |                         if let Ok(Meta::List(meta_list)) = attr.parse_meta() {\n    |                                                                 ^^^^^^^^^^\n    |\nhelp: there is a method `parse_nested_meta` with a similar name, but with different arguments\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\attr.rs:391:5\n    |\n391 | /     pub fn parse_nested_meta(\n392 | |         &self,\n393 | |         logic: impl FnMut(ParseNestedMeta) -> Result<()>,\n394 | |     ) -> Result<()> {\n    | |___________________^\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:18:40\n   |\n18 | ...                   if let Meta::Path(path) = nested_meta {\n   |                              ^^^^^^^^^^^^^^^^   ----------- this expression has type `ParseNestedMeta<'_>`\n   |                              |\n   |                              expected `ParseNestedMeta<'_>`, found `Meta`\n\nerror[E0599]: no method named `parse_meta` found for reference `&Attribute` in the current scope\n   --> src\\main.rs:35:65\n    |\n35  |                         if let Ok(Meta::List(meta_list)) = attr.parse_meta() {\n    |                                                                 ^^^^^^^^^^\n    |\nhelp: there is a method `parse_nested_meta` with a similar name, but with different arguments\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\attr.rs:391:5\n    |\n391 | /     pub fn parse_nested_meta(\n392 | |         &self,\n393 | |         logic: impl FnMut(ParseNestedMeta) -> Result<()>,\n394 | |     ) -> Result<()> {\n    | |___________________^\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:37:40\n   |\n37 | ...                   if let Meta::Path(path) = nested_meta {\n   |                              ^^^^^^^^^^^^^^^^   ----------- this expression has type `ParseNestedMeta<'_>`\n   |                              |\n   |                              expected `ParseNestedMeta<'_>`, found `Meta`\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_struct_union_alignments_326.rs"
    },
    {
        "mutator_name": "Modify_Struct_Union_Constraints_380",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Struct_Union_Constraints_380_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:32:29\n   |\n32 |                 if let Some((_, where_clause)) = &mut item_union.generics.where_clause {\n   |                             ^^^^^^^^^^^^^^^^^    ------------------------------------- this expression has type `&mut Option<WhereClause>`\n   |                             |\n   |                             expected `WhereClause`, found `(_, _)`\n   |\n   = note: expected struct `WhereClause`\n               found tuple `(_, _)`\n\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:36:69\n   |\n36 | ...                   if let Expr::Binary(expr_binary) = &*type_array.len {\n   |                                                           ^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:40:62\n   |\n40 | ...                   type_array.len = Box::new(new_expr);\n   |                       --------------   ^^^^^^^^^^^^^^^^^^ expected `Expr`, found `Box<Expr>`\n   |                       |\n   |                       expected due to the type of this binding\n   |\n   = note: expected enum `syn::Expr`\n            found struct `std::boxed::Box<syn::Expr>`\nhelp: consider unboxing the value\n   |\n40 |                                             type_array.len = *Box::new(new_expr);\n   |                                                              +\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Struct_Union_Constraints_380_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0594]: cannot assign to `type_array.len`, which is behind a `&` reference\n  --> src\\main.rs:40:45\n   |\n40 | ...                   type_array.len = new_expr;\n   |                       ^^^^^^^^^^^^^^ `type_array` is a `&` reference, so the data it refers to cannot be written\n\nFor more information about this error, try `rustc --explain E0594`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_struct_union_constraints_380.rs"
    },
    {
        "mutator_name": "Modify_Trait_And_Function_Bound_Syntax_409",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_and_function_bound_syntax_409.rs"
    },
    {
        "mutator_name": "Modify_Trait_And_Impl_Constraints_422",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [],
        "label": "Negative",
        "file": ".\\mutators\\modify_trait_and_impl_constraints_422.rs"
    },
    {
        "mutator_name": "Modify_Trait_Bounds_328",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bounds_328_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0499]: cannot borrow `file.items` as mutable more than once at a time\n  --> src\\main.rs:38:21\n   |\n32 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     first mutable borrow occurs here\n   |                     first borrow later used here\n...\n38 |                     file.items.push(Item::Trait(trait_c));\n   |                     ^^^^^^^^^^ second mutable borrow occurs here\n\nerror[E0499]: cannot borrow `file.items` as mutable more than once at a time\n  --> src\\main.rs:54:21\n   |\n48 |             for item in &mut file.items {\n   |                         ---------------\n   |                         |\n   |                         first mutable borrow occurs here\n   |                         first borrow later used here\n...\n54 |                     file.items.push(Item::Impl(impl_trait_c));\n   |                     ^^^^^^^^^^ second mutable borrow occurs here\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_bounds_328.rs"
    },
    {
        "mutator_name": "Modify_Trait_Bounds_408",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bounds_408_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0609]: no field `lifetime` on type `&mut GenericParam`\n  --> src\\main.rs:36:38\n   |\n36 |                         lifetime_def.lifetime = Lifetime::new(\"'a\", Span::call_site());\n   |                                      ^^^^^^^^ unknown field\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:44:36\n   |\n44 |                         lifetimes: Punctuated::from_iter(vec![lifetime_param]),\n   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Punctuated<GenericParam, Comma>`, found `Punctuated<LifetimeParam, _>`\n   |\n   = note: expected struct `syn::punctuated::Punctuated<GenericParam, syn::token::Comma>`\n              found struct `syn::punctuated::Punctuated<LifetimeParam, _>`\n\nSome errors have detailed explanations: E0308, E0609.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bounds_408_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0609]: no field `lifetime` on type `&mut GenericParam`\n  --> src\\main.rs:36:40\n   |\n36 |                         lifetime_param.lifetime = Lifetime::new(\"'a\", Span::call_site());\n   |                                        ^^^^^^^^ unknown field\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bounds_408_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:36:55\n   |\n36 |                         if let GenericParam::Lifetime(ref mut lifetime_param) = lifetime_param {\n   |                                                       ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:36:32\n   |\n36 |                         if let GenericParam::Lifetime(ref mut lifetime_param) = lifetime_param {\n   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n36 -                         if let GenericParam::Lifetime(ref mut lifetime_param) = lifetime_param {\n36 +                         if let GenericParam::Lifetime(lifetime_param) = lifetime_param {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bounds_408_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `VisitMut` in this scope\n  --> src\\main.rs:12:14\n   |\n12 |         impl VisitMut for TraitBoundModifierVisitor {\n   |              ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this trait\n   |\n1  + use syn::visit_mut::VisitMut;\n   |\n\nerror[E0412]: cannot find type `TraitBound` in this scope\n  --> src\\main.rs:13:57\n   |\n13 |             fn visit_trait_bound_mut(&mut self, i: &mut TraitBound) {\n   |                                                         ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TraitBound;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericParam`\n  --> src\\main.rs:16:32\n   |\n16 |                         if let GenericParam::Lifetime(lifetime_param) = lifetime_param {\n   |                                ^^^^^^^^^^^^ use of undeclared type `GenericParam`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Lifetime`\n  --> src\\main.rs:17:55\n   |\n17 | ...                   lifetime_param.lifetime = Lifetime::new(\"'a\", Span::call_site());\n   |                                                 ^^^^^^^^ use of undeclared type `Lifetime`\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::Lifetime;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:17:75\n   |\n17 | ...                   lifetime_param.lifetime = Lifetime::new(\"'a\", Span::call_site());\n   |                                                                     ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Lifetime`\n  --> src\\main.rs:21:40\n   |\n21 |                     let new_lifetime = Lifetime::new(\"'a\", Span::call_site());\n   |                                        ^^^^^^^^ use of undeclared type `Lifetime`\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::Lifetime;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:21:60\n   |\n21 |                     let new_lifetime = Lifetime::new(\"'a\", Span::call_site());\n   |                                                            ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `LifetimeParam`\n  --> src\\main.rs:22:42\n   |\n22 |                     let lifetime_param = LifetimeParam::new(new_lifetime.clone());\n   |                                          ^^^^^^^^^^^^^ use of undeclared type `LifetimeParam`\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::LifetimeParam;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `BoundLifetimes` in this scope\n  --> src\\main.rs:23:43\n   |\n23 |                     let bound_lifetimes = BoundLifetimes {\n   |                                           ^^^^^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::BoundLifetimes;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `token`\n  --> src\\main.rs:24:36\n   |\n24 |                         for_token: token::For(Span::call_site()),\n   |                                    ^^^^^ use of unresolved module or unlinked crate `token`\n   |\n   = help: if you wanted to use a crate named `token`, use `cargo add token` to add it to your `Cargo.toml`\nhelp: consider importing this module\n   |\n1  + use syn::token;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:24:47\n   |\n24 |                         for_token: token::For(Span::call_site()),\n   |                                               ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `token`\n  --> src\\main.rs:25:35\n   |\n25 |                         lt_token: token::Lt(Span::call_site()),\n   |                                   ^^^^^ use of unresolved module or unlinked crate `token`\n   |\n   = help: if you wanted to use a crate named `token`, use `cargo add token` to add it to your `Cargo.toml`\nhelp: consider importing this module\n   |\n1  + use syn::token;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:25:45\n   |\n25 |                         lt_token: token::Lt(Span::call_site()),\n   |                                             ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Punctuated`\n  --> src\\main.rs:26:36\n   |\n26 |                         lifetimes: Punctuated::from_iter(vec![GenericParam::Lifetime(lifetime_param)]),\n   |                                    ^^^^^^^^^^ use of undeclared type `Punctuated`\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::punctuated::Punctuated;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericParam`\n  --> src\\main.rs:26:63\n   |\n26 |                         lifetimes: Punctuated::from_iter(vec![GenericParam::Lifetime(lifetime_param)]),\n   |                                                               ^^^^^^^^^^^^ use of undeclared type `GenericParam`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `token`\n  --> src\\main.rs:27:35\n   |\n27 |                         gt_token: token::Gt(Span::call_site()),\n   |                                   ^^^^^ use of unresolved module or unlinked crate `token`\n   |\n   = help: if you wanted to use a crate named `token`, use `cargo add token` to add it to your `Cargo.toml`\nhelp: consider importing this module\n   |\n1  + use syn::token;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:27:45\n   |\n27 |                         gt_token: token::Gt(Span::call_site()),\n   |                                             ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nSome errors have detailed explanations: E0405, E0412, E0422, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 17 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bounds_408_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:9:6\n  |\n9 | impl Mutator for Modify_Trait_Bounds_408 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_bounds_408.rs"
    },
    {
        "mutator_name": "Modify_Trait_Bounds_414",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bounds_414_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.93s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:38:46:\nexpected lifetime\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bounds_414_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.70s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:38:46:\nexpected identifier\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bounds_414_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.92s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:38:46:\nexpected identifier\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bounds_414_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.60s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:38:46:\nexpected identifier\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bounds_414_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:16:46\n   |\n16 |                         let new_type: Type = parse_quote! { impl for<'a> #new_bounds };\n   |                                              ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:3:6\n  |\n3 | impl Mutator for Modify_Trait_Bounds_414 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n --> src\\main.rs:9:20\n  |\n9 |             if let Item::Fn(item_fn) = item {\n  |                    ^^^^ use of undeclared type `Item`\n  |\nhelp: consider importing this enum\n  |\n1 + use syn::Item;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `ReturnType`\n  --> src\\main.rs:10:24\n   |\n10 |                 if let ReturnType::Type(_, return_type) = &item_fn.sig.output {\n   |                        ^^^^^^^^^^ use of undeclared type `ReturnType`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::ReturnType;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:11:28\n   |\n11 |                     if let Type::ImplTrait(type_impl_trait) = &**return_type {\n   |                            ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0412]: cannot find type `Punctuated` in this scope\n  --> src\\main.rs:12:45\n   |\n12 |                         let mut new_bounds: Punctuated<TypeParamBound, Plus> = Punctuated::new();\n   |                                             ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::punctuated::Punctuated;\n   |\n\nerror[E0412]: cannot find type `TypeParamBound` in this scope\n  --> src\\main.rs:12:56\n   |\n12 |                         let mut new_bounds: Punctuated<TypeParamBound, Plus> = Punctuated::new();\n   |                                                        ^^^^^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TypeParamBound;\n   |\n\nerror[E0412]: cannot find type `Plus` in this scope\n  --> src\\main.rs:12:72\n   |\n12 |                         let mut new_bounds: Punctuated<TypeParamBound, Plus> = Punctuated::new();\n   |                                                                        ^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::token::Plus;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Punctuated`\n  --> src\\main.rs:12:80\n   |\n12 |                         let mut new_bounds: Punctuated<TypeParamBound, Plus> = Punctuated::new();\n   |                                                                                ^^^^^^^^^^ use of undeclared type `Punctuated`\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::punctuated::Punctuated;\n   |\n\nerror[E0412]: cannot find type `Type` in this scope\n  --> src\\main.rs:16:39\n   |\n16 |                         let new_type: Type = parse_quote! { impl for<'a> #new_bounds };\n   |                                       ^^^^ not found in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `ReturnType`\n  --> src\\main.rs:17:46\n   |\n17 |                         item_fn.sig.output = ReturnType::Type(\n   |                                              ^^^^^^^^^^ use of undeclared type `ReturnType`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::ReturnType;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `token`\n  --> src\\main.rs:18:29\n   |\n18 | ...                   token::RArrow(Span::call_site()),\n   |                       ^^^^^ use of unresolved module or unlinked crate `token`\n   |\n   = help: if you wanted to use a crate named `token`, use `cargo add token` to add it to your `Cargo.toml`\nhelp: consider importing this module\n   |\n1  + use syn::token;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:18:43\n   |\n18 | ...                   token::RArrow(Span::call_site()),\n   |                                     ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nSome errors have detailed explanations: E0405, E0412, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 13 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bounds_414_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.66s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:22:46:\nexpected identifier\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_trait_bounds_414.rs"
    },
    {
        "mutator_name": "Modify_Trait_Bounds_417",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bounds_417_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:42\n   |\n31 |             if let Item::Impl(ItemImpl { ref mut generics, ref mut trait_, .. }) = item {\n   |                                          ^^^^^^^           ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |                                          |\n   |                                          binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Impl(ItemImpl { ref mut generics, ref mut trait_, .. }) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifiers\n   |\n31 -             if let Item::Impl(ItemImpl { ref mut generics, ref mut trait_, .. }) = item {\n31 +             if let Item::Impl(ItemImpl { generics, trait_, .. }) = item {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:32:33\n   |\n32 |                 if let Some((_, ref mut path, _)) = trait_ {\n   |                                 ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:32:24\n   |\n32 |                 if let Some((_, ref mut path, _)) = trait_ {\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n32 -                 if let Some((_, ref mut path, _)) = trait_ {\n32 +                 if let Some((_, path, _)) = trait_ {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:37:68\n   |\n37 | ...                   if let GenericArgument::Constraint(ref mut constraint) = arg {\n   |                                                          ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:37:40\n   |\n37 | ...                   if let GenericArgument::Constraint(ref mut constraint) = arg {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n37 -                                 if let GenericArgument::Constraint(ref mut constraint) = arg {\n37 +                                 if let GenericArgument::Constraint(constraint) = arg {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bounds_417_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:15:61\n   |\n15 | ...                   let new_bound: TypeParamBound = parse_quote!(Sync);\n   |                                                       ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Impl(ItemImpl { generics, trait_, .. }) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `ItemImpl` in this scope\n  --> src\\main.rs:11:31\n   |\n11 |             if let Item::Impl(ItemImpl { generics, trait_, .. }) = item {\n   |                               ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::ItemImpl;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `PathArguments`\n  --> src\\main.rs:14:32\n   |\n14 |                         if let PathArguments::AngleBracketed(ref mut args) = segment.arguments {\n   |                                ^^^^^^^^^^^^^ use of undeclared type `PathArguments`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::PathArguments;\n   |\n\nerror[E0412]: cannot find type `TypeParamBound` in this scope\n  --> src\\main.rs:15:44\n   |\n15 | ...                   let new_bound: TypeParamBound = parse_quote!(Sync);\n   |                                      ^^^^^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TypeParamBound;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericArgument`\n  --> src\\main.rs:17:40\n   |\n17 | ...                   if let GenericArgument::Constraint(constraint) = arg {\n   |                              ^^^^^^^^^^^^^^^ use of undeclared type `GenericArgument`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericArgument;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TypeParamBound`\n  --> src\\main.rs:18:86\n   |\n18 | ...   if !constraint.bounds.iter().any(|b| matches!(b, TypeParamBound::Trait(TraitBound { path, .. }) if path.is_ident(\"Sync\"))) {\n   |                                                        ^^^^^^^^^^^^^^ use of undeclared type `TypeParamBound`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TypeParamBound;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TraitBound` in this scope\n  --> src\\main.rs:18:108\n   |\n18 | ...   if !constraint.bounds.iter().any(|b| matches!(b, TypeParamBound::Trait(TraitBound { path, .. }) if path.is_ident(\"Sync\"))) {\n   |                                                                              ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TraitBound;\n   |\n\nSome errors have detailed explanations: E0412, E0422, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 8 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bounds_417_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Modify_Trait_Bounds_417 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_bounds_417.rs"
    },
    {
        "mutator_name": "Modify_Trait_Bounds_In_GAT_285",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bounds_In_GAT_285_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.83s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:35:64:\nunexpected token\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bounds_In_GAT_285_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:7:6\n  |\n7 | impl Mutator for Modify_Trait_Bounds_In_GAT_285 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bounds_In_GAT_285_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.70s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:18:64:\nunexpected token\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_bounds_in_gat_285.rs"
    },
    {
        "mutator_name": "Modify_Trait_Bound_310",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_bound_310.rs"
    },
    {
        "mutator_name": "Modify_Trait_Bound_375",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bound_375_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:32:33\n   |\n32 |                 if let Some((_, ref mut path, _)) = &mut item_impl.trait_ {\n   |                                 ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:32:24\n   |\n32 |                 if let Some((_, ref mut path, _)) = &mut item_impl.trait_ {\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n32 -                 if let Some((_, ref mut path, _)) = &mut item_impl.trait_ {\n32 +                 if let Some((_, path, _)) = &mut item_impl.trait_ {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:36:68\n   |\n36 | ...                   if let GenericArgument::Constraint(ref mut constraint) = arg {\n   |                                                          ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:36:40\n   |\n36 | ...                   if let GenericArgument::Constraint(ref mut constraint) = arg {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n36 -                                 if let GenericArgument::Constraint(ref mut constraint) = arg {\n36 +                                 if let GenericArgument::Constraint(constraint) = arg {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bound_375_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Impl(item_impl) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `PathArguments`\n  --> src\\main.rs:14:32\n   |\n14 |                         if let PathArguments::AngleBracketed(ref mut args) = last_segment.arguments {\n   |                                ^^^^^^^^^^^^^ use of undeclared type `PathArguments`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::PathArguments;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericArgument`\n  --> src\\main.rs:16:40\n   |\n16 | ...                   if let GenericArgument::Constraint(constraint) = arg {\n   |                              ^^^^^^^^^^^^^^^ use of undeclared type `GenericArgument`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericArgument;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TypeParamBound`\n  --> src\\main.rs:17:44\n   |\n17 | ...                   if let TypeParamBound::Trait(ref mut trait_bound) = constraint.bounds[0] {\n   |                              ^^^^^^^^^^^^^^ use of undeclared type `TypeParamBound`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TypeParamBound;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:18:95\n   |\n18 | ...                   trait_bound.path.segments.last_mut().unwrap().ident = Ident::new(\"NonExistentTrait\", Span::call_site());\n   |                                                                             ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:18:126\n   |\n18 | ...                   trait_bound.path.segments.last_mut().unwrap().ident = Ident::new(\"NonExistentTrait\", Span::call_site());\n   |                                                                                                            ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nFor more information about this error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 6 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bound_375_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:6:6\n  |\n6 | impl Mutator for Modify_Trait_Bound_375 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bound_375_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:18:62\n   |\n18 | ...                   if let GenericArgument::Type(ref mut ty) = arg {\n   |                                                    ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:18:40\n   |\n18 | ...                   if let GenericArgument::Type(ref mut ty) = arg {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n18 -                                 if let GenericArgument::Type(ref mut ty) = arg {\n18 +                                 if let GenericArgument::Type(ty) = arg {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:19:60\n   |\n19 | ...                   if let syn::Type::Path(ref mut type_path) = ty {\n   |                                              ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:19:44\n   |\n19 | ...                   if let syn::Type::Path(ref mut type_path) = ty {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n19 -                                     if let syn::Type::Path(ref mut type_path) = ty {\n19 +                                     if let syn::Type::Path(type_path) = ty {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_bound_375.rs"
    },
    {
        "mutator_name": "Modify_Trait_Bound_399",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bound_399_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:35:32\n   |\n35 |                         if let Some(bounds) = &mut type_param.bounds {\n   |                                ^^^^^^^^^^^^   ---------------------- this expression has type `&mut syn::punctuated::Punctuated<TypeParamBound, syn::token::Plus>`\n   |                                |\n   |                                expected `Punctuated<TypeParamBound, Plus>`, found `Option<_>`\n   |\n   = note: expected struct `syn::punctuated::Punctuated<TypeParamBound, syn::token::Plus>`\n                found enum `Option<_>`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_bound_399.rs"
    },
    {
        "mutator_name": "Modify_Trait_Bound_436",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bound_436_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0277]: `&mut &mut syn::punctuated::Punctuated<WherePredicate, syn::token::Comma>` is not an iterator\n  --> src\\main.rs:33:34\n   |\n33 | ...r bound in &mut item_impl.generics.where_clause.as_mut().map(|wc| &mut wc.predicates).unwrap_or(&mut Punctuated::new()) {\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `&mut &mut syn::punctuated::Punctuated<WherePredicate, syn::token::Comma>` is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented for `syn::punctuated::Punctuated<WherePredicate, syn::token::Comma>`\n   = note: required for `&mut syn::punctuated::Punctuated<WherePredicate, syn::token::Comma>` to implement `Iterator`\n   = note: 1 redundant requirement hidden\n   = note: required for `&mut &mut syn::punctuated::Punctuated<WherePredicate, syn::token::Comma>` to implement `Iterator`\n   = note: required for `&mut &mut syn::punctuated::Punctuated<WherePredicate, syn::token::Comma>` to implement `IntoIterator`\nhelp: consider removing the leading `&`-reference\n   |\n33 -                     for bound in &mut item_impl.generics.where_clause.as_mut().map(|wc| &mut wc.predicates).unwrap_or(&mut Punctuated::new()) {\n33 +                     for bound in item_impl.generics.where_clause.as_mut().map(|wc| &mut wc.predicates).unwrap_or(&mut Punctuated::new()) {\n   |\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_bound_436.rs"
    },
    {
        "mutator_name": "Modify_Trait_Bound_With_Const_Generics_286",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bound_With_Const_Generics_286_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:32\n   |\n31 |             if let Item::Trait(ref mut trait_item) = item {\n   |                                ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Trait(ref mut trait_item) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n31 -             if let Item::Trait(ref mut trait_item) = item {\n31 +             if let Item::Trait(trait_item) = item {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:33:49\n   |\n33 |                     if let syn::TraitItem::Type(ref mut type_item) = item {\n   |                                                 ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:33:28\n   |\n33 |                     if let syn::TraitItem::Type(ref mut type_item) = item {\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n33 -                     if let syn::TraitItem::Type(ref mut type_item) = item {\n33 +                     if let syn::TraitItem::Type(type_item) = item {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:35:71\n   |\n35 | ...                   if let TypeParamBound::Trait(TraitBound { ref mut path, .. }) = bounds {\n   |                                                                 ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:35:36\n   |\n35 | ...                   if let TypeParamBound::Trait(TraitBound { ref mut path, .. }) = bounds {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n35 -                             if let TypeParamBound::Trait(TraitBound { ref mut path, .. }) = bounds {\n35 +                             if let TypeParamBound::Trait(TraitBound { path, .. }) = bounds {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:39:85\n   |\n39 | ...                   if let GenericArgument::Const(Expr::Lit(ref mut lit)) = arg {\n   |                                                               ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:39:52\n   |\n39 | ...                   if let GenericArgument::Const(Expr::Lit(ref mut lit)) = arg {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n39 -                                             if let GenericArgument::Const(Expr::Lit(ref mut lit)) = arg {\n39 +                                             if let GenericArgument::Const(Expr::Lit(lit)) = arg {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bound_With_Const_Generics_286_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Trait(trait_item) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TypeParamBound`\n  --> src\\main.rs:15:36\n   |\n15 | ...                   if let TypeParamBound::Trait(TraitBound { path, .. }) = bounds {\n   |                              ^^^^^^^^^^^^^^ use of undeclared type `TypeParamBound`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TypeParamBound;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TraitBound` in this scope\n  --> src\\main.rs:15:58\n   |\n15 | ...                   if let TypeParamBound::Trait(TraitBound { path, .. }) = bounds {\n   |                                                    ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TraitBound;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `PathArguments`\n  --> src\\main.rs:17:44\n   |\n17 | ...                   if let PathArguments::AngleBracketed(args) = &mut segment.arguments {\n   |                              ^^^^^^^^^^^^^ use of undeclared type `PathArguments`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::PathArguments;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericArgument`\n  --> src\\main.rs:19:52\n   |\n19 | ...                   if let GenericArgument::Const(Expr::Lit(lit)) = arg {\n   |                              ^^^^^^^^^^^^^^^ use of undeclared type `GenericArgument`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericArgument;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:19:75\n   |\n19 | ...                   if let GenericArgument::Const(Expr::Lit(lit)) = arg {\n   |                                                     ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:26:105\n   |\n26 | ...                   *int_lit = syn::LitInt::new(&new_value.to_string(), Span::call_site());\n   |                                                                           ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0614]: type `LitInt` cannot be dereferenced\n  --> src\\main.rs:26:53\n   |\n26 | ...                   *int_lit = syn::LitInt::new(&new_value.to_string(), Span::call_site());\n   |                       ^^^^^^^^ can't be dereferenced\n\nSome errors have detailed explanations: E0422, E0433, E0614.\nFor more information about an error, try `rustc --explain E0422`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 8 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bound_With_Const_Generics_286_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:6:6\n  |\n6 | impl Mutator for Modify_Trait_Bound_With_Const_Generics_286 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_trait_bound_with_const_generics_286.rs"
    },
    {
        "mutator_name": "Modify_Trait_Bound_With_Inconsistent_Lifetime_403",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Bound_With_Inconsistent_Lifetime_403_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0609]: no field `lifetime` on type `&mut GenericParam`\n  --> src\\main.rs:39:58\n   |\n39 | ...                   lifetime_def.lifetime = Lifetime::new(\"'inconsistent\", Span::call_site());\n   |                                    ^^^^^^^^ unknown field\n\nerror[E0560]: struct `BoundLifetimes` has no field named `colon_token`\n  --> src\\main.rs:45:45\n   |\n45 | ...                   colon_token: Some(token::Colon::default()),\n   |                       ^^^^^^^^^^^ `BoundLifetimes` does not have this field\n   |\n   = note: available fields are: `for_token`, `lt_token`, `gt_token`\n\nerror[E0308]: mismatched types\n   --> src\\main.rs:47:96\n    |\n47  | ...                   trait_bound.lifetimes.as_mut().unwrap().lifetimes.push(LifetimeParam::new(new_lifetime));\n    |                                                                         ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `GenericParam`, found `LifetimeParam`\n    |                                                                         |\n    |                                                                         arguments to this method are incorrect\n    |\nnote: method defined here\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\punctuated.rs:245:12\n    |\n245 |     pub fn push(&mut self, value: T)\n    |            ^^^^\nhelp: try wrapping the expression in `syn::GenericParam::Lifetime`\n    |\n47  |                                         trait_bound.lifetimes.as_mut().unwrap().lifetimes.push(syn::GenericParam::Lifetime(LifetimeParam::new(new_lifetime)));\n    |                                                                                                ++++++++++++++++++++++++++++                                +\n\nSome errors have detailed explanations: E0308, E0560, E0609.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_bound_with_inconsistent_lifetime_403.rs"
    },
    {
        "mutator_name": "Modify_Trait_Delegation_302",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Delegation_302_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `syn::ImplItem` in the current scope\n  --> src\\main.rs:34:42\n   |\n34 |                         if let ImplItem::Method(method) = impl_item {\n   |                                          ^^^^^^ variant or associated item not found in `ImplItem`\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:36:51\n   |\n36 | ...                   if let Stmt::Expr(Expr::Closure(expr_closure)) = block {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n36 |                                 if let Stmt::Expr(Expr::Closure(expr_closure), _) = block {\n   |                                                                              +++\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:39:63\n   |\n39 | ...                   if let Stmt::Expr(Expr::Path(expr_path)) = stmt {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n39 |                                             if let Stmt::Expr(Expr::Path(expr_path), _) = stmt {\n   |                                                                                    +++\n\nSome errors have detailed explanations: E0023, E0599.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Delegation_302_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `expr_block.block.stmts` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:38:61\n   |\n38 | ...                   if let Some(stmt) = expr_block.block.stmts.first_mut() {\n   |                                           ^^^^^^^^^^^^^^^^^^^^^^ `expr_block` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Delegation_302_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:36:51\n   |\n36 | ...                   if let Stmt::Expr(Expr::Closure(expr_closure)) = block {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n36 |                                 if let Stmt::Expr(Expr::Closure(expr_closure), _) = block {\n   |                                                                              +++\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:39:63\n   |\n39 | ...                   if let Stmt::Expr(Expr::Path(expr_path)) = stmt {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n39 |                                             if let Stmt::Expr(Expr::Path(expr_path), _) = stmt {\n   |                                                                                    +++\n\nFor more information about this error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Delegation_302_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Impl(item_impl) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:16:40\n   |\n16 | ...                   if let Stmt::Expr(Expr::Closure(expr_closure), _) = block {\n   |                              ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:16:51\n   |\n16 | ...                   if let Stmt::Expr(Expr::Closure(expr_closure), _) = block {\n   |                                         ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:17:44\n   |\n17 | ...                   if let Expr::Block(expr_block) = &*expr_closure.body {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:19:52\n   |\n19 | ...                   if let Stmt::Expr(Expr::Path(expr_path), _) = stmt {\n   |                              ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:19:63\n   |\n19 | ...                   if let Stmt::Expr(Expr::Path(expr_path), _) = stmt {\n   |                                         ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:23:73\n   |\n23 | ...                   segment.ident = Ident::new(\"\", Span::call_site());\n   |                                       ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:23:88\n   |\n23 | ...                   segment.ident = Ident::new(\"\", Span::call_site());\n   |                                                      ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nFor more information about this error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 8 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Delegation_302_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:6:6\n  |\n6 | impl Mutator for Modify_Trait_Delegation_302 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Delegation_302_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:18:51\n   |\n18 | ...                   if let Stmt::Expr(Expr::Closure(expr_closure)) = block {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n18 |                                 if let Stmt::Expr(Expr::Closure(expr_closure), _) = block {\n   |                                                                              +++\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:21:63\n   |\n21 | ...                   if let Stmt::Expr(Expr::Path(expr_path)) = stmt {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n21 |                                             if let Stmt::Expr(Expr::Path(expr_path), _) = stmt {\n   |                                                                                    +++\n\nFor more information about this error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Delegation_302_compling_err_7.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `expr_block.block.stmts` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:20:61\n   |\n20 | ...                   if let Some(stmt) = expr_block.block.stmts.first_mut() {\n   |                                           ^^^^^^^^^^^^^^^^^^^^^^ `expr_block` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Delegation_302_compling_err_8.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:18:51\n   |\n18 | ...                   if let Stmt::Expr(Expr::Closure(expr_closure)) = block {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n18 |                                 if let Stmt::Expr(Expr::Closure(expr_closure), _) = block {\n   |                                                                              +++\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:22:63\n   |\n22 | ...                   if let Stmt::Expr(Expr::Path(expr_path)) = stmt {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n22 |                                             if let Stmt::Expr(Expr::Path(expr_path), _) = stmt {\n   |                                                                                    +++\n\nFor more information about this error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_trait_delegation_302.rs"
    },
    {
        "mutator_name": "Modify_Trait_Function_Signatures_299",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Function_Signatures_299_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `TraitItem` in the current scope\n  --> src\\main.rs:34:44\n   |\n34 |                     if let syn::TraitItem::Method(method) = trait_item {\n   |                                            ^^^^^^ variant or associated item not found in `TraitItem`\n\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:40:77\n   |\n40 | ...                   if let Type::Path(TypePath { path, .. }) = &**ty {\n   |                                                                   ^^^^ can't be dereferenced\n\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:53:73\n   |\n53 | ...                   if let Type::Path(TypePath { path, .. }) = &**ty {\n   |                                                                   ^^^^ can't be dereferenced\n\nSome errors have detailed explanations: E0599, E0614.\nFor more information about an error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Function_Signatures_299_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0432]: unresolved import `syn::TraitItemMethod`\n  --> src\\main.rs:19:27\n   |\n19 |     ItemTrait, TraitItem, TraitItemMethod,\n   |                           ^^^^^^^^^^^^^^^\n   |                           |\n   |                           no `TraitItemMethod` in the root\n   |                           help: a similar name exists in the module: `TraitItemMacro`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `TraitItem` in the current scope\n  --> src\\main.rs:35:39\n   |\n35 |                     if let TraitItem::Method(method) = trait_item {\n   |                                       ^^^^^^ variant or associated item not found in `TraitItem`\n\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:41:77\n   |\n41 | ...                   if let Type::Path(TypePath { path, .. }) = &**ty {\n   |                                                                   ^^^^ can't be dereferenced\n\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:54:73\n   |\n54 | ...                   if let Type::Path(TypePath { path, .. }) = &**ty {\n   |                                                                   ^^^^ can't be dereferenced\n\nSome errors have detailed explanations: E0432, E0599, E0614.\nFor more information about an error, try `rustc --explain E0432`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_function_signatures_299.rs"
    },
    {
        "mutator_name": "Modify_Trait_Implementation_344",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Implementation_344_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `syn::ImplItem` in the current scope\n  --> src\\main.rs:47:54\n   |\n47 | ...                   if let ImplItem::Method(method) = impl_item {\n   |                                        ^^^^^^ variant or associated item not found in `ImplItem`\n\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:49:77\n   |\n49 | ...                   if let Type::Path(type_path) = &**ty {\n   |                                                       ^^^^ can't be dereferenced\n\nSome errors have detailed explanations: E0599, E0614.\nFor more information about an error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Implementation_344_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0432]: unresolved import `syn::ImplItemMethod`\n  --> src\\main.rs:19:29\n   |\n19 |     ImplItem, ImplItemType, ImplItemMethod,\n   |                             ^^^^^^^^^^^^^^\n   |                             |\n   |                             no `ImplItemMethod` in the root\n   |                             help: a similar name exists in the module: `ImplItemMacro`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:48:54\n   |\n48 | ...                   if let ImplItem::Method(method) = impl_item {\n   |                                        ^^^^^^ variant or associated item not found in `ImplItem`\n\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:50:81\n   |\n50 | ...                   if let Type::Path(type_path) = &mut **ty {\n   |                                                           ^^^^ can't be dereferenced\n\nSome errors have detailed explanations: E0432, E0599, E0614.\nFor more information about an error, try `rustc --explain E0432`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Implementation_344_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:48:54\n   |\n48 | ...                   if let ImplItem::Method(method) = impl_item {\n   |                                        ^^^^^^ variant or associated item not found in `ImplItem`\n\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:50:81\n   |\n50 | ...                   if let Type::Path(type_path) = &mut **ty {\n   |                                                           ^^^^ can't be dereferenced\n\nSome errors have detailed explanations: E0599, E0614.\nFor more information about an error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Implementation_344_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0432]: unresolved import `syn::ImplItemMethod`\n  --> src\\main.rs:19:29\n   |\n19 |     ImplItem, ImplItemType, ImplItemMethod,\n   |                             ^^^^^^^^^^^^^^\n   |                             |\n   |                             no `ImplItemMethod` in the root\n   |                             help: a similar name exists in the module: `ImplItemMacro`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:48:54\n   |\n48 | ...                   if let ImplItem::Method(method) = impl_item {\n   |                                        ^^^^^^ variant or associated item not found in `ImplItem`\n\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:50:81\n   |\n50 | ...                   if let Type::Path(type_path) = &mut **ty {\n   |                                                           ^^^^ can't be dereferenced\n\nSome errors have detailed explanations: E0432, E0599, E0614.\nFor more information about an error, try `rustc --explain E0432`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Implementation_344_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:48:54\n   |\n48 | ...                   if let ImplItem::Method(method) = impl_item {\n   |                                        ^^^^^^ variant or associated item not found in `ImplItem`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Implementation_344_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0432]: unresolved import `syn::ImplItemMethod`\n  --> src\\main.rs:19:29\n   |\n19 |     ImplItem, ImplItemType, ImplItemMethod,\n   |                             ^^^^^^^^^^^^^^\n   |                             |\n   |                             no `ImplItemMethod` in the root\n   |                             help: a similar name exists in the module: `ImplItemMacro`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:48:54\n   |\n48 | ...                   if let ImplItem::Method(method) = impl_item {\n   |                                        ^^^^^^ variant or associated item not found in `ImplItem`\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Implementation_344_compling_err_7.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:48:54\n   |\n48 | ...                   if let ImplItem::Method(method) = impl_item {\n   |                                        ^^^^^^ variant or associated item not found in `ImplItem`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Implementation_344_compling_err_8.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0432]: unresolved import `syn::ImplItemMethod`\n  --> src\\main.rs:19:29\n   |\n19 |     ImplItem, ImplItemType, ImplItemMethod,\n   |                             ^^^^^^^^^^^^^^\n   |                             |\n   |                             no `ImplItemMethod` in the root\n   |                             help: a similar name exists in the module: `ImplItemMacro`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:48:54\n   |\n48 | ...                   if let ImplItem::Method(method) = impl_item {\n   |                                        ^^^^^^ variant or associated item not found in `ImplItem`\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Implementation_344_compling_err_9.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:50:52\n   |\n50 | ...                   if let Type::Path(type_path) = &mut *ty {\n   |                              ^^^^^^^^^^^^^^^^^^^^^   -------- this expression has type `&mut std::boxed::Box<syn::Type>`\n   |                              |\n   |                              expected `Box<Type>`, found `Type`\n   |\n   = note: expected struct `std::boxed::Box<syn::Type>`\n                found enum `syn::Type`\nhelp: consider dereferencing to access the inner value using the Deref trait\n   |\n50 -                                             if let Type::Path(type_path) = &mut *ty {\n50 +                                             if let Type::Path(type_path) = &**ty {\n   |\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_implementation_344.rs"
    },
    {
        "mutator_name": "Modify_Trait_Impl_Associated_Type_372",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Impl_Associated_Type_372_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.08s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:52:38:\nunexpected token\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Impl_Associated_Type_372_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:30:38\n   |\n30 |             let new_impl: ItemImpl = parse_quote! {\n   |                                      ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:3:6\n  |\n3 | impl Mutator for Modify_Trait_Impl_Associated_Type_372 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nerror[E0425]: cannot find function `thread_rng` in this scope\n --> src\\main.rs:8:23\n  |\n8 |         let mut rng = thread_rng();\n  |                       ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use rand::thread_rng;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:12:20\n   |\n12 |             if let Item::Impl(item_impl) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0412]: cannot find type `ItemImpl` in this scope\n  --> src\\main.rs:30:27\n   |\n30 |             let new_impl: ItemImpl = parse_quote! {\n   |                           ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::ItemImpl;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:44:29\n   |\n44 |             file.items.push(Item::Impl(new_impl));\n   |                             ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nSome errors have detailed explanations: E0405, E0412, E0425, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 6 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Impl_Associated_Type_372_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `choose` found for struct `Vec<(syn::Path, std::boxed::Box<syn::Type>)>` in the current scope\n  --> src\\main.rs:33:59\n   |\n33 |         if let Some((trait_path, _self_ty)) = trait_impls.choose(&mut rng) {\n   |                                                           ^^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: trait `SliceRandom` which provides `choose` is implemented but not in scope; perhaps you want to import it\n   |\n1  + use rand::prelude::SliceRandom;\n   |\nhelp: there is a method `choose_mut` with a similar name\n   |\n33 |         if let Some((trait_path, _self_ty)) = trait_impls.choose_mut(&mut rng) {\n   |                                                                 ++++\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Impl_Associated_Type_372_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.98s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:35:38:\nexpected `impl`\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_impl_associated_type_372.rs"
    },
    {
        "mutator_name": "Modify_Trait_Impl_Assoc_Type_421",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Impl_Assoc_Type_421_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:57:52\n   |\n57 | ...                   impl_type.ty = Box::new(new_type.clone());\n   |                       ------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Type`, found `Box<Type>`\n   |                       |\n   |                       expected due to the type of this binding\n   |\n   = note: expected enum `syn::Type`\n            found struct `std::boxed::Box<syn::Type>`\nhelp: consider unboxing the value\n   |\n57 |                                     impl_type.ty = *Box::new(new_type.clone());\n   |                                                    +\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Impl_Assoc_Type_421_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0412]: cannot find type `Type` in this scope\n  --> src\\main.rs:15:32\n   |\n15 |             types: &'a mut Vec<Type>,\n   |                                ^^^^ not found in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0405]: cannot find trait `Visit` in this scope\n  --> src\\main.rs:18:18\n   |\n18 |         impl<'a> Visit<'_> for TypeCollector<'a> {\n   |                  ^^^^^ not found in this scope\n   |\nhelp: consider importing this trait\n   |\n1  + use syn::visit::Visit;\n   |\n\nerror[E0412]: cannot find type `Type` in this scope\n  --> src\\main.rs:19:45\n   |\n19 |             fn visit_type(&mut self, node: &Type) {\n   |                                             ^^^^ not found in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Impl(ItemImpl { trait_, items, .. }) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `ItemImpl` in this scope\n  --> src\\main.rs:31:31\n   |\n31 |             if let Item::Impl(ItemImpl { trait_, items, .. }) = item {\n   |                               ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::ItemImpl;\n   |\n\nerror[E0425]: cannot find function `thread_rng` in this scope\n  --> src\\main.rs:36:85\n   |\n36 | ...                   if let Some(new_type) = type_candidates.choose(&mut thread_rng()) {\n   |                                                                           ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  + use rand::thread_rng;\n   |\n\nSome errors have detailed explanations: E0405, E0412, E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 6 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Impl_Assoc_Type_421_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:7:6\n  |\n7 | impl Mutator for Modify_Trait_Impl_Assoc_Type_421 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_impl_assoc_type_421.rs"
    },
    {
        "mutator_name": "Modify_Trait_Impl_Const_Generics_420",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_impl_const_generics_420.rs"
    },
    {
        "mutator_name": "Const_Expression_Mutation_271",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Const_Expression_Mutation_271_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0425]: cannot find function, tuple struct or tuple variant `Sub` in module `token`\n   --> src\\main.rs:41:82\n    |\n41  |   ...                   syn::BinOp::Add(_) => syn::BinOp::Sub(token::Sub(expr_binary.op.span())),\n    |                                                                      ^^^\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\token.rs:690:1\n    |\n690 | / define_keywords! {\n691 | |     \"abstract\"    pub struct Abstract\n692 | |     \"as\"          pub struct As\n693 | |     \"async\"       pub struct Async\n...   |\n743 | |     \"yield\"       pub struct Yield\n744 | | }\n    | |_- similarly named function `Pub` defined here\n    |\nhelp: a function with a similar name exists\n    |\n41  -                                     syn::BinOp::Add(_) => syn::BinOp::Sub(token::Sub(expr_binary.op.span())),\n41  +                                     syn::BinOp::Add(_) => syn::BinOp::Sub(token::Pub(expr_binary.op.span())),\n    |\nhelp: consider importing one of these tuple variants\n    |\n1   + use crate::BinOp::Sub;\n    |\n1   + use syn::BinOp::Sub;\n    |\nhelp: if you import `Sub`, refer to it directly\n    |\n41  -                                     syn::BinOp::Add(_) => syn::BinOp::Sub(token::Sub(expr_binary.op.span())),\n41  +                                     syn::BinOp::Add(_) => syn::BinOp::Sub(Sub(expr_binary.op.span())),\n    |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Add` in module `token`\n   --> src\\main.rs:42:82\n    |\n42  |   ...                   syn::BinOp::Sub(_) => syn::BinOp::Add(token::Add(expr_binary.op.span())),\n    |                                                                      ^^^\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\token.rs:746:1\n    |\n746 | / define_punctuation! {\n747 | |     \"&\"           pub struct And/1        /// bitwise and logical AND, borrow, references, reference patterns\n748 | |     \"&&\"          pub struct AndAnd/2     /// lazy AND, borrow, references, reference patterns\n749 | |     \"&=\"          pub struct AndEq/2      /// bitwise AND assignment\n...   |\n792 | |     \"~\"           pub struct Tilde/1      /// unused since before Rust 1.0\n793 | | }\n    | |_- similarly named function `And` defined here\n    |\nhelp: a function with a similar name exists\n    |\n42  -                                     syn::BinOp::Sub(_) => syn::BinOp::Add(token::Add(expr_binary.op.span())),\n42  +                                     syn::BinOp::Sub(_) => syn::BinOp::Add(token::And(expr_binary.op.span())),\n    |\nhelp: consider importing one of these tuple variants\n    |\n1   + use crate::BinOp::Add;\n    |\n1   + use syn::BinOp::Add;\n    |\nhelp: if you import `Add`, refer to it directly\n    |\n42  -                                     syn::BinOp::Sub(_) => syn::BinOp::Add(token::Add(expr_binary.op.span())),\n42  +                                     syn::BinOp::Sub(_) => syn::BinOp::Add(Add(expr_binary.op.span())),\n    |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Div` in module `token`\n  --> src\\main.rs:43:82\n   |\n43 | ...                   syn::BinOp::Mul(_) => syn::BinOp::Div(token::Div(expr_binary.op.span())),\n   |                                                                    ^^^ not found in `token`\n   |\nhelp: consider importing one of these tuple variants\n   |\n1  + use crate::BinOp::Div;\n   |\n1  + use syn::BinOp::Div;\n   |\nhelp: if you import `Div`, refer to it directly\n   |\n43 -                                     syn::BinOp::Mul(_) => syn::BinOp::Div(token::Div(expr_binary.op.span())),\n43 +                                     syn::BinOp::Mul(_) => syn::BinOp::Div(Div(expr_binary.op.span())),\n   |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Mul` in module `token`\n   --> src\\main.rs:44:82\n    |\n44  |   ...                   syn::BinOp::Div(_) => syn::BinOp::Mul(token::Mul(expr_binary.op.span())),\n    |                                                                      ^^^\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\token.rs:690:1\n    |\n690 | / define_keywords! {\n691 | |     \"abstract\"    pub struct Abstract\n692 | |     \"as\"          pub struct As\n693 | |     \"async\"       pub struct Async\n...   |\n743 | |     \"yield\"       pub struct Yield\n744 | | }\n    | |_- similarly named function `Mut` defined here\n    |\nhelp: a function with a similar name exists\n    |\n44  -                                     syn::BinOp::Div(_) => syn::BinOp::Mul(token::Mul(expr_binary.op.span())),\n44  +                                     syn::BinOp::Div(_) => syn::BinOp::Mul(token::Mut(expr_binary.op.span())),\n    |\nhelp: consider importing one of these tuple variants\n    |\n1   + use crate::BinOp::Mul;\n    |\n1   + use syn::BinOp::Mul;\n    |\nhelp: if you import `Mul`, refer to it directly\n    |\n44  -                                     syn::BinOp::Div(_) => syn::BinOp::Mul(token::Mul(expr_binary.op.span())),\n44  +                                     syn::BinOp::Div(_) => syn::BinOp::Mul(Mul(expr_binary.op.span())),\n    |\n\nFor more information about this error, try `rustc --explain E0425`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Const_Expression_Mutation_271_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Const_Expression_Mutation_271 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nerror[E0405]: cannot find trait `VisitMut` in this scope\n  --> src\\main.rs:12:14\n   |\n12 |         impl VisitMut for ConstExprMutator {\n   |              ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this trait\n   |\n1  + use syn::visit_mut::VisitMut;\n   |\n\nerror[E0412]: cannot find type `Expr` in this scope\n  --> src\\main.rs:13:53\n   |\n13 |             fn visit_expr_mut(&mut self, expr: &mut Expr) {\n   |                                                     ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:14:24\n   |\n14 |                 if let Expr::Binary(expr_binary) = expr {\n   |                        ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:15:28\n   |\n15 |                     if let Expr::Path(expr_path) = &*expr_binary.left {\n   |                            ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:37:20\n   |\n37 |             if let Item::Fn(item_fn) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericParam`\n  --> src\\main.rs:39:28\n   |\n39 |                     if let GenericParam::Const(_) = param {\n   |                            ^^^^^^^^^^^^ use of undeclared type `GenericParam`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `token`\n  --> src\\main.rs:21:65\n   |\n21 | ...                   BinOp::Add(_) => BinOp::Sub(token::Sub(expr_binary.op.span())),\n   |                                                   ^^^^^ use of unresolved module or unlinked crate `token`\n   |\n   = help: if you wanted to use a crate named `token`, use `cargo add token` to add it to your `Cargo.toml`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `token`\n  --> src\\main.rs:22:65\n   |\n22 | ...                   BinOp::Sub(_) => BinOp::Add(token::Add(expr_binary.op.span())),\n   |                                                   ^^^^^ use of unresolved module or unlinked crate `token`\n   |\n   = help: if you wanted to use a crate named `token`, use `cargo add token` to add it to your `Cargo.toml`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `token`\n  --> src\\main.rs:23:65\n   |\n23 | ...                   BinOp::Mul(_) => BinOp::Div(token::Div(expr_binary.op.span())),\n   |                                                   ^^^^^ use of unresolved module or unlinked crate `token`\n   |\n   = help: if you wanted to use a crate named `token`, use `cargo add token` to add it to your `Cargo.toml`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `token`\n  --> src\\main.rs:24:65\n   |\n24 | ...                   BinOp::Div(_) => BinOp::Mul(token::Mul(expr_binary.op.span())),\n   |                                                   ^^^^^ use of unresolved module or unlinked crate `token`\n   |\n   = help: if you wanted to use a crate named `token`, use `cargo add token` to add it to your `Cargo.toml`\n\nSome errors have detailed explanations: E0405, E0412, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 11 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Const_Expression_Mutation_271_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0422]: cannot find struct, variant or union type `Sub` in module `token`\n   --> src\\main.rs:22:72\n    |\n22  |   ...                   BinOp::Add(_) => BinOp::Sub(token::Sub { spans: [expr_binary.op.span()] }),\n    |                                                            ^^^\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\token.rs:690:1\n    |\n690 | / define_keywords! {\n691 | |     \"abstract\"    pub struct Abstract\n692 | |     \"as\"          pub struct As\n693 | |     \"async\"       pub struct Async\n...   |\n743 | |     \"yield\"       pub struct Yield\n744 | | }\n    | |_- similarly named struct `Pub` defined here\n    |\nhelp: a struct with a similar name exists\n    |\n22  -                                     BinOp::Add(_) => BinOp::Sub(token::Sub { spans: [expr_binary.op.span()] }),\n22  +                                     BinOp::Add(_) => BinOp::Sub(token::Pub { spans: [expr_binary.op.span()] }),\n    |\nhelp: consider importing one of these variants\n    |\n1   + use crate::BinOp::Sub;\n    |\n1   + use syn::BinOp::Sub;\n    |\nhelp: if you import `Sub`, refer to it directly\n    |\n22  -                                     BinOp::Add(_) => BinOp::Sub(token::Sub { spans: [expr_binary.op.span()] }),\n22  +                                     BinOp::Add(_) => BinOp::Sub(Sub { spans: [expr_binary.op.span()] }),\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Add` in module `token`\n   --> src\\main.rs:23:72\n    |\n23  |   ...                   BinOp::Sub(_) => BinOp::Add(token::Add { spans: [expr_binary.op.span()] }),\n    |                                                            ^^^\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\token.rs:746:1\n    |\n746 | / define_punctuation! {\n747 | |     \"&\"           pub struct And/1        /// bitwise and logical AND, borrow, references, reference patterns\n748 | |     \"&&\"          pub struct AndAnd/2     /// lazy AND, borrow, references, reference patterns\n749 | |     \"&=\"          pub struct AndEq/2      /// bitwise AND assignment\n...   |\n792 | |     \"~\"           pub struct Tilde/1      /// unused since before Rust 1.0\n793 | | }\n    | |_- similarly named struct `And` defined here\n    |\nhelp: a struct with a similar name exists\n    |\n23  -                                     BinOp::Sub(_) => BinOp::Add(token::Add { spans: [expr_binary.op.span()] }),\n23  +                                     BinOp::Sub(_) => BinOp::Add(token::And { spans: [expr_binary.op.span()] }),\n    |\nhelp: consider importing one of these variants\n    |\n1   + use crate::BinOp::Add;\n    |\n1   + use syn::BinOp::Add;\n    |\nhelp: if you import `Add`, refer to it directly\n    |\n23  -                                     BinOp::Sub(_) => BinOp::Add(token::Add { spans: [expr_binary.op.span()] }),\n23  +                                     BinOp::Sub(_) => BinOp::Add(Add { spans: [expr_binary.op.span()] }),\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Div` in module `token`\n  --> src\\main.rs:24:72\n   |\n24 | ...                   BinOp::Mul(_) => BinOp::Div(token::Div { spans: [expr_binary.op.span()] }),\n   |                                                          ^^^ not found in `token`\n   |\nhelp: consider importing one of these variants\n   |\n1  + use crate::BinOp::Div;\n   |\n1  + use syn::BinOp::Div;\n   |\nhelp: if you import `Div`, refer to it directly\n   |\n24 -                                     BinOp::Mul(_) => BinOp::Div(token::Div { spans: [expr_binary.op.span()] }),\n24 +                                     BinOp::Mul(_) => BinOp::Div(Div { spans: [expr_binary.op.span()] }),\n   |\n\nerror[E0422]: cannot find struct, variant or union type `Mul` in module `token`\n   --> src\\main.rs:25:72\n    |\n25  |   ...                   BinOp::Div(_) => BinOp::Mul(token::Mul { spans: [expr_binary.op.span()] }),\n    |                                                            ^^^\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\token.rs:690:1\n    |\n690 | / define_keywords! {\n691 | |     \"abstract\"    pub struct Abstract\n692 | |     \"as\"          pub struct As\n693 | |     \"async\"       pub struct Async\n...   |\n743 | |     \"yield\"       pub struct Yield\n744 | | }\n    | |_- similarly named struct `Mut` defined here\n    |\nhelp: a struct with a similar name exists\n    |\n25  -                                     BinOp::Div(_) => BinOp::Mul(token::Mul { spans: [expr_binary.op.span()] }),\n25  +                                     BinOp::Div(_) => BinOp::Mul(token::Mut { spans: [expr_binary.op.span()] }),\n    |\nhelp: consider importing one of these variants\n    |\n1   + use crate::BinOp::Mul;\n    |\n1   + use syn::BinOp::Mul;\n    |\nhelp: if you import `Mul`, refer to it directly\n    |\n25  -                                     BinOp::Div(_) => BinOp::Mul(token::Mul { spans: [expr_binary.op.span()] }),\n25  +                                     BinOp::Div(_) => BinOp::Mul(Mul { spans: [expr_binary.op.span()] }),\n    |\n\nerror[E0599]: no method named `span` found for enum `BinOp` in the current scope\n   --> src\\main.rs:22:101\n    |\n22  | ...                   BinOp::Add(_) => BinOp::Sub(token::Sub { spans: [expr_binary.op.span()] }),\n    |                                                                                       ^^^^\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\spanned.rs:101:8\n    |\n101 |     fn span(&self) -> Span;\n    |        ---- the method is available for `BinOp` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Spanned` which provides `span` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use syn::spanned::Spanned;\n    |\nhelp: there is a method `__span` with a similar name\n    |\n22  |                                     BinOp::Add(_) => BinOp::Sub(token::Sub { spans: [expr_binary.op.__span()] }),\n    |                                                                                                     ++\n\nerror[E0599]: no method named `span` found for enum `BinOp` in the current scope\n   --> src\\main.rs:23:101\n    |\n23  | ...                   BinOp::Sub(_) => BinOp::Add(token::Add { spans: [expr_binary.op.span()] }),\n    |                                                                                       ^^^^\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\spanned.rs:101:8\n    |\n101 |     fn span(&self) -> Span;\n    |        ---- the method is available for `BinOp` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Spanned` which provides `span` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use syn::spanned::Spanned;\n    |\nhelp: there is a method `__span` with a similar name\n    |\n23  |                                     BinOp::Sub(_) => BinOp::Add(token::Add { spans: [expr_binary.op.__span()] }),\n    |                                                                                                     ++\n\nerror[E0599]: no method named `span` found for enum `BinOp` in the current scope\n   --> src\\main.rs:24:101\n    |\n24  | ...                   BinOp::Mul(_) => BinOp::Div(token::Div { spans: [expr_binary.op.span()] }),\n    |                                                                                       ^^^^\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\spanned.rs:101:8\n    |\n101 |     fn span(&self) -> Span;\n    |        ---- the method is available for `BinOp` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Spanned` which provides `span` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use syn::spanned::Spanned;\n    |\nhelp: there is a method `__span` with a similar name\n    |\n24  |                                     BinOp::Mul(_) => BinOp::Div(token::Div { spans: [expr_binary.op.__span()] }),\n    |                                                                                                     ++\n\nerror[E0599]: no method named `span` found for enum `BinOp` in the current scope\n   --> src\\main.rs:25:101\n    |\n25  | ...                   BinOp::Div(_) => BinOp::Mul(token::Mul { spans: [expr_binary.op.span()] }),\n    |                                                                                       ^^^^\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\spanned.rs:101:8\n    |\n101 |     fn span(&self) -> Span;\n    |        ---- the method is available for `BinOp` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Spanned` which provides `span` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use syn::spanned::Spanned;\n    |\nhelp: there is a method `__span` with a similar name\n    |\n25  |                                     BinOp::Div(_) => BinOp::Mul(token::Mul { spans: [expr_binary.op.__span()] }),\n    |                                                                                                     ++\n\nSome errors have detailed explanations: E0422, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 8 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Const_Expression_Mutation_271_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Const_Expression_Mutation_271 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nerror[E0405]: cannot find trait `VisitMut` in this scope\n  --> src\\main.rs:12:14\n   |\n12 |         impl VisitMut for ConstExprMutator {\n   |              ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this trait\n   |\n1  + use syn::visit_mut::VisitMut;\n   |\n\nerror[E0412]: cannot find type `Expr` in this scope\n  --> src\\main.rs:13:53\n   |\n13 |             fn visit_expr_mut(&mut self, expr: &mut Expr) {\n   |                                                     ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:14:24\n   |\n14 |                 if let Expr::Binary(expr_binary) = expr {\n   |                        ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:15:28\n   |\n15 |                     if let Expr::Path(expr_path) = &*expr_binary.left {\n   |                            ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `BinOp`\n  --> src\\main.rs:20:37\n   |\n20 | ...                   BinOp::Add(_) => BinOp::Sub(token::Sub { spans: [expr_binary.op.span()] }),\n   |                       ^^^^^ use of undeclared type `BinOp`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::BinOp;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `BinOp`\n  --> src\\main.rs:20:54\n   |\n20 | ...                   BinOp::Add(_) => BinOp::Sub(token::Sub { spans: [expr_binary.op.span()] }),\n   |                                        ^^^^^ use of undeclared type `BinOp`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::BinOp;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `BinOp`\n  --> src\\main.rs:21:37\n   |\n21 | ...                   BinOp::Sub(_) => BinOp::Add(token::Add { spans: [expr_binary.op.span()] }),\n   |                       ^^^^^ use of undeclared type `BinOp`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::BinOp;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `BinOp`\n  --> src\\main.rs:21:54\n   |\n21 | ...                   BinOp::Sub(_) => BinOp::Add(token::Add { spans: [expr_binary.op.span()] }),\n   |                                        ^^^^^ use of undeclared type `BinOp`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::BinOp;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `BinOp`\n  --> src\\main.rs:22:37\n   |\n22 | ...                   BinOp::Mul(_) => BinOp::Div(token::Div { spans: [expr_binary.op.span()] }),\n   |                       ^^^^^ use of undeclared type `BinOp`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::BinOp;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `BinOp`\n  --> src\\main.rs:22:54\n   |\n22 | ...                   BinOp::Mul(_) => BinOp::Div(token::Div { spans: [expr_binary.op.span()] }),\n   |                                        ^^^^^ use of undeclared type `BinOp`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::BinOp;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `BinOp`\n  --> src\\main.rs:23:37\n   |\n23 | ...                   BinOp::Div(_) => BinOp::Mul(token::Mul { spans: [expr_binary.op.span()] }),\n   |                       ^^^^^ use of undeclared type `BinOp`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::BinOp;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `BinOp`\n  --> src\\main.rs:23:54\n   |\n23 | ...                   BinOp::Div(_) => BinOp::Mul(token::Mul { spans: [expr_binary.op.span()] }),\n   |                                        ^^^^^ use of undeclared type `BinOp`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::BinOp;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:36:20\n   |\n36 |             if let Item::Fn(item_fn) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericParam`\n  --> src\\main.rs:38:28\n   |\n38 |                     if let GenericParam::Const(_) = param {\n   |                            ^^^^^^^^^^^^ use of undeclared type `GenericParam`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `token`\n  --> src\\main.rs:20:65\n   |\n20 | ...                   BinOp::Add(_) => BinOp::Sub(token::Sub { spans: [expr_binary.op.span()] }),\n   |                                                   ^^^^^ use of unresolved module or unlinked crate `token`\n   |\n   = help: if you wanted to use a crate named `token`, use `cargo add token` to add it to your `Cargo.toml`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `token`\n  --> src\\main.rs:21:65\n   |\n21 | ...                   BinOp::Sub(_) => BinOp::Add(token::Add { spans: [expr_binary.op.span()] }),\n   |                                                   ^^^^^ use of unresolved module or unlinked crate `token`\n   |\n   = help: if you wanted to use a crate named `token`, use `cargo add token` to add it to your `Cargo.toml`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `token`\n  --> src\\main.rs:22:65\n   |\n22 | ...                   BinOp::Mul(_) => BinOp::Div(token::Div { spans: [expr_binary.op.span()] }),\n   |                                                   ^^^^^ use of unresolved module or unlinked crate `token`\n   |\n   = help: if you wanted to use a crate named `token`, use `cargo add token` to add it to your `Cargo.toml`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `token`\n  --> src\\main.rs:23:65\n   |\n23 | ...                   BinOp::Div(_) => BinOp::Mul(token::Mul { spans: [expr_binary.op.span()] }),\n   |                                                   ^^^^^ use of unresolved module or unlinked crate `token`\n   |\n   = help: if you wanted to use a crate named `token`, use `cargo add token` to add it to your `Cargo.toml`\n\nSome errors have detailed explanations: E0405, E0412, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 19 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Const_Expression_Mutation_271_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0422]: cannot find struct, variant or union type `Sub` in module `token`\n   --> src\\main.rs:22:72\n    |\n22  |   ...                   BinOp::Add(_) => BinOp::Sub(token::Sub { spans: [expr_binary.op.span()] }),\n    |                                                            ^^^\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\token.rs:690:1\n    |\n690 | / define_keywords! {\n691 | |     \"abstract\"    pub struct Abstract\n692 | |     \"as\"          pub struct As\n693 | |     \"async\"       pub struct Async\n...   |\n743 | |     \"yield\"       pub struct Yield\n744 | | }\n    | |_- similarly named struct `Pub` defined here\n    |\nhelp: a struct with a similar name exists\n    |\n22  -                                     BinOp::Add(_) => BinOp::Sub(token::Sub { spans: [expr_binary.op.span()] }),\n22  +                                     BinOp::Add(_) => BinOp::Sub(token::Pub { spans: [expr_binary.op.span()] }),\n    |\nhelp: consider importing one of these variants\n    |\n1   + use crate::BinOp::Sub;\n    |\n1   + use syn::BinOp::Sub;\n    |\nhelp: if you import `Sub`, refer to it directly\n    |\n22  -                                     BinOp::Add(_) => BinOp::Sub(token::Sub { spans: [expr_binary.op.span()] }),\n22  +                                     BinOp::Add(_) => BinOp::Sub(Sub { spans: [expr_binary.op.span()] }),\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Add` in module `token`\n   --> src\\main.rs:23:72\n    |\n23  |   ...                   BinOp::Sub(_) => BinOp::Add(token::Add { spans: [expr_binary.op.span()] }),\n    |                                                            ^^^\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\token.rs:746:1\n    |\n746 | / define_punctuation! {\n747 | |     \"&\"           pub struct And/1        /// bitwise and logical AND, borrow, references, reference patterns\n748 | |     \"&&\"          pub struct AndAnd/2     /// lazy AND, borrow, references, reference patterns\n749 | |     \"&=\"          pub struct AndEq/2      /// bitwise AND assignment\n...   |\n792 | |     \"~\"           pub struct Tilde/1      /// unused since before Rust 1.0\n793 | | }\n    | |_- similarly named struct `And` defined here\n    |\nhelp: a struct with a similar name exists\n    |\n23  -                                     BinOp::Sub(_) => BinOp::Add(token::Add { spans: [expr_binary.op.span()] }),\n23  +                                     BinOp::Sub(_) => BinOp::Add(token::And { spans: [expr_binary.op.span()] }),\n    |\nhelp: consider importing one of these variants\n    |\n1   + use crate::BinOp::Add;\n    |\n1   + use syn::BinOp::Add;\n    |\nhelp: if you import `Add`, refer to it directly\n    |\n23  -                                     BinOp::Sub(_) => BinOp::Add(token::Add { spans: [expr_binary.op.span()] }),\n23  +                                     BinOp::Sub(_) => BinOp::Add(Add { spans: [expr_binary.op.span()] }),\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Div` in module `token`\n  --> src\\main.rs:24:72\n   |\n24 | ...                   BinOp::Mul(_) => BinOp::Div(token::Div { spans: [expr_binary.op.span()] }),\n   |                                                          ^^^ not found in `token`\n   |\nhelp: consider importing one of these variants\n   |\n1  + use crate::BinOp::Div;\n   |\n1  + use syn::BinOp::Div;\n   |\nhelp: if you import `Div`, refer to it directly\n   |\n24 -                                     BinOp::Mul(_) => BinOp::Div(token::Div { spans: [expr_binary.op.span()] }),\n24 +                                     BinOp::Mul(_) => BinOp::Div(Div { spans: [expr_binary.op.span()] }),\n   |\n\nerror[E0422]: cannot find struct, variant or union type `Mul` in module `token`\n   --> src\\main.rs:25:72\n    |\n25  |   ...                   BinOp::Div(_) => BinOp::Mul(token::Mul { spans: [expr_binary.op.span()] }),\n    |                                                            ^^^\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\token.rs:690:1\n    |\n690 | / define_keywords! {\n691 | |     \"abstract\"    pub struct Abstract\n692 | |     \"as\"          pub struct As\n693 | |     \"async\"       pub struct Async\n...   |\n743 | |     \"yield\"       pub struct Yield\n744 | | }\n    | |_- similarly named struct `Mut` defined here\n    |\nhelp: a struct with a similar name exists\n    |\n25  -                                     BinOp::Div(_) => BinOp::Mul(token::Mul { spans: [expr_binary.op.span()] }),\n25  +                                     BinOp::Div(_) => BinOp::Mul(token::Mut { spans: [expr_binary.op.span()] }),\n    |\nhelp: consider importing one of these variants\n    |\n1   + use crate::BinOp::Mul;\n    |\n1   + use syn::BinOp::Mul;\n    |\nhelp: if you import `Mul`, refer to it directly\n    |\n25  -                                     BinOp::Div(_) => BinOp::Mul(token::Mul { spans: [expr_binary.op.span()] }),\n25  +                                     BinOp::Div(_) => BinOp::Mul(Mul { spans: [expr_binary.op.span()] }),\n    |\n\nerror[E0599]: no method named `span` found for enum `BinOp` in the current scope\n   --> src\\main.rs:22:101\n    |\n22  | ...                   BinOp::Add(_) => BinOp::Sub(token::Sub { spans: [expr_binary.op.span()] }),\n    |                                                                                       ^^^^\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\spanned.rs:101:8\n    |\n101 |     fn span(&self) -> Span;\n    |        ---- the method is available for `BinOp` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Spanned` which provides `span` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use syn::spanned::Spanned;\n    |\nhelp: there is a method `__span` with a similar name\n    |\n22  |                                     BinOp::Add(_) => BinOp::Sub(token::Sub { spans: [expr_binary.op.__span()] }),\n    |                                                                                                     ++\n\nerror[E0599]: no method named `span` found for enum `BinOp` in the current scope\n   --> src\\main.rs:23:101\n    |\n23  | ...                   BinOp::Sub(_) => BinOp::Add(token::Add { spans: [expr_binary.op.span()] }),\n    |                                                                                       ^^^^\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\spanned.rs:101:8\n    |\n101 |     fn span(&self) -> Span;\n    |        ---- the method is available for `BinOp` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Spanned` which provides `span` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use syn::spanned::Spanned;\n    |\nhelp: there is a method `__span` with a similar name\n    |\n23  |                                     BinOp::Sub(_) => BinOp::Add(token::Add { spans: [expr_binary.op.__span()] }),\n    |                                                                                                     ++\n\nerror[E0599]: no method named `span` found for enum `BinOp` in the current scope\n   --> src\\main.rs:24:101\n    |\n24  | ...                   BinOp::Mul(_) => BinOp::Div(token::Div { spans: [expr_binary.op.span()] }),\n    |                                                                                       ^^^^\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\spanned.rs:101:8\n    |\n101 |     fn span(&self) -> Span;\n    |        ---- the method is available for `BinOp` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Spanned` which provides `span` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use syn::spanned::Spanned;\n    |\nhelp: there is a method `__span` with a similar name\n    |\n24  |                                     BinOp::Mul(_) => BinOp::Div(token::Div { spans: [expr_binary.op.__span()] }),\n    |                                                                                                     ++\n\nerror[E0599]: no method named `span` found for enum `BinOp` in the current scope\n   --> src\\main.rs:25:101\n    |\n25  | ...                   BinOp::Div(_) => BinOp::Mul(token::Mul { spans: [expr_binary.op.span()] }),\n    |                                                                                       ^^^^\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\spanned.rs:101:8\n    |\n101 |     fn span(&self) -> Span;\n    |        ---- the method is available for `BinOp` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Spanned` which provides `span` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use syn::spanned::Spanned;\n    |\nhelp: there is a method `__span` with a similar name\n    |\n25  |                                     BinOp::Div(_) => BinOp::Mul(token::Mul { spans: [expr_binary.op.__span()] }),\n    |                                                                                                     ++\n\nSome errors have detailed explanations: E0422, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 8 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Const_Expression_Mutation_271_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Const_Expression_Mutation_271 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nerror[E0405]: cannot find trait `VisitMut` in this scope\n  --> src\\main.rs:12:14\n   |\n12 |         impl VisitMut for ConstExprMutator {\n   |              ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this trait\n   |\n1  + use syn::visit_mut::VisitMut;\n   |\n\nerror[E0412]: cannot find type `Expr` in this scope\n  --> src\\main.rs:13:53\n   |\n13 |             fn visit_expr_mut(&mut self, expr: &mut Expr) {\n   |                                                     ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:14:24\n   |\n14 |                 if let Expr::Binary(expr_binary) = expr {\n   |                        ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:15:28\n   |\n15 |                     if let Expr::Path(expr_path) = &*expr_binary.left {\n   |                            ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `BinOp`\n  --> src\\main.rs:20:37\n   |\n20 | ...                   BinOp::Add(_) => BinOp::Sub(token::Sub { spans: [expr_binary.op.span()] }),\n   |                       ^^^^^ use of undeclared type `BinOp`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::BinOp;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `BinOp`\n  --> src\\main.rs:20:54\n   |\n20 | ...                   BinOp::Add(_) => BinOp::Sub(token::Sub { spans: [expr_binary.op.span()] }),\n   |                                        ^^^^^ use of undeclared type `BinOp`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::BinOp;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `BinOp`\n  --> src\\main.rs:21:37\n   |\n21 | ...                   BinOp::Sub(_) => BinOp::Add(token::Add { spans: [expr_binary.op.span()] }),\n   |                       ^^^^^ use of undeclared type `BinOp`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::BinOp;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `BinOp`\n  --> src\\main.rs:21:54\n   |\n21 | ...                   BinOp::Sub(_) => BinOp::Add(token::Add { spans: [expr_binary.op.span()] }),\n   |                                        ^^^^^ use of undeclared type `BinOp`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::BinOp;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `BinOp`\n  --> src\\main.rs:22:37\n   |\n22 | ...                   BinOp::Mul(_) => BinOp::Div(token::Div { spans: [expr_binary.op.span()] }),\n   |                       ^^^^^ use of undeclared type `BinOp`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::BinOp;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `BinOp`\n  --> src\\main.rs:22:54\n   |\n22 | ...                   BinOp::Mul(_) => BinOp::Div(token::Div { spans: [expr_binary.op.span()] }),\n   |                                        ^^^^^ use of undeclared type `BinOp`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::BinOp;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `BinOp`\n  --> src\\main.rs:23:37\n   |\n23 | ...                   BinOp::Div(_) => BinOp::Mul(token::Mul { spans: [expr_binary.op.span()] }),\n   |                       ^^^^^ use of undeclared type `BinOp`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::BinOp;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `BinOp`\n  --> src\\main.rs:23:54\n   |\n23 | ...                   BinOp::Div(_) => BinOp::Mul(token::Mul { spans: [expr_binary.op.span()] }),\n   |                                        ^^^^^ use of undeclared type `BinOp`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::BinOp;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:36:20\n   |\n36 |             if let Item::Fn(item_fn) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericParam`\n  --> src\\main.rs:38:28\n   |\n38 |                     if let GenericParam::Const(_) = param {\n   |                            ^^^^^^^^^^^^ use of undeclared type `GenericParam`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `token`\n  --> src\\main.rs:20:65\n   |\n20 | ...                   BinOp::Add(_) => BinOp::Sub(token::Sub { spans: [expr_binary.op.span()] }),\n   |                                                   ^^^^^ use of unresolved module or unlinked crate `token`\n   |\n   = help: if you wanted to use a crate named `token`, use `cargo add token` to add it to your `Cargo.toml`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `token`\n  --> src\\main.rs:21:65\n   |\n21 | ...                   BinOp::Sub(_) => BinOp::Add(token::Add { spans: [expr_binary.op.span()] }),\n   |                                                   ^^^^^ use of unresolved module or unlinked crate `token`\n   |\n   = help: if you wanted to use a crate named `token`, use `cargo add token` to add it to your `Cargo.toml`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `token`\n  --> src\\main.rs:22:65\n   |\n22 | ...                   BinOp::Mul(_) => BinOp::Div(token::Div { spans: [expr_binary.op.span()] }),\n   |                                                   ^^^^^ use of unresolved module or unlinked crate `token`\n   |\n   = help: if you wanted to use a crate named `token`, use `cargo add token` to add it to your `Cargo.toml`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `token`\n  --> src\\main.rs:23:65\n   |\n23 | ...                   BinOp::Div(_) => BinOp::Mul(token::Mul { spans: [expr_binary.op.span()] }),\n   |                                                   ^^^^^ use of unresolved module or unlinked crate `token`\n   |\n   = help: if you wanted to use a crate named `token`, use `cargo add token` to add it to your `Cargo.toml`\n\nSome errors have detailed explanations: E0405, E0412, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 19 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Const_Expression_Mutation_271_compling_err_7.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0422]: cannot find struct, variant or union type `Sub` in module `token`\n   --> src\\main.rs:22:72\n    |\n22  |   ...                   BinOp::Add(_) => BinOp::Sub(token::Sub { spans: [expr_binary.op.span()] }),\n    |                                                            ^^^\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\token.rs:690:1\n    |\n690 | / define_keywords! {\n691 | |     \"abstract\"    pub struct Abstract\n692 | |     \"as\"          pub struct As\n693 | |     \"async\"       pub struct Async\n...   |\n743 | |     \"yield\"       pub struct Yield\n744 | | }\n    | |_- similarly named struct `Pub` defined here\n    |\nhelp: a struct with a similar name exists\n    |\n22  -                                     BinOp::Add(_) => BinOp::Sub(token::Sub { spans: [expr_binary.op.span()] }),\n22  +                                     BinOp::Add(_) => BinOp::Sub(token::Pub { spans: [expr_binary.op.span()] }),\n    |\nhelp: consider importing one of these variants\n    |\n1   + use crate::BinOp::Sub;\n    |\n1   + use syn::BinOp::Sub;\n    |\nhelp: if you import `Sub`, refer to it directly\n    |\n22  -                                     BinOp::Add(_) => BinOp::Sub(token::Sub { spans: [expr_binary.op.span()] }),\n22  +                                     BinOp::Add(_) => BinOp::Sub(Sub { spans: [expr_binary.op.span()] }),\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Add` in module `token`\n   --> src\\main.rs:23:72\n    |\n23  |   ...                   BinOp::Sub(_) => BinOp::Add(token::Add { spans: [expr_binary.op.span()] }),\n    |                                                            ^^^\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\token.rs:746:1\n    |\n746 | / define_punctuation! {\n747 | |     \"&\"           pub struct And/1        /// bitwise and logical AND, borrow, references, reference patterns\n748 | |     \"&&\"          pub struct AndAnd/2     /// lazy AND, borrow, references, reference patterns\n749 | |     \"&=\"          pub struct AndEq/2      /// bitwise AND assignment\n...   |\n792 | |     \"~\"           pub struct Tilde/1      /// unused since before Rust 1.0\n793 | | }\n    | |_- similarly named struct `And` defined here\n    |\nhelp: a struct with a similar name exists\n    |\n23  -                                     BinOp::Sub(_) => BinOp::Add(token::Add { spans: [expr_binary.op.span()] }),\n23  +                                     BinOp::Sub(_) => BinOp::Add(token::And { spans: [expr_binary.op.span()] }),\n    |\nhelp: consider importing one of these variants\n    |\n1   + use crate::BinOp::Add;\n    |\n1   + use syn::BinOp::Add;\n    |\nhelp: if you import `Add`, refer to it directly\n    |\n23  -                                     BinOp::Sub(_) => BinOp::Add(token::Add { spans: [expr_binary.op.span()] }),\n23  +                                     BinOp::Sub(_) => BinOp::Add(Add { spans: [expr_binary.op.span()] }),\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Div` in module `token`\n  --> src\\main.rs:24:72\n   |\n24 | ...                   BinOp::Mul(_) => BinOp::Div(token::Div { spans: [expr_binary.op.span()] }),\n   |                                                          ^^^ not found in `token`\n   |\nhelp: consider importing one of these variants\n   |\n1  + use crate::BinOp::Div;\n   |\n1  + use syn::BinOp::Div;\n   |\nhelp: if you import `Div`, refer to it directly\n   |\n24 -                                     BinOp::Mul(_) => BinOp::Div(token::Div { spans: [expr_binary.op.span()] }),\n24 +                                     BinOp::Mul(_) => BinOp::Div(Div { spans: [expr_binary.op.span()] }),\n   |\n\nerror[E0422]: cannot find struct, variant or union type `Mul` in module `token`\n   --> src\\main.rs:25:72\n    |\n25  |   ...                   BinOp::Div(_) => BinOp::Mul(token::Mul { spans: [expr_binary.op.span()] }),\n    |                                                            ^^^\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\token.rs:690:1\n    |\n690 | / define_keywords! {\n691 | |     \"abstract\"    pub struct Abstract\n692 | |     \"as\"          pub struct As\n693 | |     \"async\"       pub struct Async\n...   |\n743 | |     \"yield\"       pub struct Yield\n744 | | }\n    | |_- similarly named struct `Mut` defined here\n    |\nhelp: a struct with a similar name exists\n    |\n25  -                                     BinOp::Div(_) => BinOp::Mul(token::Mul { spans: [expr_binary.op.span()] }),\n25  +                                     BinOp::Div(_) => BinOp::Mul(token::Mut { spans: [expr_binary.op.span()] }),\n    |\nhelp: consider importing one of these variants\n    |\n1   + use crate::BinOp::Mul;\n    |\n1   + use syn::BinOp::Mul;\n    |\nhelp: if you import `Mul`, refer to it directly\n    |\n25  -                                     BinOp::Div(_) => BinOp::Mul(token::Mul { spans: [expr_binary.op.span()] }),\n25  +                                     BinOp::Div(_) => BinOp::Mul(Mul { spans: [expr_binary.op.span()] }),\n    |\n\nFor more information about this error, try `rustc --explain E0422`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Const_Expression_Mutation_271_compling_err_8.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:22:65\n   |\n22 | ...                   BinOp::Add(_) => BinOp::Sub(expr_binary.op.span()),\n   |                                        ---------- ^^^^^^^^^^^^^^^^^^^^^ expected `Minus`, found `Span`\n   |                                        |\n   |                                        arguments to this enum variant are incorrect\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\op.rs:9:9\n   |\n9  |         Sub(Token![-]),\n   |         ^^^\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:23:65\n   |\n23 | ...                   BinOp::Sub(_) => BinOp::Add(expr_binary.op.span()),\n   |                                        ---------- ^^^^^^^^^^^^^^^^^^^^^ expected `Plus`, found `Span`\n   |                                        |\n   |                                        arguments to this enum variant are incorrect\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\op.rs:7:9\n   |\n7  |         Add(Token![+]),\n   |         ^^^\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:24:65\n   |\n24 | ...                   BinOp::Mul(_) => BinOp::Div(expr_binary.op.span()),\n   |                                        ---------- ^^^^^^^^^^^^^^^^^^^^^ expected `Slash`, found `Span`\n   |                                        |\n   |                                        arguments to this enum variant are incorrect\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\op.rs:13:9\n   |\n13 |         Div(Token![/]),\n   |         ^^^\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:25:65\n   |\n25 | ...                   BinOp::Div(_) => BinOp::Mul(expr_binary.op.span()),\n   |                                        ---------- ^^^^^^^^^^^^^^^^^^^^^ expected `Star`, found `Span`\n   |                                        |\n   |                                        arguments to this enum variant are incorrect\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\op.rs:11:9\n   |\n11 |         Mul(Token![*]),\n   |         ^^^\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\const_expression_mutation_271.rs"
    },
    {
        "mutator_name": "Dereference_Mutable_Raw_Pointer_349",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Dereference_Mutable_Raw_Pointer_349_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:38:37\n   |\n38 |                         if let Some((_, expr)) = &local.init {\n   |                                     ^^^^^^^^^    ----------- this expression has type `&Option<LocalInit>`\n   |                                     |\n   |                                     expected `LocalInit`, found `(_, _)`\n   |\n   = note: expected struct `LocalInit`\n               found tuple `(_, _)`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\dereference_mutable_raw_pointer_349.rs"
    },
    {
        "mutator_name": "Modify_Associated_Type_255",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Associated_Type_255_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.86s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:39:52:\nunexpected token\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Associated_Type_255_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:17:52\n   |\n17 | ...                   impl_type.ty = parse_quote!(&'static dyn AnotherType where AnotherType: AdditionalTrait);\n   |                                      ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:3:6\n  |\n3 | impl Mutator for Modify_Associated_Type_255 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n --> src\\main.rs:9:20\n  |\n9 |             if let Item::Impl(item_impl) = item {\n  |                    ^^^^ use of undeclared type `Item`\n  |\nhelp: consider importing this enum\n  |\n1 + use syn::Item;\n  |\n\nSome errors have detailed explanations: E0405, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Associated_Type_255_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.64s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:21:52:\nunexpected token\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Associated_Type_255_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.60s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:21:52:\nunexpected token\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_associated_type_255.rs"
    },
    {
        "mutator_name": "Modify_Function_Generics_And_Traits_407",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Function_Generics_And_Traits_407_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.91s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:37:67:\nexpected lifetime\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_function_generics_and_traits_407.rs"
    },
    {
        "mutator_name": "Modify_Gat_Lifetime_287",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Gat_Lifetime_287_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on shared package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0392]: lifetime parameter `'ast` is never used\n  --> src\\main.rs:30:27\n   |\n30 |         struct GatVisitor<'ast> {\n   |                           ^^^^ unused lifetime parameter\n   |\n   = help: consider removing `'ast`, referring to it in a field, or using a marker such as `PhantomData`\n\nFor more information about this error, try `rustc --explain E0392`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_gat_lifetime_287.rs"
    },
    {
        "mutator_name": "Modify_Poll_Enum_Usage_347",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Poll_Enum_Usage_347_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:34:39\n   |\n34 |                     if let Stmt::Expr(Expr::Match(expr_match)) = stmt {\n   |                                       ^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n34 |                     if let Stmt::Expr(Expr::Match(expr_match), _) = stmt {\n   |                                                              +++\n\nerror[E0609]: no field `pat` on type `&PatTupleStruct`\n  --> src\\main.rs:43:99\n   |\n43 | ...                   if let Pat::Tuple(pat_tuple) = &*pat_tuple_struct.pat {\n   |                                                                         ^^^ unknown field\n   |\nhelp: a field with a similar name exists\n   |\n43 |                                                 if let Pat::Tuple(pat_tuple) = &*pat_tuple_struct.path {\n   |                                                                                                      +\n\nerror[E0277]: the trait bound `PatTupleStruct: syn::parse_quote::ParseQuote` is not satisfied\n   --> src\\main.rs:60:101\n    |\n60  |   ...                   *pat_inner_struct = parse_quote! {\n    |  ___________________________________________^\n61  | | ...                       CustomType::Value(_)\n62  | | ...                   };\n    | |_______________________^ the trait `Parse` is not implemented for `PatTupleStruct`\n    |\n    = help: the following other types implement trait `Parse`:\n              Abstract\n              AndAnd\n              AndEq\n              AngleBracketedGenericArguments\n              Arm\n              As\n              At\n              Auto\n            and 248 others\n    = note: required for `PatTupleStruct` to implement `syn::parse_quote::ParseQuote`\nnote: required by a bound in `parse_quote`\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\parse_quote.rs:117:17\n    |\n117 | pub fn parse<T: ParseQuote>(token_stream: TokenStream) -> T {\n    |                 ^^^^^^^^^^ required by this bound in `parse`\n    = note: this error originates in the macro `parse_quote` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0023, E0277, E0609.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Poll_Enum_Usage_347_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:32:109\n   |\n32 | ...                   let custom_type: Item = parse_quote! {\n   |                                               ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:40:101\n   |\n40 | ...                   *pat_inner_struct = parse_quote! {\n   |                                           ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Fn(item_fn) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:14:28\n   |\n14 |                     if let Stmt::Expr(Expr::Match(expr_match), _) = stmt {\n   |                            ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:14:39\n   |\n14 |                     if let Stmt::Expr(Expr::Match(expr_match), _) = stmt {\n   |                                       ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:15:32\n   |\n15 |                         if let Expr::Path(ExprPath { path, .. }) = &*expr_match.expr {\n   |                                ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `ExprPath` in this scope\n  --> src\\main.rs:15:43\n   |\n15 |                         if let Expr::Path(ExprPath { path, .. }) = &*expr_match.expr {\n   |                                           ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::ExprPath;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Pat`\n  --> src\\main.rs:20:44\n   |\n20 | ...                   if let Pat::TupleStruct(pat_tuple_struct) = &arm.pat {\n   |                              ^^^ use of undeclared type `Pat`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Pat;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Pat`\n  --> src\\main.rs:23:61\n   |\n23 | ...                   if let Some(Pat::Tuple(pat_tuple)) = pat_tuple_struct.elems.first() {\n   |                                   ^^^ use of undeclared type `Pat`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Pat;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Pat`\n  --> src\\main.rs:24:65\n   |\n24 | ...                   if let Some(Pat::Path(pat_path)) = pat_tuple.elems.first() {\n   |                                   ^^^ use of undeclared type `Pat`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Pat;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Pat`\n  --> src\\main.rs:27:77\n   |\n27 | ...                   if let Some(Pat::Tuple(pat_inner_tuple)) = pat_tuple.elems.last() {\n   |                                   ^^^ use of undeclared type `Pat`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Pat;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Pat`\n  --> src\\main.rs:28:81\n   |\n28 | ...                   if let Some(Pat::TupleStruct(pat_inner_struct)) = pat_inner_tuple.elems.first() {\n   |                                   ^^^ use of undeclared type `Pat`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Pat;\n   |\n\nerror[E0412]: cannot find type `Item` in this scope\n  --> src\\main.rs:32:102\n   |\n32 | ...                   let custom_type: Item = parse_quote! {\n   |                                        ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nSome errors have detailed explanations: E0412, E0422, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 13 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Poll_Enum_Usage_347_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Modify_Poll_Enum_Usage_347 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Poll_Enum_Usage_347_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:15:39\n   |\n15 |                     if let Stmt::Expr(Expr::Match(expr_match)) = stmt {\n   |                                       ^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n15 |                     if let Stmt::Expr(Expr::Match(expr_match), _) = stmt {\n   |                                                              +++\n\nerror[E0277]: the trait bound `PatTupleStruct: syn::parse_quote::ParseQuote` is not satisfied\n   --> src\\main.rs:41:101\n    |\n41  |   ...                   *pat_inner_struct = parse_quote! {\n    |  ___________________________________________^\n42  | | ...                       CustomType::Value(_)\n43  | | ...                   };\n    | |_______________________^ the trait `Parse` is not implemented for `PatTupleStruct`\n    |\n    = help: the following other types implement trait `Parse`:\n              Abstract\n              AndAnd\n              AndEq\n              AngleBracketedGenericArguments\n              Arm\n              As\n              At\n              Auto\n            and 248 others\n    = note: required for `PatTupleStruct` to implement `syn::parse_quote::ParseQuote`\nnote: required by a bound in `parse_quote`\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\parse_quote.rs:117:17\n    |\n117 | pub fn parse<T: ParseQuote>(token_stream: TokenStream) -> T {\n    |                 ^^^^^^^^^^ required by this bound in `parse`\n    = note: this error originates in the macro `parse_quote` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0023, E0277.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Poll_Enum_Usage_347_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `Pat` cannot be dereferenced\n  --> src\\main.rs:41:81\n   |\n41 | ...                   *arm.pat = parse_quote! {\n   |                       ^^^^^^^^ can't be dereferenced\n   |\nhelp: parentheses are required to parse this as an expression\n   |\n32 ~                                                                                 (if !has_custom_type {\n33 |                                                                                     let custom_type: Item = parse_quote! {\n...\n39 |                                                                                     has_custom_type = true;\n40 ~                                                                                 })\n   |\n\nFor more information about this error, try `rustc --explain E0614`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Poll_Enum_Usage_347_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0499]: cannot borrow `file.items` as mutable more than once at a time\n  --> src\\main.rs:38:85\n   |\n11 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     first mutable borrow occurs here\n   |                     first borrow later used here\n...\n38 |                                                                                     file.items.push(custom_type);\n   |                                                                                     ^^^^^^^^^^ second mutable borrow occurs here\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Poll_Enum_Usage_347_compling_err_7.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0499]: cannot borrow `file.items` as mutable more than once at a time\n  --> src\\main.rs:39:85\n   |\n18 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     first mutable borrow occurs here\n   |                     first borrow later used here\n...\n39 |                                                                                     file.items.push(custom_type.clone());\n   |                                                                                     ^^^^^^^^^^ second mutable borrow occurs here\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_poll_enum_usage_347.rs"
    },
    {
        "mutator_name": "Modify_Struct_Fields_Const_Context_387",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Struct_Fields_Const_Context_387_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `parse_meta` found for reference `&syn::Attribute` in the current scope\n   --> src\\main.rs:55:32\n    |\n55  |         if let Ok(meta) = attr.parse_meta() {\n    |                                ^^^^^^^^^^\n    |\nhelp: there is a method `parse_nested_meta` with a similar name, but with different arguments\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\attr.rs:391:5\n    |\n391 | /     pub fn parse_nested_meta(\n392 | |         &self,\n393 | |         logic: impl FnMut(ParseNestedMeta) -> Result<()>,\n394 | |     ) -> Result<()> {\n    | |___________________^\n\nerror[E0609]: no field `nested` on type `MetaList`\n  --> src\\main.rs:58:34\n   |\n58 |                     && meta_list.nested.iter().any(|nested_meta| {\n   |                                  ^^^^^^ unknown field\n   |\n   = note: available fields are: `path`, `delimiter`, `tokens`\n\nerror[E0433]: failed to resolve: use of undeclared type `NestedMeta`\n  --> src\\main.rs:59:32\n   |\n59 |                         if let NestedMeta::Meta(Meta::Path(path)) = nested_meta {\n   |                                ^^^^^^^^^^ use of undeclared type `NestedMeta`\n\nSome errors have detailed explanations: E0433, E0599, E0609.\nFor more information about an error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Struct_Fields_Const_Context_387_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:57:17\n   |\n57 | /                 meta.parse_nested_meta(|nested_meta| {\n58 | |                     if nested_meta.path.is_ident(\"ConstParamTy\") {\n59 | |                         return Ok(());\n...  |\n62 | |                 }).is_ok()\n   | |__________________________^ expected `Result<(), Error>`, found `bool`\n   |\n   = note: expected enum `Result<(), syn::Error>`\n              found type `bool`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_struct_fields_const_context_387.rs"
    },
    {
        "mutator_name": "Alter_Const_Parameter_Width_383",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Alter_Const_Parameter_Width_383_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:34:59\n   |\n34 |                         if let Type::Array(type_array) = &*const_param.ty {\n   |                                                           ^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:51:41\n   |\n51 | ...                   *type_array.len = new_expr_lit;\n   |                       ^^^^^^^^^^^^^^^ can't be dereferenced\n\nFor more information about this error, try `rustc --explain E0614`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Const_Parameter_Width_383_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:51:58\n   |\n51 | ...                   type_array.len = Box::new(new_expr_lit);\n   |                       --------------   ^^^^^^^^^^^^^^^^^^^^^^ expected `Expr`, found `Box<Expr>`\n   |                       |\n   |                       expected due to the type of this binding\n   |\n   = note: expected enum `syn::Expr`\n            found struct `std::boxed::Box<syn::Expr>`\nhelp: consider unboxing the value\n   |\n51 |                                         type_array.len = *Box::new(new_expr_lit);\n   |                                                          +\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Const_Parameter_Width_383_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `into_inner` found for struct `std::boxed::Box<syn::Expr>` in the current scope\n  --> src\\main.rs:51:81\n   |\n51 | ...                   type_array.len = Box::new(new_expr_lit).into_inner();\n   |                                        -----------------------^^^^^^^^^^--\n   |                                        |                      |\n   |                                        |                      this is an associated function, not a method\n   |                                        help: use associated function syntax instead: `std::boxed::Box::<syn::Expr>::into_inner(Box::new(new_expr_lit))`\n   |\n   = note: found the following associated functions; to be used as methods, functions must have a `self` parameter\n   = note: the candidate is defined in an impl for the type `std::boxed::Box<T, A>`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Const_Parameter_Width_383_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0594]: cannot assign to `type_array.len`, which is behind a `&` reference\n  --> src\\main.rs:51:41\n   |\n51 | ...                   type_array.len = *Box::new(new_expr_lit);\n   |                       ^^^^^^^^^^^^^^ `type_array` is a `&` reference, so the data it refers to cannot be written\n\nFor more information about this error, try `rustc --explain E0594`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Const_Parameter_Width_383_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:51:58\n   |\n51 | ...                   type_array.len = Box::new(new_expr_lit);\n   |                       --------------   ^^^^^^^^^^^^^^^^^^^^^^ expected `Expr`, found `Box<Expr>`\n   |                       |\n   |                       expected due to the type of this binding\n   |\n   = note: expected enum `syn::Expr`\n            found struct `std::boxed::Box<syn::Expr>`\nhelp: consider unboxing the value\n   |\n51 |                                         type_array.len = *Box::new(new_expr_lit);\n   |                                                          +\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\alter_const_parameter_width_383.rs"
    },
    {
        "mutator_name": "Change_Impl_Trait_334",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Change_Impl_Trait_334_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:34:37\n   |\n34 |                         if let Some((_, expr)) = &mut local.init {\n   |                                     ^^^^^^^^^    --------------- this expression has type `&mut Option<LocalInit>`\n   |                                     |\n   |                                     expected `LocalInit`, found `(_, _)`\n   |\n   = note: expected struct `LocalInit`\n               found tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:41:50\n   |\n41 | ...                   pat: local.pat.clone(),\n   |                            ^^^^^^^^^^^^^^^^^ expected `Box<Pat>`, found `Pat`\n   |\n   = note: expected struct `std::boxed::Box<Pat>`\n                found enum `Pat`\n   = note: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\nhelp: store this in the heap by calling `Box::new`\n   |\n41 |                                             pat: Box::new(local.pat.clone()),\n   |                                                  +++++++++                 +\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:39:53\n   |\n39 |   ...                   local.pat = Box::new(Pat::Type(PatType {\n   |  _______________________---------___^\n   | |                       |\n   | |                       expected due to the type of this binding\n40 | | ...                       attrs: vec![],\n41 | | ...                       pat: local.pat.clone(),\n42 | | ...                       colon_token: Default::default(),\n43 | | ...                       ty: Box::new(new_type),\n44 | | ...                   }));\n   | |_________________________^ expected `Pat`, found `Box<Pat>`\n   |\n   = note: expected enum `Pat`\n            found struct `std::boxed::Box<Pat>`\nhelp: consider unboxing the value\n   |\n39 |                                         local.pat = *Box::new(Pat::Type(PatType {\n   |                                                     +\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Change_Impl_Trait_334_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Fn(item_fn) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:13:28\n   |\n13 |                     if let Stmt::Local(local) = stmt {\n   |                            ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Pat`\n  --> src\\main.rs:15:36\n   |\n15 | ...                   if let Pat::Type(PatType { ty, .. }) = &*local.pat {\n   |                              ^^^ use of undeclared type `Pat`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Pat;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `PatType` in this scope\n  --> src\\main.rs:15:46\n   |\n15 | ...                   if let Pat::Type(PatType { ty, .. }) = &*local.pat {\n   |                                        ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::PatType;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:16:40\n   |\n16 | ...                   if let Type::Reference(type_reference) = ty.as_ref() {\n   |                              ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:17:44\n   |\n17 | ...                   if let Type::ImplTrait(type_impl_trait) = type_reference.elem.as_ref() {\n   |                              ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:18:56\n   |\n18 | ...                   let new_type = Type::ImplTrait(type_impl_trait.clone());\n   |                                      ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Pat`\n  --> src\\main.rs:19:62\n   |\n19 | ...                   local.pat = Box::new(Pat::Type(PatType {\n   |                                            ^^^ use of undeclared type `Pat`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Pat;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `PatType` in this scope\n  --> src\\main.rs:19:72\n   |\n19 | ...                   local.pat = Box::new(Pat::Type(PatType {\n   |                                                      ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::PatType;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:25:48\n   |\n25 | ...                   if let Expr::Reference(expr_ref) = init.1.as_mut() {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 10 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Change_Impl_Trait_334_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Change_Impl_Trait_334 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Change_Impl_Trait_334_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Fn(item_fn) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:13:28\n   |\n13 |                     if let Stmt::Local(local) = stmt {\n   |                            ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Pat`\n  --> src\\main.rs:15:36\n   |\n15 | ...                   if let Pat::Type(PatType { ty, .. }) = &*local.pat {\n   |                              ^^^ use of undeclared type `Pat`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Pat;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `PatType` in this scope\n  --> src\\main.rs:15:46\n   |\n15 | ...                   if let Pat::Type(PatType { ty, .. }) = &*local.pat {\n   |                                        ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::PatType;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:16:40\n   |\n16 | ...                   if let Type::Reference(type_reference) = ty.as_ref() {\n   |                              ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:17:44\n   |\n17 | ...                   if let Type::ImplTrait(type_impl_trait) = type_reference.elem.as_ref() {\n   |                              ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:18:56\n   |\n18 | ...                   let new_type = Type::ImplTrait(type_impl_trait.clone());\n   |                                      ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Pat`\n  --> src\\main.rs:19:62\n   |\n19 | ...                   local.pat = Box::new(Pat::Type(PatType {\n   |                                            ^^^ use of undeclared type `Pat`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Pat;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `PatType` in this scope\n  --> src\\main.rs:19:72\n   |\n19 | ...                   local.pat = Box::new(Pat::Type(PatType {\n   |                                                      ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::PatType;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:25:48\n   |\n25 | ...                   if let Expr::Reference(expr_ref) = init.1.as_mut() {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 10 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Change_Impl_Trait_334_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `Pat` cannot be dereferenced\n  --> src\\main.rs:16:69\n   |\n16 | ...                   if let Pat::Type(PatType { ty, .. }) = &*local.pat {\n   |                                                               ^^^^^^^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:22:50\n   |\n22 | ...                   pat: local.pat.clone(),\n   |                            ^^^^^^^^^^^^^^^^^ expected `Box<Pat>`, found `Pat`\n   |\n   = note: expected struct `std::boxed::Box<Pat>`\n                found enum `Pat`\n   = note: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\nhelp: store this in the heap by calling `Box::new`\n   |\n22 |                                             pat: Box::new(local.pat.clone()),\n   |                                                  +++++++++                 +\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:20:53\n   |\n20 |   ...                   local.pat = Box::new(Pat::Type(PatType {\n   |  _______________________---------___^\n   | |                       |\n   | |                       expected due to the type of this binding\n21 | | ...                       attrs: vec![],\n22 | | ...                       pat: local.pat.clone(),\n23 | | ...                       colon_token: Default::default(),\n24 | | ...                       ty: Box::new(new_type),\n25 | | ...                   }));\n   | |_________________________^ expected `Pat`, found `Box<Pat>`\n   |\n   = note: expected enum `Pat`\n            found struct `std::boxed::Box<Pat>`\nhelp: consider unboxing the value\n   |\n20 |                                         local.pat = *Box::new(Pat::Type(PatType {\n   |                                                     +\n\nerror[E0609]: no field `1` on type `&mut LocalInit`\n  --> src\\main.rs:26:81\n   |\n26 | ...                   if let Expr::Reference(expr_ref) = init.1.as_mut() {\n   |                                                               ^ unknown field\n   |\n   = note: available fields are: `eq_token`, `expr`, `diverge`\n\nerror[E0609]: no field `1` on type `&mut LocalInit`\n  --> src\\main.rs:27:51\n   |\n27 | ...                   *init.1 = expr_ref.expr.clone();\n   |                             ^ unknown field\n   |\n   = note: available fields are: `eq_token`, `expr`, `diverge`\n\nSome errors have detailed explanations: E0308, E0609, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 5 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Change_Impl_Trait_334_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `Pat` cannot be dereferenced\n  --> src\\main.rs:16:69\n   |\n16 | ...                   if let Pat::Type(PatType { ty, .. }) = &*local.pat {\n   |                                                               ^^^^^^^^^^ can't be dereferenced\n\nerror[E0614]: type `Pat` cannot be dereferenced\n  --> src\\main.rs:22:59\n   |\n22 | ...                   pat: Box::new(*local.pat.clone()),\n   |                                     ^^^^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:20:53\n   |\n20 |   ...                   local.pat = Box::new(Pat::Type(PatType {\n   |  _______________________---------___^\n   | |                       |\n   | |                       expected due to the type of this binding\n21 | | ...                       attrs: vec![],\n22 | | ...                       pat: Box::new(*local.pat.clone()),\n23 | | ...                       colon_token: Default::default(),\n24 | | ...                       ty: Box::new(new_type),\n25 | | ...                   }));\n   | |_________________________^ expected `Pat`, found `Box<Pat>`\n   |\n   = note: expected enum `Pat`\n            found struct `std::boxed::Box<Pat>`\nhelp: consider unboxing the value\n   |\n20 |                                         local.pat = *Box::new(Pat::Type(PatType {\n   |                                                     +\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Change_Impl_Trait_334_compling_err_7.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:22:50\n   |\n22 | ...                   pat: local.pat.clone(),\n   |                            ^^^^^^^^^^^^^^^^^ expected `Box<Pat>`, found `Pat`\n   |\n   = note: expected struct `std::boxed::Box<Pat>`\n                found enum `Pat`\n   = note: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\nhelp: store this in the heap by calling `Box::new`\n   |\n22 |                                             pat: Box::new(local.pat.clone()),\n   |                                                  +++++++++                 +\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\change_impl_trait_334.rs"
    },
    {
        "mutator_name": "Modify_Adt_Const_Params_384",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Adt_Const_Params_384_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:35:66\n   |\n35 |                         if let syn::Type::Reference(type_ref) = &*const_item.ty {\n   |                                                                  ^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:40:57\n   |\n40 | ...                   const_item.ty = Box::new(parse_quote!(&'static str));\n   |                       -------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Type`, found `Box<_>`\n   |                       |\n   |                       expected due to the type of this binding\n   |\n   = note: expected enum `syn::Type`\n            found struct `std::boxed::Box<_>`\nhelp: consider unboxing the value\n   |\n40 |                                         const_item.ty = *Box::new(parse_quote!(&'static str));\n   |                                                         +\n\nerror[E0614]: type `Stmt` cannot be dereferenced\n  --> src\\main.rs:43:88\n   |\n43 | ...                   if let syn::Expr::Block(expr_block) = &mut *expr_unsafe.block.stmts[0].clone() {\n   |                                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:44:72\n   |\n44 | ...                   if let syn::Stmt::Expr(expr) = &expr_block.block.stmts[0] {\n   |                                              ^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n44 |                                                 if let syn::Stmt::Expr(expr, _) = &expr_block.block.stmts[0] {\n   |                                                                            +++\n\nSome errors have detailed explanations: E0023, E0308, E0614.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Adt_Const_Params_384_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:20:57\n   |\n20 | ...                   const_item.ty = parse_quote!(&'static str);\n   |                                       ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:28:83\n   |\n28 | ...                   const_item.expr = parse_quote!(s);\n   |                                         ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:12:20\n   |\n12 |             if let Item::Impl(item_impl) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:23:52\n   |\n23 | ...                   if let syn::Expr::Block(expr_block) = &mut expr_unsafe.block {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ---------------------- this expression has type `&mut syn::Block`\n   |                              |\n   |                              expected `Block`, found `Expr`\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Adt_Const_Params_384_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Modify_Adt_Const_Params_384 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Adt_Const_Params_384_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:20:57\n   |\n20 | ...                   const_item.ty = parse_quote!(&'static str);\n   |                                       ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:28:83\n   |\n28 | ...                   const_item.expr = parse_quote!(s);\n   |                                         ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:12:20\n   |\n12 |             if let Item::Impl(item_impl) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:22:86\n   |\n22 | ...                   if let syn::Expr::Unsafe(expr_unsafe) = &mut *const_item.expr {\n   |                                                                    ^^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0614]: type `syn::Block` cannot be dereferenced\n  --> src\\main.rs:23:88\n   |\n23 | ...                   if let syn::Expr::Block(expr_block) = &mut *expr_unsafe.block {\n   |                                                                  ^^^^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:24:72\n   |\n24 | ...                   if let syn::Stmt::Expr(expr) = &expr_block.block.stmts[0] {\n   |                                              ^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n24 |                                                 if let syn::Stmt::Expr(expr, _) = &expr_block.block.stmts[0] {\n   |                                                                            +++\n\nSome errors have detailed explanations: E0023, E0433, E0614.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 6 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Adt_Const_Params_384_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Modify_Adt_Const_Params_384 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Adt_Const_Params_384_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:24:52\n   |\n24 | ...                   if let syn::Expr::Block(expr_block) = &mut expr_unsafe.block {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ---------------------- this expression has type `&mut syn::Block`\n   |                              |\n   |                              expected `Block`, found `Expr`\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:25:72\n   |\n25 | ...                   if let syn::Stmt::Expr(expr) = &expr_block.block.stmts[0] {\n   |                                              ^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n25 |                                                 if let syn::Stmt::Expr(expr, _) = &expr_block.block.stmts[0] {\n   |                                                                            +++\n\nSome errors have detailed explanations: E0023, E0308.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Adt_Const_Params_384_compling_err_7.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Block` cannot be dereferenced\n  --> src\\main.rs:24:84\n   |\n24 | ...                   if let syn::Block { stmts, .. } = &mut *expr_unsafe.block {\n   |                                                              ^^^^^^^^^^^^^^^^^^ can't be dereferenced\n\nFor more information about this error, try `rustc --explain E0614`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Adt_Const_Params_384_compling_err_8.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:25:72\n   |\n25 | ...                   if let syn::Stmt::Expr(expr) = &stmts[0] {\n   |                                              ^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n25 |                                                 if let syn::Stmt::Expr(expr, _) = &stmts[0] {\n   |                                                                            +++\n\nFor more information about this error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_adt_const_params_384.rs"
    },
    {
        "mutator_name": "Modify_Function_Call_Generics_333",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Function_Call_Generics_333_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `path.segments` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:56:36\n   |\n56 |             if let Some(segment) = path.segments.last_mut() {\n   |                                    ^^^^^^^^^^^^^ `path` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Function_Call_Generics_333_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:70:64\n   |\n70 |             node.func = Box::new(Expr::Path(ExprPath { path, ..*node.func.clone() }));\n   |                                                                ^^^^^^^^^^^^^^^^^^ expected `ExprPath`, found `Expr`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Function_Call_Generics_333_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0063]: missing fields `attrs` and `qself` in initializer of `ExprPath`\n  --> src\\main.rs:70:45\n   |\n70 |             node.func = Box::new(Expr::Path(ExprPath { path }));\n   |                                             ^^^^^^^^ missing `attrs` and `qself`\n\nFor more information about this error, try `rustc --explain E0063`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Function_Call_Generics_333_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.01s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:63:51:\nunexpected token\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Function_Call_Generics_333_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0283]: type annotations needed\n  --> src\\main.rs:63:37\n   |\n63 | ...                   let new_generic = parse_quote! { #type_param.ident };\n   |                           ^^^^^^^^^^^\n64 | ...                   args.args.push(GenericArgument::Type(Type::Path(TypePath { qself: None, path: SynPath::from(new_generic) })));\n   |                                                                                                     ------- type must be known at this point\n   |\n   = note: multiple `impl`s satisfying `syn::Path: From<_>` found in the following crates: `core`, `syn`:\n           - impl<T> From<T> for T;\n           - impl<T> From<T> for syn::Path\n             where T: Into<PathSegment>;\nhelp: consider giving `new_generic` an explicit type\n   |\n63 |                                 let new_generic: /* Type */ = parse_quote! { #type_param.ident };\n   |                                                ++++++++++++\n\nFor more information about this error, try `rustc --explain E0283`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_function_call_generics_333.rs"
    },
    {
        "mutator_name": "Modify_Trait_Impl_With_Default_Constraint_371",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Impl_With_Default_Constraint_371_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0499]: cannot borrow `file.items` as mutable more than once at a time\n  --> src\\main.rs:39:29\n   |\n31 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     first mutable borrow occurs here\n   |                     first borrow later used here\n...\n39 |                             file.items.insert(0, new_trait);\n   |                             ^^^^^^^^^^ second mutable borrow occurs here\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_impl_with_default_constraint_371.rs"
    },
    {
        "mutator_name": "Modify_Trait_Lifetime_257",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Lifetime_257_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0609]: no field `bounds` on type `&mut ImplItemType`\n  --> src\\main.rs:46:65\n   |\n46 |                         if let Some(ref mut bounds) = type_item.bounds.first_mut() {\n   |                                                                 ^^^^^^ unknown field\n   |\n   = note: available fields are: `attrs`, `vis`, `defaultness`, `type_token`, `ident` ... and 4 others\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Lifetime_257_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0609]: no field `bounds` on type `Generics`\n  --> src\\main.rs:46:74\n   |\n46 |                         if let Some(ref mut bounds) = type_item.generics.bounds.first_mut() {\n   |                                                                          ^^^^^^ unknown field\n   |\n   = note: available fields are: `lt_token`, `params`, `gt_token`, `where_clause`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Lifetime_257_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:32\n   |\n31 |             if let Item::Trait(ref mut trait_item) = item {\n   |                                ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Trait(ref mut trait_item) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n31 -             if let Item::Trait(ref mut trait_item) = item {\n31 +             if let Item::Trait(trait_item) = item {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:33:49\n   |\n33 |                     if let syn::TraitItem::Type(ref mut type_item) = item {\n   |                                                 ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:33:28\n   |\n33 |                     if let syn::TraitItem::Type(ref mut type_item) = item {\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n33 -                     if let syn::TraitItem::Type(ref mut type_item) = item {\n33 +                     if let syn::TraitItem::Type(type_item) = item {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:35:61\n   |\n35 | ...                   if let TypeParamBound::Lifetime(ref mut lifetime) = bounds {\n   |                                                       ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:35:36\n   |\n35 | ...                   if let TypeParamBound::Lifetime(ref mut lifetime) = bounds {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n35 -                             if let TypeParamBound::Lifetime(ref mut lifetime) = bounds {\n35 +                             if let TypeParamBound::Lifetime(lifetime) = bounds {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:43:31\n   |\n43 |             if let Item::Impl(ref mut impl_item) = item {\n   |                               ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:43:20\n   |\n43 |             if let Item::Impl(ref mut impl_item) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n43 -             if let Item::Impl(ref mut impl_item) = item {\n43 +             if let Item::Impl(impl_item) = item {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:45:48\n   |\n45 |                     if let syn::ImplItem::Type(ref mut type_item) = item {\n   |                                                ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:45:28\n   |\n45 |                     if let syn::ImplItem::Type(ref mut type_item) = item {\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n45 -                     if let syn::ImplItem::Type(ref mut type_item) = item {\n45 +                     if let syn::ImplItem::Type(type_item) = item {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:47:59\n   |\n47 | ...                   if let GenericParam::Lifetime(ref mut lifetime_param) = bounds {\n   |                                                     ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:47:36\n   |\n47 | ...                   if let GenericParam::Lifetime(ref mut lifetime_param) = bounds {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n47 -                             if let GenericParam::Lifetime(ref mut lifetime_param) = bounds {\n47 +                             if let GenericParam::Lifetime(lifetime_param) = bounds {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 6 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Lifetime_257_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Trait(trait_item) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TypeParamBound`\n  --> src\\main.rs:15:36\n   |\n15 | ...                   if let TypeParamBound::Lifetime(lifetime) = bounds {\n   |                              ^^^^^^^^^^^^^^ use of undeclared type `TypeParamBound`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TypeParamBound;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:16:50\n   |\n16 | ...                   lifetime.ident = Ident::new(\"'b\", lifetime.ident.span());\n   |                                        ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:23:20\n   |\n23 |             if let Item::Impl(impl_item) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericParam`\n  --> src\\main.rs:27:36\n   |\n27 | ...                   if let GenericParam::Lifetime(lifetime_param) = bounds {\n   |                              ^^^^^^^^^^^^ use of undeclared type `GenericParam`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:28:65\n   |\n28 | ...                   lifetime_param.lifetime.ident = Ident::new(\"'c\", lifetime_param.lifetime.ident.span());\n   |                                                       ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nFor more information about this error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 6 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Lifetime_257_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:6:6\n  |\n6 | impl Mutator for Modify_Trait_Lifetime_257 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Lifetime_257_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.97s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:30:65:\n\"'c\" is not a valid Ident\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Lifetime_257_compling_err_7.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:18:50\n   |\n18 | ...                   lifetime.ident = syn::Lifetime::new(\"'b\", lifetime.ident.span());\n   |                       --------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Ident`, found `Lifetime`\n   |                       |\n   |                       expected due to the type of this binding\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Lifetime_257_compling_err_8.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.75s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:18:50:\n\"'b\" is not a valid Ident\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Lifetime_257_compling_err_9.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0432]: unresolved import `syn::LifetimeDef`\n --> src\\main.rs:2:57\n  |\n2 | use syn::{Item, TypeParamBound, GenericParam, Lifetime, LifetimeDef};\n  |                                                         ^^^^^^^^^^^\n  |                                                         |\n  |                                                         no `LifetimeDef` in the root\n  |                                                         help: a similar name exists in the module: `Lifetime`\n\nFor more information about this error, try `rustc --explain E0432`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_lifetime_257.rs"
    },
    {
        "mutator_name": "Modify_Trait_Method_Signature_With_Unusual_FFI_Type_447",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Method_Signature_With_Unusual_FFI_Type_447_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `syn::TraitItem` in the current scope\n  --> src\\main.rs:33:39\n   |\n33 |                     if let TraitItem::Method(ref mut method) = trait_item {\n   |                                       ^^^^^^ variant or associated item not found in `TraitItem`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Method_Signature_With_Unusual_FFI_Type_447_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0432]: unresolved import `syn::TraitItemMethod`\n --> src\\main.rs:9:49\n  |\n9 |     PathArguments, ReturnType, Stmt, TraitItem, TraitItemMethod, TraitBound, TraitBoundModifier, Type, TypeImplTrait,\n  |                                                 ^^^^^^^^^^^^^^^\n  |                                                 |\n  |                                                 no `TraitItemMethod` in the root\n  |                                                 help: a similar name exists in the module: `TraitItemMacro`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `TraitItem` in the current scope\n  --> src\\main.rs:33:39\n   |\n33 |                     if let TraitItem::Method(ref mut method) = trait_item {\n   |                                       ^^^^^^ variant or associated item not found in `TraitItem`\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Method_Signature_With_Unusual_FFI_Type_447_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:32\n   |\n31 |             if let Item::Trait(ref mut trait_item) = item {\n   |                                ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Trait(ref mut trait_item) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n31 -             if let Item::Trait(ref mut trait_item) = item {\n31 +             if let Item::Trait(trait_item) = item {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:33:42\n   |\n33 |                     if let TraitItem::Fn(ref mut method) = trait_item {\n   |                                          ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:33:28\n   |\n33 |                     if let TraitItem::Fn(ref mut method) = trait_item {\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n33 -                     if let TraitItem::Fn(ref mut method) = trait_item {\n33 +                     if let TraitItem::Fn(method) = trait_item {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_method_signature_with_unusual_ffi_type_447.rs"
    },
    {
        "mutator_name": "Modify_Transmutability_Trait_Bound_435",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_transmutability_trait_bound_435.rs"
    },
    {
        "mutator_name": "Modify_Tuple_Pattern_Assignment_361",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Tuple_Pattern_Assignment_361_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:33:43\n   |\n33 |                     if let syn::ImplItem::Method(method) = item {\n   |                                           ^^^^^^ variant or associated item not found in `ImplItem`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:36:45\n   |\n36 | ...                   if let Some((_, expr)) = &local.init {\n   |                                   ^^^^^^^^^    ----------- this expression has type `&Option<LocalInit>`\n   |                                   |\n   |                                   expected `LocalInit`, found `(_, _)`\n   |\n   = note: expected struct `LocalInit`\n               found tuple `(_, _)`\n\nerror[E0614]: type `Stmt` cannot be dereferenced\n  --> src\\main.rs:61:53\n   |\n61 | ...                   *stmt = parse_quote! {\n   |                       ^^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:61:61\n   |\n61 |   ...                   *stmt = parse_quote! {\n   |  _______________________________^\n62 | | ...                       let #tuple_pat = (#(#new_exprs),*);\n63 | | ...                   };\n   | |                       ^\n   | |                       |\n   | |                       expected `HasIterator`, found `ThereIsNoIteratorInRepetition`\n   | |_______________________expected due to this\n   |                         here the type of `has_iter` is inferred to be `ThereIsNoIteratorInRepetition`\n   |\n   = note: this error originates in the macro `$crate::quote_token_with_context` which comes from the expansion of the macro `parse_quote` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0308, E0599, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Tuple_Pattern_Assignment_361_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0609]: no field `1` on type `&LocalInit`\n  --> src\\main.rs:37:75\n   |\n37 | ...                   if let Expr::Tuple(tuple_expr) = init.1.as_ref() {\n   |                                                             ^ unknown field\n   |\n   = note: available fields are: `eq_token`, `expr`, `diverge`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:61:61\n   |\n61 |   ...                   *stmt = parse_quote! {\n   |  _______________________________^\n62 | | ...                       let #tuple_pat = (#(#new_exprs),*);\n63 | | ...                   };\n   | |                       ^\n   | |                       |\n   | |                       expected `HasIterator`, found `ThereIsNoIteratorInRepetition`\n   | |_______________________expected due to this\n   |                         here the type of `has_iter` is inferred to be `ThereIsNoIteratorInRepetition`\n   |\n   = note: this error originates in the macro `$crate::quote_token_with_context` which comes from the expansion of the macro `parse_quote` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0308, E0609.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Tuple_Pattern_Assignment_361_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:36:45\n   |\n36 | ...                   if let Some((_, init_expr)) = &local.init {\n   |                                   ^^^^^^^^^^^^^^    ----------- this expression has type `&Option<LocalInit>`\n   |                                   |\n   |                                   expected `LocalInit`, found `(_, _)`\n   |\n   = note: expected struct `LocalInit`\n               found tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:61:61\n   |\n61 |   ...                   *stmt = parse_quote! {\n   |  _______________________________^\n62 | | ...                       let #tuple_pat = (#(#new_exprs),*);\n63 | | ...                   };\n   | |                       ^\n   | |                       |\n   | |                       expected `HasIterator`, found `ThereIsNoIteratorInRepetition`\n   | |_______________________expected due to this\n   |                         here the type of `has_iter` is inferred to be `ThereIsNoIteratorInRepetition`\n   |\n   = note: this error originates in the macro `$crate::quote_token_with_context` which comes from the expansion of the macro `parse_quote` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Tuple_Pattern_Assignment_361_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:61:61\n   |\n61 |   ...                   *stmt = parse_quote! {\n   |  _______________________________^\n62 | | ...                       let #tuple_pat = (#(#new_exprs),*);\n63 | | ...                   };\n   | |                       ^\n   | |                       |\n   | |                       expected `HasIterator`, found `ThereIsNoIteratorInRepetition`\n   | |_______________________expected due to this\n   |                         here the type of `has_iter` is inferred to be `ThereIsNoIteratorInRepetition`\n   |\n   = note: this error originates in the macro `$crate::quote_token_with_context` which comes from the expansion of the macro `parse_quote` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Tuple_Pattern_Assignment_361_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0499]: cannot borrow `method.block.stmts` as mutable more than once at a time\n  --> src\\main.rs:52:69\n   |\n34 |                         for stmt in &mut method.block.stmts {\n   |                                     -----------------------\n   |                                     |\n   |                                     first mutable borrow occurs here\n   |                                     first borrow later used here\n...\n52 |                                                                     method.block.stmts.insert(0, new_var_stmt);\n   |                                                                     ^^^^^^^^^^^^^^^^^^ second mutable borrow occurs here\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_tuple_pattern_assignment_361.rs"
    },
    {
        "mutator_name": "Modify_Type_Alias_With_Impl_Trait_308",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Type_Alias_With_Impl_Trait_308_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:54:29\n   |\n54 |                 if let Some((_, expr)) = &mut i.init {\n   |                             ^^^^^^^^^    ----------- this expression has type `&mut Option<LocalInit>`\n   |                             |\n   |                             expected `LocalInit`, found `(_, _)`\n   |\n   = note: expected struct `LocalInit`\n               found tuple `(_, _)`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_type_alias_with_impl_trait_308.rs"
    },
    {
        "mutator_name": "Modify_Type_Constraints_378",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_type_constraints_378.rs"
    },
    {
        "mutator_name": "Modify_Type_Constraints_418",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_type_constraints_418.rs"
    },
    {
        "mutator_name": "Modify_Type_Constraints_And_Array_Init_332",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_type_constraints_and_array_init_332.rs"
    },
    {
        "mutator_name": "Modify_Type_Projections_426",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Type_Projections_426_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.44s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' has overflowed its stack\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 0xc00000fd, STATUS_STACK_OVERFLOW)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Type_Projections_426_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:15:46\n   |\n15 |                         let new_type: Type = parse_quote! {\n   |                                              ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:3:6\n  |\n3 | impl Mutator for Modify_Type_Projections_426 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nerror[E0405]: cannot find trait `VisitMut` in this scope\n  --> src\\main.rs:11:14\n   |\n11 |         impl VisitMut for TypeProjectionVisitor {\n   |              ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this trait\n   |\n1  + use syn::visit_mut::VisitMut;\n   |\n\nerror[E0412]: cannot find type `TypePath` in this scope\n  --> src\\main.rs:12:63\n   |\n12 |             fn visit_type_path_mut(&mut self, type_path: &mut TypePath) {\n   |                                                               ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypePath;\n   |\n\nerror[E0412]: cannot find type `Type` in this scope\n  --> src\\main.rs:15:39\n   |\n15 |                         let new_type: Type = parse_quote! {\n   |                                       ^^^^ not found in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:19:29\n   |\n19 | ...                   Type::Path(type_path) => type_path,\n   |                       ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nSome errors have detailed explanations: E0405, E0412, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 6 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Type_Projections_426_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `mutate` found for struct `Modify_Type_Projections_426` in the current scope\n  --> src\\main.rs:62:41\n   |\n5  | pub struct Modify_Type_Projections_426;\n   | -------------------------------------- method `mutate` not found for this struct\n...\n62 |             Modify_Type_Projections_426.mutate(&mut file_ast);\n   |                                         ^^^^^^ method not found in `Modify_Type_Projections_426`\n   |\n  ::: src\\mutator.rs:15:8\n   |\n15 |     fn mutate(&self, file: &mut syn::File);\n   |        ------ the method is available for `Modify_Type_Projections_426` here\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: trait `Mutator` which provides `mutate` is implemented but not in scope; perhaps you want to import it\n   |\n1  + use crate::mutator::Mutator;\n   |\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_type_projections_426.rs"
    },
    {
        "mutator_name": "Modify_Union_Field_Types_329",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_union_field_types_329.rs"
    },
    {
        "mutator_name": "Modify_Where_Clause_440",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_where_clause_440.rs"
    },
    {
        "mutator_name": "Mutate_Pattern_Matching_References_369",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\mutate_pattern_matching_references_369.rs"
    },
    {
        "mutator_name": "Mutator_Array_Index_Out_Of_Bounds_340",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\mutator_array_index_out_of_bounds_340.rs"
    },
    {
        "mutator_name": "Mutator_Async_Yield_281",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Mutator_Async_Yield_281_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:44:43\n   |\n44 |                         if let Stmt::Expr(expr) = stmt {\n   |                                           ^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n44 |                         if let Stmt::Expr(expr, _) = stmt {\n   |                                               +++\n\nerror[E0061]: this enum variant takes 2 arguments but 1 argument was supplied\n  --> src\\main.rs:47:41\n   |\n47 | ...                   *stmt = Stmt::Expr(expr_yield);\n   |                               ^^^^^^^^^^------------ argument #2 of type `Option<Semi>` is missing\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:9\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |         ^^^^\nhelp: provide the argument\n   |\n47 |                                 *stmt = Stmt::Expr(expr_yield, /* Option<Semi> */);\n   |                                                              ++++++++++++++++++++\n\nSome errors have detailed explanations: E0023, E0061.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mutator_Async_Yield_281_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:17:61\n   |\n17 | ...                   let new_bound: TypeParamBound = parse_quote!(Future<Output = &'a T>);\n   |                                                       ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:26:56\n   |\n26 | ...                   let expr_yield: Expr = parse_quote!(yield #expr_await.base);\n   |                                              ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Fn(item_fn) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `ReturnType`\n  --> src\\main.rs:14:28\n   |\n14 |                     if let ReturnType::Type(_, ty) = &mut item_fn.sig.output {\n   |                            ^^^^^^^^^^ use of undeclared type `ReturnType`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::ReturnType;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:15:32\n   |\n15 |                         if let Type::ImplTrait(type_impl_trait) = &mut **ty {\n   |                                ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Lifetime`\n  --> src\\main.rs:16:44\n   |\n16 | ...                   let lifetime = Lifetime::new(\"'a\", Span::call_site());\n   |                                      ^^^^^^^^ use of undeclared type `Lifetime`\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::Lifetime;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:16:64\n   |\n16 | ...                   let lifetime = Lifetime::new(\"'a\", Span::call_site());\n   |                                                          ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0412]: cannot find type `TypeParamBound` in this scope\n  --> src\\main.rs:17:44\n   |\n17 | ...                   let new_bound: TypeParamBound = parse_quote!(Future<Output = &'a T>);\n   |                                      ^^^^^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TypeParamBound;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:24:32\n   |\n24 |                         if let Stmt::Expr(expr, _) = stmt {\n   |                                ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:25:36\n   |\n25 | ...                   if let Expr::Await(expr_await) = expr {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0412]: cannot find type `Expr` in this scope\n  --> src\\main.rs:26:49\n   |\n26 | ...                   let expr_yield: Expr = parse_quote!(yield #expr_await.base);\n   |                                       ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:27:41\n   |\n27 | ...                   *stmt = Stmt::Expr(expr_yield, None);\n   |                               ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 12 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mutator_Async_Yield_281_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:6:6\n  |\n6 | impl Mutator for Mutator_Async_Yield_281 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mutator_Async_Yield_281_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:26:43\n   |\n26 |                         if let Stmt::Expr(expr) = stmt {\n   |                                           ^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n26 |                         if let Stmt::Expr(expr, _) = stmt {\n   |                                               +++\n\nerror[E0061]: this enum variant takes 2 arguments but 1 argument was supplied\n  --> src\\main.rs:29:41\n   |\n29 | ...                   *stmt = Stmt::Expr(expr_yield);\n   |                               ^^^^^^^^^^------------ argument #2 of type `Option<Semi>` is missing\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:9\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |         ^^^^\nhelp: provide the argument\n   |\n29 |                                 *stmt = Stmt::Expr(expr_yield, /* Option<Semi> */);\n   |                                                              ++++++++++++++++++++\n\nSome errors have detailed explanations: E0023, E0061.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\mutator_async_yield_281.rs"
    },
    {
        "mutator_name": "Mutator_Change_Associated_Type_249",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\mutator_change_associated_type_249.rs"
    },
    {
        "mutator_name": "Mutator_Closure_Return_Type_Change_338",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Mutator_Closure_Return_Type_Change_338_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:34:37\n   |\n34 |                         if let Some((_, expr)) = &mut local.init {\n   |                                     ^^^^^^^^^    --------------- this expression has type `&mut Option<LocalInit>`\n   |                                     |\n   |                                     expected `LocalInit`, found `(_, _)`\n   |\n   = note: expected struct `LocalInit`\n               found tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:36:40\n   |\n36 | ...                   if let Some(output_type) = &closure.output {\n   |                              ^^^^^^^^^^^^^^^^^   --------------- this expression has type `&ReturnType`\n   |                              |\n   |                              expected `ReturnType`, found `Option<_>`\n   |\n   = note: expected enum `ReturnType`\n              found enum `Option<_>`\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:50:71\n   |\n50 | ...                   if let Stmt::Expr(expr) = stmt {\n   |                                         ^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n50 |                                                     if let Stmt::Expr(expr, _) = stmt {\n   |                                                                           +++\n\nSome errors have detailed explanations: E0023, E0308.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mutator_Closure_Return_Type_Change_338_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:25:47\n   |\n25 | ...                   *ty = parse_quote!(#new_type_ident);\n   |                             ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:33:69\n   |\n33 | ...                   *expr = parse_quote!(#value as #new_type_ident);\n   |                               ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Fn(item_fn) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:13:28\n   |\n13 |                     if let Stmt::Local(local) = stmt {\n   |                            ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:15:36\n   |\n15 | ...                   if let Expr::Closure(closure) = init.1.as_mut() {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `ReturnType`\n  --> src\\main.rs:16:40\n   |\n16 | ...                   if let ReturnType::Type(_, ty) = &closure.output {\n   |                              ^^^^^^^^^^ use of undeclared type `ReturnType`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::ReturnType;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:17:44\n   |\n17 | ...                   if let Type::Path(type_path) = ty.as_ref() {\n   |                              ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:24:62\n   |\n24 | ...                   let new_type_ident = Ident::new(new_type, Span::call_site());\n   |                                            ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:24:83\n   |\n24 | ...                   let new_type_ident = Ident::new(new_type, Span::call_site());\n   |                                                                 ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:27:48\n   |\n27 | ...                   if let Expr::Block(block) = &mut *closure.body {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:29:56\n   |\n29 | ...                   if let Stmt::Expr(expr, _) = stmt {\n   |                              ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:30:60\n   |\n30 | ...                   if let Expr::Lit(expr_lit) = expr {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nFor more information about this error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 12 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mutator_Closure_Return_Type_Change_338_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:6:6\n  |\n6 | impl Mutator for Mutator_Closure_Return_Type_Change_338 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mutator_Closure_Return_Type_Change_338_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0609]: no field `1` on type `&mut LocalInit`\n  --> src\\main.rs:17:66\n   |\n17 | ...                   if let Expr::Closure(closure) = init.1.as_mut() {\n   |                                                            ^ unknown field\n   |\n   = note: available fields are: `eq_token`, `expr`, `diverge`\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:31:67\n   |\n31 | ...                   if let Stmt::Expr(expr) = stmt {\n   |                                         ^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n31 |                                                 if let Stmt::Expr(expr, _) = stmt {\n   |                                                                       +++\n\nSome errors have detailed explanations: E0023, E0609.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mutator_Closure_Return_Type_Change_338_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0594]: cannot assign to `*ty`, which is behind a `&` reference\n  --> src\\main.rs:27:41\n   |\n27 | ...                   *ty = parse_quote!(#new_type_ident);\n   |                       ^^^ `ty` is a `&` reference, so the data it refers to cannot be written\n\nFor more information about this error, try `rustc --explain E0594`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mutator_Closure_Return_Type_Change_338_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:31:67\n   |\n31 | ...                   if let Stmt::Expr(expr) = stmt {\n   |                                         ^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n31 |                                                 if let Stmt::Expr(expr, _) = stmt {\n   |                                                                       +++\n\nFor more information about this error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\mutator_closure_return_type_change_338.rs"
    },
    {
        "mutator_name": "Mutator_Complex_Const_Generic_411",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Mutator_Complex_Const_Generic_411_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:29\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                             ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n31 -             if let Item::Fn(ref mut func) = item {\n31 +             if let Item::Fn(func) = item {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\mutator_complex_const_generic_411.rs"
    },
    {
        "mutator_name": "Mutator_Function_Return_Impl_Trait_406",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Mutator_Function_Return_Impl_Trait_406_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:48:29\n   |\n48 |             if let Item::Fn(ref mut func) = item {\n   |                             ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:48:20\n   |\n48 |             if let Item::Fn(ref mut func) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n48 -             if let Item::Fn(ref mut func) = item {\n48 +             if let Item::Fn(func) = item {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mutator_Function_Return_Impl_Trait_406_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:21:35\n   |\n21 |             let new_trait: Item = parse_quote! {\n   |                                   ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:31:57\n   |\n31 |                         let new_bound: TypeParamBound = parse_quote! {\n   |                                                         ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:12:20\n   |\n12 |             if let Item::Trait(trait_item) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0412]: cannot find type `Item` in this scope\n  --> src\\main.rs:21:28\n   |\n21 |             let new_trait: Item = parse_quote! {\n   |                            ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:28:20\n   |\n28 |             if let Item::Fn(func) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `ReturnType`\n  --> src\\main.rs:29:24\n   |\n29 |                 if let ReturnType::Type(_, ref mut ty) = func.sig.output {\n   |                        ^^^^^^^^^^ use of undeclared type `ReturnType`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::ReturnType;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:30:28\n   |\n30 |                     if let Type::ImplTrait(ref mut impl_trait) = **ty {\n   |                            ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0412]: cannot find type `TypeParamBound` in this scope\n  --> src\\main.rs:31:40\n   |\n31 |                         let new_bound: TypeParamBound = parse_quote! {\n   |                                        ^^^^^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TypeParamBound;\n   |\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 8 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mutator_Function_Return_Impl_Trait_406_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Mutator_Function_Return_Impl_Trait_406 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\mutator_function_return_impl_trait_406.rs"
    },
    {
        "mutator_name": "Mutator_Function_Trait_Bounds_391",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Mutator_Function_Trait_Bounds_391_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:64:43\n   |\n64 |                         if let Stmt::Expr(Expr::Cast(ref mut expr_cast)) = stmt {\n   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n64 |                         if let Stmt::Expr(Expr::Cast(ref mut expr_cast), _) = stmt {\n   |                                                                        +++\n\nerror[E0061]: this enum variant takes 2 arguments but 1 argument was supplied\n  --> src\\main.rs:71:37\n   |\n71 | ...                   *stmt = Stmt::Expr(new_cast);\n   |                               ^^^^^^^^^^---------- argument #2 of type `Option<Semi>` is missing\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:9\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |         ^^^^\nhelp: provide the argument\n   |\n71 |                             *stmt = Stmt::Expr(new_cast, /* Option<Semi> */);\n   |                                                        ++++++++++++++++++++\n\nSome errors have detailed explanations: E0023, E0061.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mutator_Function_Trait_Bounds_391_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:32:29\n   |\n32 |             if let Item::Fn(ref mut func) = item {\n   |                             ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:32:20\n   |\n32 |             if let Item::Fn(ref mut func) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n32 -             if let Item::Fn(ref mut func) = item {\n32 +             if let Item::Fn(func) = item {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:38:41\n   |\n38 |                     if let FnArg::Typed(ref mut pat_type) = input {\n   |                                         ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:38:28\n   |\n38 |                     if let FnArg::Typed(ref mut pat_type) = input {\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n38 -                     if let FnArg::Typed(ref mut pat_type) = input {\n38 +                     if let FnArg::Typed(pat_type) = input {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:64:54\n   |\n64 |                         if let Stmt::Expr(Expr::Cast(ref mut expr_cast), _) = stmt {\n   |                                                      ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:64:32\n   |\n64 |                         if let Stmt::Expr(Expr::Cast(ref mut expr_cast), _) = stmt {\n   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n64 -                         if let Stmt::Expr(Expr::Cast(ref mut expr_cast), _) = stmt {\n64 +                         if let Stmt::Expr(Expr::Cast(expr_cast), _) = stmt {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\mutator_function_trait_bounds_391.rs"
    },
    {
        "mutator_name": "Mutator_Function_Type_Bounds_443",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [],
        "label": "Negative",
        "file": ".\\mutators\\mutator_function_type_bounds_443.rs"
    },
    {
        "mutator_name": "Mutator_Function_With_Trait_Bound_397",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Mutator_Function_With_Trait_Bound_397_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:40:52\n   |\n40 | ...                   if let TypeParamBound::Trait(TraitBound { ref path, modifier, .. }) = constraint {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ---------- this expression has type `&syn::Constraint`\n   |                              |\n   |                              expected `Constraint`, found `TypeParamBound`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mutator_Function_With_Trait_Bound_397_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:29\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                             ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Fn(ref mut func) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n31 -             if let Item::Fn(ref mut func) = item {\n31 +             if let Item::Fn(func) = item {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:39:88\n   |\n39 | ...                   if let GenericArgument::Type(Type::TraitObject(ref trait_object)) = arg {\n   |                                                                      ^^^ binding modifier not allowed under `ref` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:39:48\n   |\n39 | ...                   if let GenericArgument::Type(Type::TraitObject(ref trait_object)) = arg {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&_`\nhelp: remove the unnecessary binding modifier\n   |\n39 -                                         if let GenericArgument::Type(Type::TraitObject(ref trait_object)) = arg {\n39 +                                         if let GenericArgument::Type(Type::TraitObject(trait_object)) = arg {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:41:91\n   |\n41 | ...                   if let TypeParamBound::Trait(TraitBound { ref path, modifier, .. }) = bound {\n   |                                                                 ^^^ binding modifier not allowed under `ref` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:41:56\n   |\n41 | ...                   if let TypeParamBound::Trait(TraitBound { ref path, modifier, .. }) = bound {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&_`\nhelp: remove the unnecessary binding modifier\n   |\n41 -                                                 if let TypeParamBound::Trait(TraitBound { ref path, modifier, .. }) = bound {\n41 +                                                 if let TypeParamBound::Trait(TraitBound { path, modifier, .. }) = bound {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\mutator_function_with_trait_bound_397.rs"
    },
    {
        "mutator_name": "Mutator_Lambda_Yield_280",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Mutator_Lambda_Yield_280_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:38:86\n   |\n38 |                     if block.block.stmts.iter().any(|stmt| matches!(stmt, Stmt::Expr(Expr::Yield(_)))) {\n   |                                                                                      ^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n38 |                     if block.block.stmts.iter().any(|stmt| matches!(stmt, Stmt::Expr(Expr::Yield(_), _))) {\n   |                                                                                                    +++\n\nerror[E0061]: this enum variant takes 2 arguments but 1 argument was supplied\n  --> src\\main.rs:39:50\n   |\n39 |                         block.block.stmts = vec![Stmt::Expr(return_expr)];\n   |                                                  ^^^^^^^^^^------------- argument #2 of type `Option<Semi>` is missing\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:9\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |         ^^^^\nhelp: provide the argument\n   |\n39 |                         block.block.stmts = vec![Stmt::Expr(return_expr, /* Option<Semi> */)];\n   |                                                                        ++++++++++++++++++++\n\nerror[E0061]: this enum variant takes 2 arguments but 1 argument was supplied\n  --> src\\main.rs:41:50\n   |\n41 |                         block.block.stmts = vec![Stmt::Expr(yield_expr)];\n   |                                                  ^^^^^^^^^^------------ argument #2 of type `Option<Semi>` is missing\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:9\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |         ^^^^\nhelp: provide the argument\n   |\n41 |                         block.block.stmts = vec![Stmt::Expr(yield_expr, /* Option<Semi> */)];\n   |                                                                       ++++++++++++++++++++\n\nSome errors have detailed explanations: E0023, E0061.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\mutator_lambda_yield_280.rs"
    },
    {
        "mutator_name": "Mutator_Lifetime_In_GATs_289",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\mutator_lifetime_in_gats_289.rs"
    },
    {
        "mutator_name": "Mutator_Macro_Invocation_Alteration_353",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Mutator_Macro_Invocation_Alteration_353_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:33:28\n   |\n33 |                     if let Some((_, MacroDelimiter::Brace(ref mut tokens))) = item_macro.mac.delimiter {\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ------------------------ this expression has type `syn::MacroDelimiter`\n   |                            |\n   |                            expected `MacroDelimiter`, found `Option<_>`\n   |\n   = note: expected enum `syn::MacroDelimiter`\n              found enum `Option<_>`\n\nerror[E0599]: `syn::token::Brace` is not an iterator\n   --> src\\main.rs:35:53\n    |\n35  |                           for token in tokens.clone().into_iter() {\n    |                                                       ^^^^^^^^^ `syn::token::Brace` is not an iterator\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\token.rs:795:1\n    |\n795 | / define_delimiters! {\n796 | |     Brace         pub struct Brace        /// `{`&hellip;`}`\n797 | |     Bracket       pub struct Bracket      /// `[`&hellip;`]`\n798 | |     Parenthesis   pub struct Paren        /// `(`&hellip;`)`\n799 | | }\n    | |_- doesn't satisfy `syn::token::Brace: IntoIterator` or `syn::token::Brace: Iterator`\n    |\n    = note: the following trait bounds were not satisfied:\n            `syn::token::Brace: Iterator`\n            which is required by `syn::token::Brace: IntoIterator`\n            `&syn::token::Brace: Iterator`\n            which is required by `&syn::token::Brace: IntoIterator`\n            `&mut syn::token::Brace: Iterator`\n            which is required by `&mut syn::token::Brace: IntoIterator`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:49:35\n   |\n49 |                         *tokens = new_tokens;\n   |                         -------   ^^^^^^^^^^ expected `Brace`, found `TokenStream`\n   |                         |\n   |                         expected due to the type of this binding\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mutator_Macro_Invocation_Alteration_353_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: `syn::token::Brace` is not an iterator\n   --> src\\main.rs:35:53\n    |\n35  |                           for token in tokens.clone().into_iter() {\n    |                                                       ^^^^^^^^^ `syn::token::Brace` is not an iterator\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\token.rs:795:1\n    |\n795 | / define_delimiters! {\n796 | |     Brace         pub struct Brace        /// `{`&hellip;`}`\n797 | |     Bracket       pub struct Bracket      /// `[`&hellip;`]`\n798 | |     Parenthesis   pub struct Paren        /// `(`&hellip;`)`\n799 | | }\n    | |_- doesn't satisfy `syn::token::Brace: IntoIterator` or `syn::token::Brace: Iterator`\n    |\n    = note: the following trait bounds were not satisfied:\n            `syn::token::Brace: Iterator`\n            which is required by `syn::token::Brace: IntoIterator`\n            `&syn::token::Brace: Iterator`\n            which is required by `&syn::token::Brace: IntoIterator`\n            `&mut syn::token::Brace: Iterator`\n            which is required by `&mut syn::token::Brace: IntoIterator`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:49:35\n   |\n49 |                         *tokens = Group::new(Delimiter::Brace, new_tokens).stream();\n   |                         -------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Brace`, found `TokenStream`\n   |                         |\n   |                         expected due to the type of this binding\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mutator_Macro_Invocation_Alteration_353_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0252]: the name `Ident` is defined multiple times\n --> src\\main.rs:7:91\n  |\n1 | use proc_macro2::{Delimiter, Group, Ident, Span, TokenStream, TokenTree};\n  |                                     ----- previous import of the type `Ident` here\n...\n7 |     BoundLifetimes, Expr, ExprCall, ExprPath, File, FnArg, GenericArgument, GenericParam, Ident,\n  |                                                                                           ^^^^^-\n  |                                                                                           |\n  |                                                                                           `Ident` reimported here\n  |                                                                                           help: remove unnecessary import\n  |\n  = note: `Ident` must be defined only once in the type namespace of this module\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:32\n   |\n31 |             if let Item::Macro(ref mut item_macro) = item {\n   |                                ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Macro(ref mut item_macro) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n31 -             if let Item::Macro(ref mut item_macro) = item {\n31 +             if let Item::Macro(item_macro) = item {\n   |\n\nFor more information about this error, try `rustc --explain E0252`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\mutator_macro_invocation_alteration_353.rs"
    },
    {
        "mutator_name": "Mutator_Malformed_Type_Specification_354",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Mutator_Malformed_Type_Specification_354_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.99s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:48:33:\n\"(x: !)\" is not a valid Ident\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\mutator_malformed_type_specification_354.rs"
    },
    {
        "mutator_name": "Mutator_Modify_Trait_Lifetime_263",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\mutator_modify_trait_lifetime_263.rs"
    },
    {
        "mutator_name": "Mutator_Nested_Result_Type_259",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Mutator_Nested_Result_Type_259_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0658]: box pattern syntax is experimental\n  --> src\\main.rs:32:44\n   |\n32 |                 if let ReturnType::Type(_, box Type::Path(type_path)) = &item_fn.sig.output {\n   |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: see issue #29641 <https://github.com/rust-lang/rust/issues/29641> for more information\n   = help: add `#![feature(box_patterns)]` to the crate attributes to enable\n   = note: this compiler was built on 2025-05-09; consider upgrading it if it is out of date\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:43:59\n   |\n43 | ...                   if let Stmt::Expr(expr) | Stmt::Semi(expr, _) = stmt {\n   |                                         ^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n43 |                                         if let Stmt::Expr(expr, _) | Stmt::Semi(expr, _) = stmt {\n   |                                                               +++\n\nerror[E0599]: no variant or associated item named `Semi` found for enum `Stmt` in the current scope\n  --> src\\main.rs:43:73\n   |\n43 | ...                   if let Stmt::Expr(expr) | Stmt::Semi(expr, _) = stmt {\n   |                                                       ^^^^ variant or associated item not found in `Stmt`\n\nSome errors have detailed explanations: E0023, E0599, E0658.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mutator_Nested_Result_Type_259_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Semi` found for enum `Stmt` in the current scope\n  --> src\\main.rs:44:80\n   |\n44 | ...                   if let Stmt::Expr(expr, _) | Stmt::Semi(expr, _) = stmt {\n   |                                                          ^^^^ variant or associated item not found in `Stmt`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mutator_Nested_Result_Type_259_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:44:63\n   |\n44 | ...                   if let Stmt::Expr(expr) = stmt {\n   |                                         ^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n44 |                                             if let Stmt::Expr(expr, _) = stmt {\n   |                                                                   +++\n\nFor more information about this error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mutator_Nested_Result_Type_259_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.95s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:38:69:\nexpected `>`\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mutator_Nested_Result_Type_259_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:46:63\n   |\n46 | ...                   if let Stmt::Expr(expr) = stmt {\n   |                                         ^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n46 |                                             if let Stmt::Expr(expr, _) = stmt {\n   |                                                                   +++\n\nFor more information about this error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\mutator_nested_result_type_259.rs"
    },
    {
        "mutator_name": "Mutator_Trait_Lifetime_Modifier_412",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Mutator_Trait_Lifetime_Modifier_412_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `TraitItem` in the current scope\n  --> src\\main.rs:37:44\n   |\n37 |                     if let syn::TraitItem::Method(method) = item {\n   |                                            ^^^^^^ variant or associated item not found in `TraitItem`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mutator_Trait_Lifetime_Modifier_412_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0432]: unresolved import `syn::TraitItemMethod`\n  --> src\\main.rs:19:27\n   |\n19 |     ItemTrait, TraitItem, TraitItemMethod,\n   |                           ^^^^^^^^^^^^^^^\n   |                           |\n   |                           no `TraitItemMethod` in the root\n   |                           help: a similar name exists in the module: `TraitItemMacro`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `TraitItem` in the current scope\n  --> src\\main.rs:38:39\n   |\n38 |                     if let TraitItem::Method(method) = item {\n   |                                       ^^^^^^ variant or associated item not found in `TraitItem`\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\mutator_trait_lifetime_modifier_412.rs"
    },
    {
        "mutator_name": "Mutator_Type_Cast_Dyn_398",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Mutator_Type_Cast_Dyn_398_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0609]: no field `elem` on type `&ExprReference`\n  --> src\\main.rs:37:70\n   |\n37 | ...                   if let Type::TraitObject(_) = &*expr_ref.elem {\n   |                                                                ^^^^ unknown field\n   |\n   = note: available fields are: `attrs`, `and_token`, `mutability`, `expr`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mutator_Type_Cast_Dyn_398_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:37:36\n   |\n37 | ...                   if let Type::TraitObject(_) = &*expr_ref.expr {\n   |                              ^^^^^^^^^^^^^^^^^^^^   --------------- this expression has type `&syn::Expr`\n   |                              |\n   |                              expected `Expr`, found `Type`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mutator_Type_Cast_Dyn_398_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0609]: no field `ty` on type `&ExprReference`\n  --> src\\main.rs:37:70\n   |\n37 | ...                   if let Type::TraitObject(_) = &*expr_ref.ty {\n   |                                                                ^^ unknown field\n   |\n   = note: available fields are: `attrs`, `and_token`, `mutability`, `expr`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\mutator_type_cast_dyn_398.rs"
    },
    {
        "mutator_name": "Mutator_Union_And_Associated_Types_251",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Mutator_Union_And_Associated_Types_251_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0392]: lifetime parameter `'ast` is never used\n  --> src\\main.rs:30:29\n   |\n30 |         struct UnionVisitor<'ast> {\n   |                             ^^^^ unused lifetime parameter\n   |\n   = help: consider removing `'ast`, referring to it in a field, or using a marker such as `PhantomData`\n\nFor more information about this error, try `rustc --explain E0392`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Mutator_Union_And_Associated_Types_251_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.09s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:102:39:\ncalled `Option::unwrap()` on a `None` value\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\mutator_union_and_associated_types_251.rs"
    },
    {
        "mutator_name": "Pointer_Arithmetic_With_Type_Casting_348",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Pointer_Arithmetic_With_Type_Casting_348_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Semi` found for enum `Stmt` in the current scope\n  --> src\\main.rs:36:34\n   |\n36 |                     if let Stmt::Semi(Expr::MethodCall(method_call), _) = stmt {\n   |                                  ^^^^ variant or associated item not found in `Stmt`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:38:36\n   |\n38 | ...                   if let Some(receiver) = method_call.receiver.as_ref() {\n   |                              ^^^^^^^^^^^^^^   ----------------------------- this expression has type `&syn::Expr`\n   |                              |\n   |                              expected `Expr`, found `Option<_>`\n   |\n   = note: expected enum `syn::Expr`\n              found enum `Option<_>`\n\nerror[E0599]: no variant or associated item named `Semi` found for enum `Stmt` in the current scope\n  --> src\\main.rs:54:58\n   |\n54 | ...                   new_stmts.push(Stmt::Semi(ptr_as_usize, Default::default()));\n   |                                            ^^^^ variant or associated item not found in `Stmt`\n\nerror[E0599]: no variant or associated item named `Semi` found for enum `Stmt` in the current scope\n  --> src\\main.rs:55:58\n   |\n55 | ...                   new_stmts.push(Stmt::Semi(new_address, Default::default()));\n   |                                            ^^^^ variant or associated item not found in `Stmt`\n\nerror[E0599]: no variant or associated item named `Semi` found for enum `Stmt` in the current scope\n  --> src\\main.rs:56:58\n   |\n56 | ...                   new_stmts.push(Stmt::Semi(new_ptr, Default::default()));\n   |                                            ^^^^ variant or associated item not found in `Stmt`\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 5 previous errors\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\pointer_arithmetic_with_type_casting_348.rs"
    },
    {
        "mutator_name": "Refactor_Pattern_Matching_368",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Refactor_Pattern_Matching_368_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:36:32\n   |\n36 |                         if let Pat::Ident(pat_ident) = &mut field.pat {\n   |                                ^^^^^^^^^^^^^^^^^^^^^   -------------- this expression has type `&mut std::boxed::Box<Pat>`\n   |                                |\n   |                                expected `Box<Pat>`, found `Pat`\n   |\n   = note: expected struct `std::boxed::Box<Pat>`\n                found enum `Pat`\nhelp: consider dereferencing to access the inner value using the Deref trait\n   |\n36 -                         if let Pat::Ident(pat_ident) = &mut field.pat {\n36 +                         if let Pat::Ident(pat_ident) = &*field.pat {\n   |\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\refactor_pattern_matching_368.rs"
    },
    {
        "mutator_name": "Rename_Unnamed_Fields_294",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Rename_Unnamed_Fields_294_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:31:33\n   |\n31 |             if let Item::Struct(ref mut item_struct) = item {\n   |                                 ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:31:20\n   |\n31 |             if let Item::Struct(ref mut item_struct) = item {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n31 -             if let Item::Struct(ref mut item_struct) = item {\n31 +             if let Item::Struct(item_struct) = item {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:41:39\n   |\n41 |             } else if let Item::Union(ref mut item_union) = item {\n   |                                       ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:41:27\n   |\n41 |             } else if let Item::Union(ref mut item_union) = item {\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n41 -             } else if let Item::Union(ref mut item_union) = item {\n41 +             } else if let Item::Union(item_union) = item {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Rename_Unnamed_Fields_294_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Struct(item_struct) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:17:44\n   |\n17 |                         field.ident = Some(Ident::new(&format!(\"field{}\", field_index), Span::call_site()));\n   |                                            ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:17:89\n   |\n17 |                         field.ident = Some(Ident::new(&format!(\"field{}\", field_index), Span::call_site()));\n   |                                                                                         ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:21:27\n   |\n21 |             } else if let Item::Union(item_union) = item {\n   |                           ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:27:44\n   |\n27 |                         field.ident = Some(Ident::new(&format!(\"field{}\", field_index), Span::call_site()));\n   |                                            ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:27:89\n   |\n27 |                         field.ident = Some(Ident::new(&format!(\"field{}\", field_index), Span::call_site()));\n   |                                                                                         ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nFor more information about this error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 6 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Rename_Unnamed_Fields_294_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:6:6\n  |\n6 | impl Mutator for Rename_Unnamed_Fields_294 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\rename_unnamed_fields_294.rs"
    },
    {
        "mutator_name": "Replace_Const_With_Custom_Struct_269",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\replace_const_with_custom_struct_269.rs"
    },
    {
        "mutator_name": "Replace_Const_With_Generic_291",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Replace_Const_With_Generic_291_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:51:61\n   |\n51 | ...                   if let Expr::Path(expr_path) = &*type_array.len {\n   |                                                       ^^^^^^^^^^^^^^^ can't be dereferenced\n\nFor more information about this error, try `rustc --explain E0614`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\replace_const_with_generic_291.rs"
    },
    {
        "mutator_name": "Replace_GAT_With_Direct_Type_284",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Replace_GAT_With_Direct_Type_284_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `syn::TraitItem` in the current scope\n  --> src\\main.rs:59:39\n   |\n59 |                     if let TraitItem::Method(method) = item {\n   |                                       ^^^^^^ variant or associated item not found in `TraitItem`\n\nerror[E0599]: no method named `visit_trait_item_method_mut` found for struct `MethodVisitor` in the current scope\n  --> src\\main.rs:60:39\n   |\n30 |         struct MethodVisitor;\n   |         -------------------- method `visit_trait_item_method_mut` not found for this struct\n...\n60 |                         MethodVisitor.visit_trait_item_method_mut(method);\n   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\nhelp: there is a method `visit_trait_item_mut` with a similar name\n   |\n60 -                         MethodVisitor.visit_trait_item_method_mut(method);\n60 +                         MethodVisitor.visit_trait_item_mut(method);\n   |\n\nerror[E0506]: cannot assign to `pat_type.ty` because it is borrowed\n  --> src\\main.rs:43:49\n   |\n35 |                     if let Type::ImplTrait(type_impl_trait) = &*pat_type.ty {\n   |                                                               ------------- `pat_type.ty` is borrowed here\n36 |                         for bound in &type_impl_trait.bounds {\n   |                                      ----------------------- borrow later used here\n...\n43 |                                                 pat_type.ty = Box::new(new_type);\n   |                                                 ^^^^^^^^^^^ `pat_type.ty` is assigned to here but it was already borrowed\n\nSome errors have detailed explanations: E0506, E0599.\nFor more information about an error, try `rustc --explain E0506`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Replace_GAT_With_Direct_Type_284_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0506]: cannot assign to `pat_type.ty` because it is borrowed\n  --> src\\main.rs:43:49\n   |\n35 |                     if let Type::ImplTrait(type_impl_trait) = &*pat_type.ty {\n   |                                                               ------------- `pat_type.ty` is borrowed here\n36 |                         for bound in &type_impl_trait.bounds {\n   |                                      ----------------------- borrow later used here\n...\n43 |                                                 pat_type.ty = Box::new(new_type);\n   |                                                 ^^^^^^^^^^^ `pat_type.ty` is assigned to here but it was already borrowed\n\nFor more information about this error, try `rustc --explain E0506`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\replace_gat_with_direct_type_284.rs"
    },
    {
        "mutator_name": "Replace_Impl_Trait_With_Concrete_Type_360",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Replace_Impl_Trait_With_Concrete_Type_360_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0609]: no field `ty` on type `&mut syn::Local`\n  --> src\\main.rs:45:55\n   |\n45 |                         if let Some((_, ty)) = &local.ty {\n   |                                                       ^^ unknown field\n   |\n   = note: available fields are: `attrs`, `let_token`, `pat`, `init`, `semi_token`\n\nerror[E0609]: no field `ty` on type `&mut syn::Local`\n  --> src\\main.rs:48:44\n   |\n48 | ...                   *local.ty.as_mut().unwrap().1 = Box::new(parse_quote!(Option<(u32, u32)>));\n   |                              ^^ unknown field\n   |\n   = note: available fields are: `attrs`, `let_token`, `pat`, `init`, `semi_token`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Replace_Impl_Trait_With_Concrete_Type_360_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:45:37\n   |\n45 |                         if let Some((_, box_ty)) = &local.init {\n   |                                     ^^^^^^^^^^^    ----------- this expression has type `&Option<LocalInit>`\n   |                                     |\n   |                                     expected `LocalInit`, found `(_, _)`\n   |\n   = note: expected struct `LocalInit`\n               found tuple `(_, _)`\n\nerror[E0599]: no variant or associated item named `Type` found for enum `syn::Expr` in the current scope\n  --> src\\main.rs:46:42\n   |\n46 | ...                   if let Expr::Type(expr_type) = &**box_ty {\n   |                                    ^^^^ variant or associated item not found in `syn::Expr`\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Replace_Impl_Trait_With_Concrete_Type_360_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0609]: no field `ty` on type `&mut syn::Local`\n  --> src\\main.rs:50:47\n   |\n50 | ...                   local.ty = Some(Box::new(PatType {\n   |                             ^^ unknown field\n   |\n   = note: available fields are: `attrs`, `let_token`, `pat`, `init`, `semi_token`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Replace_Impl_Trait_With_Concrete_Type_360_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:50:53\n   |\n50 |   ...                   local.pat = Box::new(Pat::Type(PatType {\n   |  _______________________---------___^\n   | |                       |\n   | |                       expected due to the type of this binding\n51 | | ...                       attrs: Vec::new(),\n52 | | ...                       pat: Box::new(Pat::Wild(PatWild {\n53 | | ...                           attrs: Vec::new(),\n...  |\n57 | | ...                       ty: Box::new(new_type),\n58 | | ...                   }));\n   | |_________________________^ expected `Pat`, found `Box<Pat>`\n   |\n   = note: expected enum `Pat`\n            found struct `std::boxed::Box<Pat>`\nhelp: consider unboxing the value\n   |\n50 |                                         local.pat = *Box::new(Pat::Type(PatType {\n   |                                                     +\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\replace_impl_trait_with_concrete_type_360.rs"
    },
    {
        "mutator_name": "Replace_Return_Type_with_impl_Trait_444",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\replace_return_type_with_impl_trait_444.rs"
    },
    {
        "mutator_name": "Replace_Unsized_With_Sized_331",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Replace_Unsized_With_Sized_331_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Binding` found for enum `GenericArgument` in the current scope\n  --> src\\main.rs:41:69\n   |\n41 | ...                   if let GenericArgument::Binding(binding) = arg {\n   |                                               ^^^^^^^ variant or associated item not found in `GenericArgument`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\replace_unsized_with_sized_331.rs"
    },
    {
        "mutator_name": "Simplify_Static_Type_395",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\simplify_static_type_395.rs"
    },
    {
        "mutator_name": "Specialization_Trait_Impl_Mutation_416",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\specialization_trait_impl_mutation_416.rs"
    },
    {
        "mutator_name": "Struct_Type_Change_288",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\struct_type_change_288.rs"
    },
    {
        "mutator_name": "Struct_With_Impl_Trait_In_Field_400",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Struct_With_Impl_Trait_In_Field_400_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: expected identifier, found reserved keyword `gen`\n  --> src\\main.rs:66:58\n   |\n66 | ...                   &format!(\"new_field_{}\", rng.gen::<u32>()),\n   |                                                    ^^^ expected identifier, found reserved keyword\n   |\nhelp: escape `gen` to use it as an identifier\n   |\n66 |                             &format!(\"new_field_{}\", rng.r#gen::<u32>()),\n   |                                                          ++\n\nerror[E0599]: no method named `choose` found for struct `std::collections::hash_set::Iter` in the current scope\n   --> src\\main.rs:64:72\n    |\n64  |                     if let Some(trait_ident) = trait_candidates.iter().choose(&mut rng) {\n    |                                                                        ^^^^^^ method not found in `Iter<'_, Ident>`\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rand-0.8.5\\src\\seq\\mod.rs:304:8\n    |\n304 |     fn choose<R>(mut self, rng: &mut R) -> Option<Self::Item>\n    |        ------ the method is available for `std::collections::hash_set::Iter<'_, proc_macro2::Ident>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `IteratorRandom` which provides `choose` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use rand::prelude::IteratorRandom;\n    |\n\nerror[E0599]: no method named `push` found for enum `Fields` in the current scope\n  --> src\\main.rs:69:44\n   |\n69 |                         item_struct.fields.push(Field {\n   |                         -------------------^^^^ method not found in `Fields`\n\nerror[E0063]: missing field `mutability` in initializer of `syn::Field`\n  --> src\\main.rs:69:49\n   |\n69 |                         item_struct.fields.push(Field {\n   |                                                 ^^^^^ missing `mutability`\n\nerror[E0599]: no method named `choose` found for struct `std::collections::hash_set::Iter` in the current scope\n   --> src\\main.rs:91:75\n    |\n91  |                 } else if let Some(trait_ident) = trait_candidates.iter().choose(&mut rng) {\n    |                                                                           ^^^^^^ method not found in `Iter<'_, Ident>`\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rand-0.8.5\\src\\seq\\mod.rs:304:8\n    |\n304 |     fn choose<R>(mut self, rng: &mut R) -> Option<Self::Item>\n    |        ------ the method is available for `std::collections::hash_set::Iter<'_, proc_macro2::Ident>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `IteratorRandom` which provides `choose` is implemented but not in scope; perhaps you want to import it\n    |\n1   + use rand::prelude::IteratorRandom;\n    |\n\nSome errors have detailed explanations: E0063, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 5 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Struct_With_Impl_Trait_In_Field_400_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Struct_With_Impl_Trait_In_Field_400 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nerror[E0425]: cannot find function `thread_rng` in this scope\n  --> src\\main.rs:10:23\n   |\n10 |         let mut rng = thread_rng();\n   |                       ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  + use rand::thread_rng;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n  --> src\\main.rs:11:36\n   |\n11 |         let mut trait_candidates = HashSet::new();\n   |                                    ^^^^^^^ use of undeclared type `HashSet`\n   |\nhelp: consider importing this struct\n   |\n1  + use std::collections::HashSet;\n   |\n\nerror[E0412]: cannot find type `HashSet` in this scope\n  --> src\\main.rs:15:39\n   |\n15 |             trait_candidates: &'a mut HashSet<Ident>,\n   |                                       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use std::collections::HashSet;\n   |\n\nerror[E0412]: cannot find type `Ident` in this scope\n  --> src\\main.rs:15:47\n   |\n15 |             trait_candidates: &'a mut HashSet<Ident>,\n   |                                               ^^^^^ not found in this scope\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nerror[E0405]: cannot find trait `Visit` in this scope\n  --> src\\main.rs:18:18\n   |\n18 |         impl<'a> Visit<'_> for TraitCollector<'a> {\n   |                  ^^^^^ not found in this scope\n   |\nhelp: consider importing this trait\n   |\n1  + use syn::visit::Visit;\n   |\n\nerror[E0412]: cannot find type `ItemTrait` in this scope\n  --> src\\main.rs:19:51\n   |\n19 |             fn visit_item_trait(&mut self, node: &ItemTrait) {\n   |                                                   ^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::ItemTrait;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:30:20\n   |\n30 |             if let Item::Struct(item_struct) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:35:28\n   |\n35 |                     if let Type::Path(type_path) = &field.ty {\n   |                            ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:45:47\n   |\n45 |                         let new_field_ident = Ident::new(\n   |                                               ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:47:29\n   |\n47 | ...                   Span::call_site(),\n   |                       ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `Field` in this scope\n  --> src\\main.rs:50:53\n   |\n50 | ...                   fields_named.named.push(Field {\n   |                                               ^^^^^ not found in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Expr::Field;\n   |\n1  + use syn::Field;\n   |\n1  + use tree_sitter::QueryErrorKind::Field;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `token`\n  --> src\\main.rs:54:51\n   |\n54 | ...                   colon_token: Some(token::Colon::default()),\n   |                                         ^^^^^ use of unresolved module or unlinked crate `token`\n   |\n   = help: if you wanted to use a crate named `token`, use `cargo add token` to add it to your `Cargo.toml`\nhelp: consider importing this struct\n   |\n1  + use syn::token::Colon;\n   |\nhelp: if you import `Colon`, refer to it directly\n   |\n54 -                                 colon_token: Some(token::Colon::default()),\n54 +                                 colon_token: Some(Colon::default()),\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:55:37\n   |\n55 | ...                   ty: Type::ImplTrait(TypeImplTrait {\n   |                           ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypeImplTrait` in this scope\n  --> src\\main.rs:55:53\n   |\n55 | ...                   ty: Type::ImplTrait(TypeImplTrait {\n   |                                           ^^^^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypeImplTrait;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `token`\n  --> src\\main.rs:56:49\n   |\n56 | ...                   impl_token: token::Impl::default(),\n   |                                   ^^^^^ use of unresolved module or unlinked crate `token`\n   |\n   = help: if you wanted to use a crate named `token`, use `cargo add token` to add it to your `Cargo.toml`\nhelp: consider importing this struct\n   |\n1  + use syn::token::Impl;\n   |\nhelp: if you import `Impl`, refer to it directly\n   |\n56 -                                     impl_token: token::Impl::default(),\n56 +                                     impl_token: Impl::default(),\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TypeParamBound`\n  --> src\\main.rs:57:50\n   |\n57 | ...                   bounds: vec![TypeParamBound::Trait(TraitBound {\n   |                                    ^^^^^^^^^^^^^^ use of undeclared type `TypeParamBound`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TypeParamBound;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TraitBound` in this scope\n  --> src\\main.rs:57:72\n   |\n57 | ...                   bounds: vec![TypeParamBound::Trait(TraitBound {\n   |                                                          ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TraitBound;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TraitBoundModifier`\n  --> src\\main.rs:59:51\n   |\n59 | ...                   modifier: TraitBoundModifier::None,\n   |                                 ^^^^^^^^^^^^^^^^^^ use of undeclared type `TraitBoundModifier`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TraitBoundModifier;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `SynPath` in this scope\n  --> src\\main.rs:61:47\n   |\n61 | ...                   path: SynPath {\n   |                             ^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Punctuated`\n  --> src\\main.rs:63:55\n   |\n63 | ...                   segments: Punctuated::from_iter(vec![PathSegment {\n   |                                 ^^^^^^^^^^ use of undeclared type `Punctuated`\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::punctuated::Punctuated;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `PathSegment` in this scope\n  --> src\\main.rs:63:82\n   |\n63 | ...                   segments: Punctuated::from_iter(vec![PathSegment {\n   |                                                            ^^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::PathSegment;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `PathArguments`\n  --> src\\main.rs:65:60\n   |\n65 | ...                   arguments: PathArguments::None,\n   |                                  ^^^^^^^^^^^^^ use of undeclared type `PathArguments`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::PathArguments;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:76:36\n   |\n76 |                         field.ty = Type::ImplTrait(TypeImplTrait {\n   |                                    ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypeImplTrait` in this scope\n  --> src\\main.rs:76:52\n   |\n76 |                         field.ty = Type::ImplTrait(TypeImplTrait {\n   |                                                    ^^^^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypeImplTrait;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `token`\n  --> src\\main.rs:77:41\n   |\n77 | ...                   impl_token: token::Impl::default(),\n   |                                   ^^^^^ use of unresolved module or unlinked crate `token`\n   |\n   = help: if you wanted to use a crate named `token`, use `cargo add token` to add it to your `Cargo.toml`\nhelp: consider importing this struct\n   |\n1  + use syn::token::Impl;\n   |\nhelp: if you import `Impl`, refer to it directly\n   |\n77 -                             impl_token: token::Impl::default(),\n77 +                             impl_token: Impl::default(),\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TypeParamBound`\n  --> src\\main.rs:78:42\n   |\n78 | ...                   bounds: vec![TypeParamBound::Trait(TraitBound {\n   |                                    ^^^^^^^^^^^^^^ use of undeclared type `TypeParamBound`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TypeParamBound;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TraitBound` in this scope\n  --> src\\main.rs:78:64\n   |\n78 | ...                   bounds: vec![TypeParamBound::Trait(TraitBound {\n   |                                                          ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TraitBound;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TraitBoundModifier`\n  --> src\\main.rs:80:43\n   |\n80 | ...                   modifier: TraitBoundModifier::None,\n   |                                 ^^^^^^^^^^^^^^^^^^ use of undeclared type `TraitBoundModifier`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TraitBoundModifier;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `SynPath` in this scope\n  --> src\\main.rs:82:39\n   |\n82 | ...                   path: SynPath {\n   |                             ^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Punctuated`\n  --> src\\main.rs:84:47\n   |\n84 | ...                   segments: Punctuated::from_iter(vec![PathSegment {\n   |                                 ^^^^^^^^^^ use of undeclared type `Punctuated`\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::punctuated::Punctuated;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `PathSegment` in this scope\n  --> src\\main.rs:84:74\n   |\n84 | ...                   segments: Punctuated::from_iter(vec![PathSegment {\n   |                                                            ^^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::PathSegment;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `PathArguments`\n  --> src\\main.rs:86:52\n   |\n86 | ...                   arguments: PathArguments::None,\n   |                                  ^^^^^^^^^^^^^ use of undeclared type `PathArguments`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::PathArguments;\n   |\n\nSome errors have detailed explanations: E0405, E0412, E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 33 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Struct_With_Impl_Trait_In_Field_400_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: expected identifier, found reserved keyword `gen`\n  --> src\\main.rs:53:58\n   |\n53 | ...                   &format!(\"new_field_{}\", rng.gen::<u32>()),\n   |                                                    ^^^ expected identifier, found reserved keyword\n   |\nhelp: escape `gen` to use it as an identifier\n   |\n53 |                             &format!(\"new_field_{}\", rng.r#gen::<u32>()),\n   |                                                          ++\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:77:45\n   |\n77 | ...                   mutability: None,\n   |                                   ^^^^ expected `FieldMutability`, found `Option<_>`\n   |\n   = note: expected enum `FieldMutability`\n              found enum `Option<_>`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\struct_with_impl_trait_in_field_400.rs"
    },
    {
        "mutator_name": "Trait_AssocType_Cycle_446",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Trait_AssocType_Cycle_446_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0658]: box pattern syntax is experimental\n  --> src\\main.rs:34:52\n   |\n34 |                         if let ReturnType::Type(_, box Type::ImplTrait(_)) = &m.sig.output {\n   |                                                    ^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: see issue #29641 <https://github.com/rust-lang/rust/issues/29641> for more information\n   = help: add `#![feature(box_patterns)]` to the crate attributes to enable\n   = note: this compiler was built on 2025-05-09; consider upgrading it if it is out of date\n\nerror[E0658]: box pattern syntax is experimental\n  --> src\\main.rs:42:48\n   |\n42 |                     if let ReturnType::Type(_, box Type::ImplTrait(impl_trait)) = &method.sig.output {\n   |                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: see issue #29641 <https://github.com/rust-lang/rust/issues/29641> for more information\n   = help: add `#![feature(box_patterns)]` to the crate attributes to enable\n   = note: this compiler was built on 2025-05-09; consider upgrading it if it is out of date\n\nerror[E0599]: no variant or associated item named `Method` found for enum `TraitItem` in the current scope\n  --> src\\main.rs:33:44\n   |\n33 |                     if let syn::TraitItem::Method(m) = i {\n   |                                            ^^^^^^ variant or associated item not found in `TraitItem`\n\nerror[E0063]: missing field `type_token` in initializer of `TraitItemType`\n  --> src\\main.rs:48:64\n   |\n48 |                     item_trait.items.push(syn::TraitItem::Type(syn::TraitItemType {\n   |                                                                ^^^^^^^^^^^^^^^^^^ missing `type_token`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `TraitItem` in the current scope\n  --> src\\main.rs:59:48\n   |\n59 |                         if let syn::TraitItem::Method(m) = i {\n   |                                                ^^^^^^ variant or associated item not found in `TraitItem`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `TraitItem` in the current scope\n  --> src\\main.rs:58:44\n   |\n58 |                     if let syn::TraitItem::Method(method) = item_trait.items.iter_mut().find(|i| {\n   |                                            ^^^^^^ variant or associated item not found in `TraitItem`\n\nSome errors have detailed explanations: E0063, E0599, E0658.\nFor more information about an error, try `rustc --explain E0063`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 6 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Trait_AssocType_Cycle_446_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:44:48\n   |\n44 |                     if let ReturnType::Type(_, ref ty) = &method.sig.output {\n   |                                                ^^^ binding modifier not allowed under `ref` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:44:28\n   |\n44 |                     if let ReturnType::Type(_, ref ty) = &method.sig.output {\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&_`\nhelp: remove the unnecessary binding modifier\n   |\n44 -                     if let ReturnType::Type(_, ref ty) = &method.sig.output {\n44 +                     if let ReturnType::Type(_, ty) = &method.sig.output {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:34:52\n   |\n34 |                         if let ReturnType::Type(_, ref ty) = &m.sig.output {\n   |                                                    ^^^ binding modifier not allowed under `ref` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:34:32\n   |\n34 |                         if let ReturnType::Type(_, ref ty) = &m.sig.output {\n   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&_`\nhelp: remove the unnecessary binding modifier\n   |\n34 -                         if let ReturnType::Type(_, ref ty) = &m.sig.output {\n34 +                         if let ReturnType::Type(_, ty) = &m.sig.output {\n   |\n\nerror[E0507]: cannot move out of `ty` as enum variant `ImplTrait` which is behind a shared reference\n  --> src\\main.rs:45:62\n   |\n45 |                         if let Type::ImplTrait(impl_trait) = **ty {\n   |                                                ----------    ^^^^\n   |                                                |\n   |                                                data moved here\n   |                                                move occurs because `impl_trait` has type `TypeImplTrait`, which does not implement the `Copy` trait\n   |\nhelp: consider removing the dereference here\n   |\n45 -                         if let Type::ImplTrait(impl_trait) = **ty {\n45 +                         if let Type::ImplTrait(impl_trait) = *ty {\n   |\n\nerror[E0502]: cannot borrow `item_trait.items` as mutable because it is also borrowed as immutable\n  --> src\\main.rs:52:21\n   |\n32 |                   if let Some(method) = item_trait.items.iter().find_map(|i| {\n   |                                         ---------------- immutable borrow occurs here\n...\n52 | /                     item_trait.items.push(syn::TraitItem::Type(syn::TraitItemType {\n53 | |                         attrs: vec![],\n54 | |                         ident: assoc_type_ident.clone(),\n55 | |                         generics: syn::Generics::default(),\n...  |\n60 | |                         type_token: token::Type(Span::call_site()),\n61 | |                     }));\n   | |_______________________^ mutable borrow occurs here\n...\n65 |                               return m.sig.ident == method.sig.ident;\n   |                                                     ---------------- immutable borrow later captured here by closure\n\nerror[E0502]: cannot borrow `item_trait.items` as mutable because it is also borrowed as immutable\n  --> src\\main.rs:63:63\n   |\n32 |                 if let Some(method) = item_trait.items.iter().find_map(|i| {\n   |                                       ---------------- immutable borrow occurs here\n...\n63 |                     if let Some(syn::TraitItem::Fn(method)) = item_trait.items.iter_mut().find(|i| {\n   |                                                               ^^^^^^^^^^^^^^^^ mutable borrow occurs here\n64 |                         if let syn::TraitItem::Fn(m) = i {\n65 |                             return m.sig.ident == method.sig.ident;\n   |                                                   ---------------- immutable borrow later captured here by closure\n\nSome errors have detailed explanations: E0502, E0507.\nFor more information about an error, try `rustc --explain E0502`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 5 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Trait_AssocType_Cycle_446_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:12:20\n   |\n12 |             if let Item::Trait(item_trait) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `ReturnType`\n  --> src\\main.rs:15:32\n   |\n15 |                         if let ReturnType::Type(_, ty) = &m.sig.output {\n   |                                ^^^^^^^^^^ use of undeclared type `ReturnType`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::ReturnType;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:16:36\n   |\n16 | ...                   if let Type::ImplTrait(_) = **ty {\n   |                              ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:23:44\n   |\n23 |                     let assoc_type_ident = Ident::new(\"AssocType\", Span::call_site());\n   |                                            ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:23:68\n   |\n23 |                     let assoc_type_ident = Ident::new(\"AssocType\", Span::call_site());\n   |                                                                    ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Punctuated`\n  --> src\\main.rs:24:38\n   |\n24 |                     let mut bounds = Punctuated::new();\n   |                                      ^^^^^^^^^^ use of undeclared type `Punctuated`\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::punctuated::Punctuated;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `ReturnType`\n  --> src\\main.rs:25:28\n   |\n25 |                     if let ReturnType::Type(_, ty) = &method.sig.output {\n   |                            ^^^^^^^^^^ use of undeclared type `ReturnType`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::ReturnType;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:26:32\n   |\n26 |                         if let Type::ImplTrait(impl_trait) = *ty {\n   |                                ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `token`\n  --> src\\main.rs:37:43\n   |\n37 |                         colon_token: Some(token::Colon(Span::call_site())),\n   |                                           ^^^^^ use of unresolved module or unlinked crate `token`\n   |\n   = help: if you wanted to use a crate named `token`, use `cargo add token` to add it to your `Cargo.toml`\nhelp: consider importing this module\n   |\n1  + use syn::token;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:37:56\n   |\n37 |                         colon_token: Some(token::Colon(Span::call_site())),\n   |                                                        ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `token`\n  --> src\\main.rs:40:37\n   |\n40 |                         semi_token: token::Semi(Span::call_site()),\n   |                                     ^^^^^ use of unresolved module or unlinked crate `token`\n   |\n   = help: if you wanted to use a crate named `token`, use `cargo add token` to add it to your `Cargo.toml`\nhelp: consider importing this module\n   |\n1  + use syn::token;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:40:49\n   |\n40 |                         semi_token: token::Semi(Span::call_site()),\n   |                                                 ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `token`\n  --> src\\main.rs:41:37\n   |\n41 |                         type_token: token::Type(Span::call_site()),\n   |                                     ^^^^^ use of unresolved module or unlinked crate `token`\n   |\n   = help: if you wanted to use a crate named `token`, use `cargo add token` to add it to your `Cargo.toml`\nhelp: consider importing this module\n   |\n1  + use syn::token;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:41:49\n   |\n41 |                         type_token: token::Type(Span::call_site()),\n   |                                                 ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `ReturnType`\n  --> src\\main.rs:50:45\n   |\n50 |                         method.sig.output = ReturnType::Type(\n   |                                             ^^^^^^^^^^ use of undeclared type `ReturnType`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::ReturnType;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `token`\n  --> src\\main.rs:51:29\n   |\n51 | ...                   token::RArrow(Span::call_site()),\n   |                       ^^^^^ use of unresolved module or unlinked crate `token`\n   |\n   = help: if you wanted to use a crate named `token`, use `cargo add token` to add it to your `Cargo.toml`\nhelp: consider importing this module\n   |\n1  + use syn::token;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:51:43\n   |\n51 | ...                   token::RArrow(Span::call_site()),\n   |                                     ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:52:38\n   |\n52 | ...                   Box::new(Type::Path(TypePath {\n   |                                ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypePath` in this scope\n  --> src\\main.rs:52:49\n   |\n52 | ...                   Box::new(Type::Path(TypePath {\n   |                                           ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypePath;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:62:89\n   |\n62 |             if let Item::Trait(item_trait) = file.items.iter_mut().find(|i| matches!(i, Item::Trait(_))) {\n   |                                                                                         ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:62:20\n   |\n62 |             if let Item::Trait(item_trait) = file.items.iter_mut().find(|i| matches!(i, Item::Trait(_))) {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:63:24\n   |\n63 |                 if let Item::Trait(item_trait) = item_trait {\n   |                        ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 22 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Trait_AssocType_Cycle_446_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:6:6\n  |\n6 | impl Mutator for Trait_AssocType_Cycle_446 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Trait_AssocType_Cycle_446_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:28:32\n   |\n28 |                         if let Type::ImplTrait(impl_trait) = *ty {\n   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^   --- this expression has type `std::boxed::Box<syn::Type>`\n   |                                |\n   |                                expected `Box<Type>`, found `Type`\n   |\n   = note: expected struct `std::boxed::Box<syn::Type>`\n                found enum `syn::Type`\nhelp: consider dereferencing the boxed value\n   |\n28 |                         if let Type::ImplTrait(impl_trait) = **ty {\n   |                                                               +\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:64:20\n   |\n64 |             if let Item::Trait(item_trait) = file.items.iter_mut().find(|i| matches!(i, Item::Trait(_))) {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^   ----------------------------------------------------------- this expression has type `Option<&mut syn::Item>`\n   |                    |\n   |                    expected `Option<&mut Item>`, found `Item`\n   |\n   = note: expected enum `Option<&mut syn::Item>`\n              found enum `syn::Item`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:65:24\n   |\n65 |                 if let Item::Trait(item_trait) = item_trait {\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^   ---------- this expression has type `ItemTrait`\n   |                        |\n   |                        expected `ItemTrait`, found `Item`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Trait_AssocType_Cycle_446_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0063]: missing field `type_token` in initializer of `TraitItemType`\n  --> src\\main.rs:35:59\n   |\n35 |                     assoc_type_items.push(TraitItem::Type(TraitItemType {\n   |                                                           ^^^^^^^^^^^^^ missing `type_token`\n\nFor more information about this error, try `rustc --explain E0063`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Trait_AssocType_Cycle_446_compling_err_7.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0502]: cannot borrow `item_trait.items` as mutable because it is also borrowed as immutable\n  --> src\\main.rs:46:58\n   |\n15 |                 if let Some(method) = item_trait.items.iter().find_map(|i| {\n   |                                       ---------------- immutable borrow occurs here\n...\n46 |                     if let Some(TraitItem::Fn(method)) = item_trait.items.iter_mut().find(|i| {\n   |                                                          ^^^^^^^^^^^^^^^^ mutable borrow occurs here\n47 |                         if let TraitItem::Fn(m) = i {\n48 |                             return m.sig.ident == method.sig.ident;\n   |                                                   ---------------- immutable borrow later captured here by closure\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\trait_assoctype_cycle_446.rs"
    },
    {
        "mutator_name": "Trait_Implementation_Mismatch_429",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Trait_Implementation_Mismatch_429_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0726]: implicit elided lifetime not allowed here\n  --> src\\main.rs:34:14\n   |\n34 |         impl Visit for TraitImplVisitor {\n   |              ^^^^^ expected lifetime parameter\n   |\nhelp: indicate the anonymous lifetime\n   |\n34 |         impl Visit<'_> for TraitImplVisitor {\n   |                   ++++\n\nerror[E0599]: no method named `parenthesized` found for enum `PathArguments` in the current scope\n  --> src\\main.rs:38:83\n   |\n38 |                         if let Some((_, PathArguments::None)) = segment.arguments.parenthesized() {\n   |                                                                                   ^^^^^^^^^^^^^ method not found in `PathArguments`\n   |\nhelp: there is a variant with a similar name\n   |\n38 -                         if let Some((_, PathArguments::None)) = segment.arguments.parenthesized() {\n38 +                         if let Some((_, PathArguments::None)) = segment.arguments.Parenthesized() {\n   |\n\nSome errors have detailed explanations: E0599, E0726.\nFor more information about an error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\trait_implementation_mismatch_429.rs"
    },
    {
        "mutator_name": "Trait_Implementation_Mutation_404",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\trait_implementation_mutation_404.rs"
    },
    {
        "mutator_name": "Trait_Impl_Async_Mutator_439",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Trait_Impl_Async_Mutator_439_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `retain` found for struct `syn::punctuated::Punctuated` in the current scope\n  --> src\\main.rs:39:63\n   |\n39 | ...                   predicate_type.bounds.retain(|b| {\n   |                       ----------------------^^^^^^ method not found in `Punctuated<TypeParamBound, Plus>`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\trait_impl_async_mutator_439.rs"
    },
    {
        "mutator_name": "Trait_Impl_Gen_282",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Trait_Impl_Gen_282_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:35:47\n   |\n35 |                         if let syn::ImplItem::Method(method) = item {\n   |                                               ^^^^^^ variant or associated item not found in `ImplItem`\n\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:37:77\n   |\n37 | ...                   if let Type::Path(TypePath { path, .. }) = &**ty {\n   |                                                                   ^^^^ can't be dereferenced\n\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:58:51\n   |\n58 | ...                   if let syn::ImplItem::Method(method) = item {\n   |                                             ^^^^^^ variant or associated item not found in `ImplItem`\n\nerror[E0614]: type `syn::Type` cannot be dereferenced\n  --> src\\main.rs:78:85\n   |\n78 | ...                   if let Type::Path(TypePath { path, .. }) = &mut **ty {\n   |                                                                       ^^^^ can't be dereferenced\n\nSome errors have detailed explanations: E0599, E0614.\nFor more information about an error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\trait_impl_gen_282.rs"
    },
    {
        "mutator_name": "Trait_Impl_Mutation_373",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\trait_impl_mutation_373.rs"
    },
    {
        "mutator_name": "Transmute_Option_In_Function_Context_345",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Transmute_Option_In_Function_Context_345_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:46:37\n   |\n46 |                         if let Some((_, expr)) = init {\n   |                                     ^^^^^^^^^    ---- this expression has type `&Option<LocalInit>`\n   |                                     |\n   |                                     expected `LocalInit`, found `(_, _)`\n   |\n   = note: expected struct `LocalInit`\n               found tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:73:41\n   |\n73 | ...                   if let Some((_, expr)) = init {\n   |                                   ^^^^^^^^^    ---- this expression has type `&mut Option<LocalInit>`\n   |                                   |\n   |                                   expected `LocalInit`, found `(_, _)`\n   |\n   = note: expected struct `LocalInit`\n               found tuple `(_, _)`\n\nerror[E0614]: type `Stmt` cannot be dereferenced\n  --> src\\main.rs:75:87\n   |\n75 | ...                   if let Expr::Call(ExprCall { func, args, .. }) = &*unsafe_expr.block.stmts[0] {\n   |                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:76:85\n   |\n76 | ...                   if let Expr::Path(ExprPath { path, .. }) = &**func {\n   |                                                                   ^^^^^^ can't be dereferenced\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Transmute_Option_In_Function_Context_345_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:72:56\n   |\n72 | ...                   if let Some(Stmt::Expr(Expr::Call(ExprCall { func, args, .. }))) = unsafe_expr.block.stmts.first_mut() {\n   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n72 |                                 if let Some(Stmt::Expr(Expr::Call(ExprCall { func, args, .. }), _)) = unsafe_expr.block.stmts.first_mut() {\n   |                                                                                               +++\n\nFor more information about this error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\transmute_option_in_function_context_345.rs"
    },
    {
        "mutator_name": "Transmute_With_Unresolved_Inference_296",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\transmute_with_unresolved_inference_296.rs"
    },
    {
        "mutator_name": "Undefined_Type_In_Struct_312",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\undefined_type_in_struct_312.rs"
    },
    {
        "mutator_name": "Unsized_Field_Placement_323",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Unsized_Field_Placement_323_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0608]: cannot index into a value of type `Fields`\n  --> src\\main.rs:44:83\n   |\n44 | ...                   if let Type::Path(type_path) = &mut item_struct.fields[selected_index].ty {\n   |                                                                             ^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0608`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Unsized_Field_Placement_323_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.80s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:47:89:\n\"[u8]\" is not a valid Ident\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Unsized_Field_Placement_323_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.77s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:48:66:\nexpected identifier\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Unsized_Field_Placement_323_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:27:82\n   |\n27 | ...                   arguments: PathArguments::AngleBracketed(parse_quote!(<u8>)),\n   |                                                                ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:3:6\n  |\n3 | impl Mutator for Unsized_Field_Placement_323 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n --> src\\main.rs:9:20\n  |\n9 |             if let Item::Struct(item_struct) = item {\n  |                    ^^^^ use of undeclared type `Item`\n  |\nhelp: consider importing this enum\n  |\n1 + use syn::Item;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `Fields`\n  --> src\\main.rs:10:24\n   |\n10 |                 if let Fields::Named(fields_named) = &mut item_struct.fields {\n   |                        ^^^^^^ use of undeclared type `Fields`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Fields;\n   |\n\nerror[E0425]: cannot find function `thread_rng` in this scope\n  --> src\\main.rs:12:39\n   |\n12 |                         let mut rng = thread_rng();\n   |                                       ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  + use rand::thread_rng;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:14:69\n   |\n14 | ...                   .filter(|(_, field)| matches!(field.ty, Type::Path(_)))\n   |                                                               ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:23:40\n   |\n23 | ...                   if let Type::Path(type_path) = &mut fields_named.named[selected_index].ty {\n   |                              ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:24:89\n   |\n24 | ...                   type_path.path.segments.last_mut().unwrap().ident = Ident::new(\"u8\", Span::call_site());\n   |                                                                           ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:24:106\n   |\n24 | ...                   type_path.path.segments.last_mut().unwrap().ident = Ident::new(\"u8\", Span::call_site());\n   |                                                                                            ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `PathSegment` in this scope\n  --> src\\main.rs:25:66\n   |\n25 | ...                   type_path.path.segments.push(PathSegment {\n   |                                                    ^^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::PathSegment;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:26:48\n   |\n26 | ...                   ident: Ident::new(\"Slice\", Span::call_site()),\n   |                              ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:26:68\n   |\n26 | ...                   ident: Ident::new(\"Slice\", Span::call_site()),\n   |                                                  ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `PathArguments`\n  --> src\\main.rs:27:52\n   |\n27 | ...                   arguments: PathArguments::AngleBracketed(parse_quote!(<u8>)),\n   |                                  ^^^^^^^^^^^^^ use of undeclared type `PathArguments`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::PathArguments;\n   |\n\nSome errors have detailed explanations: E0405, E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 13 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Unsized_Field_Placement_323_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `shuffle` found for struct `Vec<usize>` in the current scope\n  --> src\\main.rs:24:49\n   |\n24 | ...                   sized_field_indices.shuffle(&mut rng);\n   |                                           ^^^^^^^ method not found in `Vec<usize>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: trait `SliceRandom` which provides `shuffle` is implemented but not in scope; perhaps you want to import it\n   |\n1  + use rand::prelude::SliceRandom;\n   |\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\unsized_field_placement_323.rs"
    },
    {
        "mutator_name": "Zero_Sized_Array_In_Union_320",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Zero_Sized_Array_In_Union_320_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0614]: type `syn::Expr` cannot be dereferenced\n  --> src\\main.rs:35:55\n   |\n35 |                         if let Expr::Lit(expr_lit) = &*type_array.len {\n   |                                                       ^^^^^^^^^^^^^^^ can't be dereferenced\n\nerror[E0599]: no method named `retain` found for struct `syn::punctuated::Punctuated` in the current scope\n  --> src\\main.rs:50:45\n   |\n50 |                     item_union.fields.named.retain(|f| f != &field);\n   |                                             ^^^^^^ method not found in `Punctuated<Field, Comma>`\n\nSome errors have detailed explanations: E0599, E0614.\nFor more information about an error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Zero_Sized_Array_In_Union_320_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0507]: cannot move out of `item_union.fields.named` which is behind a mutable reference\n  --> src\\main.rs:51:43\n   |\n51 |                 item_union.fields.named = item_union.fields.named.into_iter().filter(|f| !fields_to_replace.contains(f)).collect();\n   |                                           ^^^^^^^^^^^^^^^^^^^^^^^ ----------- `item_union.fields.named` moved due to this method call\n   |                                           |\n   |                                           move occurs because `item_union.fields.named` has type `syn::punctuated::Punctuated<syn::Field, syn::token::Comma>`, which does not implement the `Copy` trait\n   |\nhelp: you can `clone` the value and consume it, but this might not be your desired behavior\n   |\n51 |                 item_union.fields.named = <syn::punctuated::Punctuated<syn::Field, syn::token::Comma> as Clone>::clone(&item_union.fields.named).into_iter().filter(|f| !fields_to_replace.contains(f)).collect();\n   |                                           ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++                       +\nhelp: consider cloning the value if the performance cost is acceptable\n   |\n51 |                 item_union.fields.named = item_union.fields.named.clone().into_iter().filter(|f| !fields_to_replace.contains(f)).collect();\n   |                                                                  ++++++++\n\nerror[E0382]: borrow of moved value: `fields_to_replace`\n   --> src\\main.rs:51:86\n    |\n32  |                 let mut fields_to_replace = vec![];\n    |                     --------------------- move occurs because `fields_to_replace` has type `Vec<syn::Field>`, which does not implement the `Copy` trait\n...\n44  |                 for field in fields_to_replace {\n    |                              ----------------- `fields_to_replace` moved due to this implicit call to `.into_iter()`\n...\n51  |                 item_union.fields.named = item_union.fields.named.into_iter().filter(|f| !fields_to_replace.contains(f)).collect();\n    |                                                                                      ^^^  ----------------- borrow occurs due to use in closure\n    |                                                                                      |\n    |                                                                                      value borrowed here after move\n    |\nnote: `into_iter` takes ownership of the receiver `self`, which moves `fields_to_replace`\n   --> C:\\Users\\love\\.rustup\\toolchains\\nightly-2025-05-10-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\iter\\traits\\collect.rs:313:18\n    |\n313 |     fn into_iter(self) -> Self::IntoIter;\n    |                  ^^^^\nhelp: consider iterating over a slice of the `Vec<syn::Field>`'s content to avoid moving into the `for` loop\n    |\n44  |                 for field in &fields_to_replace {\n    |                              +\n\nSome errors have detailed explanations: E0382, E0507.\nFor more information about an error, try `rustc --explain E0382`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Zero_Sized_Array_In_Union_320_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:26:29\n   |\n26 |                         ty: parse_quote!([u8; 1]),\n   |                             ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Union(item_union) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:14:28\n   |\n14 |                     if let Type::Array(type_array) = &field.ty {\n   |                            ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:15:32\n   |\n15 |                         if let Expr::Lit(expr_lit) = &type_array.len {\n   |                                ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nFor more information about this error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Zero_Sized_Array_In_Union_320_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Zero_Sized_Array_In_Union_320 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\zero_sized_array_in_union_320.rs"
    },
    {
        "mutator_name": "Alter_Const_Generics_Default_Values_449",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Alter_Const_Generics_Default_Values_449_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.80s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:35:40:\nexpected one of: `for`, parentheses, `fn`, `unsafe`, `extern`, identifier, `::`, `<`, `dyn`, square brackets, `*`, `&`, `!`, `impl`, `_`, lifetime\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Const_Generics_Default_Values_449_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.20s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:27:36:\nexpected one of: `for`, parentheses, `fn`, `unsafe`, `extern`, identifier, `::`, `<`, `dyn`, square brackets, `*`, `&`, `!`, `impl`, `_`, lifetime\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Const_Generics_Default_Values_449_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.97s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:27:36:\nexpected one of: `for`, parentheses, `fn`, `unsafe`, `extern`, identifier, `::`, `<`, `dyn`, square brackets, `*`, `&`, `!`, `impl`, `_`, lifetime\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Const_Generics_Default_Values_449_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:12:36\n   |\n12 |                         *default = parse_quote!({ let x: #default = Default::default(); x });\n   |                                    ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:3:6\n  |\n3 | impl Mutator for Alter_Const_Generics_Default_Values_449 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n --> src\\main.rs:9:20\n  |\n9 |             if let Item::Struct(item_struct) = item {\n  |                    ^^^^ use of undeclared type `Item`\n  |\nhelp: consider importing this enum\n  |\n1 + use syn::Item;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericParam`\n  --> src\\main.rs:10:29\n   |\n10 |                 if let Some(GenericParam::Const(const_param)) = item_struct.generics.params.first_mut() {\n   |                             ^^^^^^^^^^^^ use of undeclared type `GenericParam`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nSome errors have detailed explanations: E0405, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Const_Generics_Default_Values_449_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.73s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:17:36:\nexpected one of: `for`, parentheses, `fn`, `unsafe`, `extern`, identifier, `::`, `<`, `dyn`, square brackets, `*`, `&`, `!`, `impl`, `_`, lifetime\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Const_Generics_Default_Values_449_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.71s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:18:46:\nexpected one of: `for`, parentheses, `fn`, `unsafe`, `extern`, identifier, `::`, `<`, `dyn`, square brackets, `*`, `&`, `!`, `impl`, `_`, lifetime\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Alter_Const_Generics_Default_Values_449_compling_err_7.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.70s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:16:46:\nexpected one of: `for`, parentheses, `fn`, `unsafe`, `extern`, identifier, `::`, `<`, `dyn`, square brackets, `*`, `&`, `!`, `impl`, `_`, lifetime\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\alter_const_generics_default_values_449.rs"
    },
    {
        "mutator_name": "Modify_Trait_Constraints_With_Const_Generics_450",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_constraints_with_const_generics_450.rs"
    },
    {
        "mutator_name": "Add_Async_Method_To_Trait_Impl_489",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\add_async_method_to_trait_impl_489.rs"
    },
    {
        "mutator_name": "Add_Conflicting_Attributes_466",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Add_Conflicting_Attributes_466_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0615]: attempted to take value of method `path` on type `&Attribute`\n  --> src\\main.rs:36:38\n   |\n36 |                     let path = &attr.path;\n   |                                      ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n36 |                     let path = &attr.path();\n   |                                          ++\n\nerror[E0061]: this enum variant takes 2 arguments but 1 argument was supplied\n  --> src\\main.rs:65:47\n   |\n65 |                         func.block.stmts.push(Stmt::Expr(call_expr));\n   |                                               ^^^^^^^^^^----------- argument #2 of type `Option<Semi>` is missing\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:9\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |         ^^^^\nhelp: provide the argument\n   |\n65 |                         func.block.stmts.push(Stmt::Expr(call_expr, /* Option<Semi> */));\n   |                                                                   ++++++++++++++++++++\n\nSome errors have detailed explanations: E0061, E0615.\nFor more information about an error, try `rustc --explain E0061`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\add_conflicting_attributes_466.rs"
    },
    {
        "mutator_name": "Adjust_Lifetime_Parameters_In_Trait_Implementations_488",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Adjust_Lifetime_Parameters_In_Trait_Implementations_488_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `syn::TraitItem` in the current scope\n  --> src\\main.rs:35:39\n   |\n35 |                     if let TraitItem::Method(method) = trait_item {\n   |                                       ^^^^^^ variant or associated item not found in `syn::TraitItem`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\adjust_lifetime_parameters_in_trait_implementations_488.rs"
    },
    {
        "mutator_name": "Attribute_Macro_With_Undefined_Macro_460",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Attribute_Macro_With_Undefined_Macro_460_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 3.34s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:45:40:\nunexpected token, expected `]`\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\attribute_macro_with_undefined_macro_460.rs"
    },
    {
        "mutator_name": "Convert_Async_Closure_To_Block_472",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Convert_Async_Closure_To_Block_472_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0609]: no field `stmts` on type `std::boxed::Box<syn::Expr>`\n  --> src\\main.rs:41:53\n   |\n41 | ...                   stmts: closure.body.stmts.clone(),\n   |                                           ^^^^^ unknown field\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Convert_Async_Closure_To_Block_472_compling_err_2.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0061]: this enum variant takes 2 arguments but 1 argument was supplied\n  --> src\\main.rs:41:45\n   |\n41 | ...                   stmts: vec![syn::Stmt::Expr(*closure.body.clone())],\n   |                                   ^^^^^^^^^^^^^^^----------------------- argument #2 of type `Option<Semi>` is missing\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:9\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |         ^^^^\nhelp: provide the argument\n   |\n41 |                                 stmts: vec![syn::Stmt::Expr(*closure.body.clone(), /* Option<Semi> */)],\n   |                                                                                  ++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0061`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\convert_async_closure_to_block_472.rs"
    },
    {
        "mutator_name": "Convert_Inner_To_Outer_Attribute_480",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Convert_Inner_To_Outer_Attribute_480_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: `proc_macro2::TokenTree` is not an iterator\n   --> src\\main.rs:34:43\n    |\n34  |                     let mut iter = tokens.into_iter().peekable();\n    |                                           ^^^^^^^^^ `proc_macro2::TokenTree` is not an iterator\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.92\\src\\lib.rs:571:1\n    |\n571 | pub enum TokenTree {\n    | ------------------ doesn't satisfy `proc_macro2::TokenTree: IntoIterator` or `proc_macro2::TokenTree: Iterator`\n    |\n    = note: the following trait bounds were not satisfied:\n            `proc_macro2::TokenTree: Iterator`\n            which is required by `proc_macro2::TokenTree: IntoIterator`\n            `&proc_macro2::TokenTree: Iterator`\n            which is required by `&proc_macro2::TokenTree: IntoIterator`\n            `&mut proc_macro2::TokenTree: Iterator`\n            which is required by `&mut proc_macro2::TokenTree: IntoIterator`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\convert_inner_to_outer_attribute_480.rs"
    },
    {
        "mutator_name": "Inline_Const_Expr_In_Global_Asm_497",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\inline_const_expr_in_global_asm_497.rs"
    },
    {
        "mutator_name": "Misuse_BuiltIn_Attributes_457",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Misuse_BuiltIn_Attributes_457_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0615]: attempted to take value of method `path` on type `&Attribute`\n  --> src\\main.rs:33:29\n   |\n33 |                     if attr.path.is_ident(\"inline\") {\n   |                             ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n33 |                     if attr.path().is_ident(\"inline\") {\n   |                                 ++\n\nFor more information about this error, try `rustc --explain E0615`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Misuse_BuiltIn_Attributes_457_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:14:56\n   |\n14 |                         let new_attr: syn::Attribute = parse_quote!(#[inline::always]);\n   |                                                        ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Misuse_BuiltIn_Attributes_457_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Misuse_BuiltIn_Attributes_457 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Misuse_BuiltIn_Attributes_457_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0615]: attempted to take value of method `path` on type `&Attribute`\n  --> src\\main.rs:14:29\n   |\n14 |                     if attr.path.is_ident(\"inline\") {\n   |                             ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n14 |                     if attr.path().is_ident(\"inline\") {\n   |                                 ++\n\nFor more information about this error, try `rustc --explain E0615`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\misuse_builtin_attributes_457.rs"
    },
    {
        "mutator_name": "Modify_Allocator_Api_Usage_453",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Allocator_Api_Usage_453_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:36:43\n   |\n36 |                         if let Stmt::Expr(Expr::ForLoop(for_loop)) = stmt {\n   |                                           ^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n36 |                         if let Stmt::Expr(Expr::ForLoop(for_loop), _) = stmt {\n   |                                                                  +++\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:42:59\n   |\n42 | ...                   if let Stmt::Expr(Expr::Assign(assign)) = stmt {\n   |                                         ^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n42 |                                         if let Stmt::Expr(Expr::Assign(assign), _) = stmt {\n   |                                                                               +++\n\nerror[E0061]: this enum variant takes 2 arguments but 1 argument was supplied\n  --> src\\main.rs:50:82\n   |\n50 | ...                   new_for_loop.body.stmts.push(Stmt::Expr(new_expr));\n   |                                                    ^^^^^^^^^^---------- argument #2 of type `Option<Semi>` is missing\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:9\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |         ^^^^\nhelp: provide the argument\n   |\n50 |                                                     new_for_loop.body.stmts.push(Stmt::Expr(new_expr, /* Option<Semi> */));\n   |                                                                                                     ++++++++++++++++++++\n\nerror[E0061]: this enum variant takes 2 arguments but 1 argument was supplied\n  --> src\\main.rs:56:52\n   |\n56 | ...                   new_stmts.push(Stmt::Expr(Expr::ForLoop(new_for_loop)));\n   |                                      ^^^^^^^^^^----------------------------- argument #2 of type `Option<Semi>` is missing\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:9\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |         ^^^^\nhelp: provide the argument\n   |\n56 |                                     new_stmts.push(Stmt::Expr(Expr::ForLoop(new_for_loop), /* Option<Semi> */));\n   |                                                                                          ++++++++++++++++++++\n\nSome errors have detailed explanations: E0023, E0061.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_allocator_api_usage_453.rs"
    },
    {
        "mutator_name": "Modify_Associated_Type_Bounds_481",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_associated_type_bounds_481.rs"
    },
    {
        "mutator_name": "Modify_Attribute_In_Structs_456",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_attribute_in_structs_456.rs"
    },
    {
        "mutator_name": "Modify_Box_Init_With_System_Allocator_455",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Box_Init_With_System_Allocator_455_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: `UseTree` is not an iterator\n   --> src\\main.rs:34:63\n    |\n34  |                   if let Some(use_tree) = use_item.tree.clone().into_iter().next() {\n    |                                                                 ^^^^^^^^^ `UseTree` is not an iterator\n    |\n   ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\item.rs:424:1\n    |\n424 | / ast_enum_of_structs! {\n425 | |     /// A suffix of an import tree in a `use` item: `Type as Renamed` or `*`.\n426 | |     ///\n427 | |     /// # Syntax tree enum\n...   |\n449 | | }\n    | |_- doesn't satisfy `UseTree: IntoIterator` or `UseTree: Iterator`\n    |\n    = note: the following trait bounds were not satisfied:\n            `UseTree: Iterator`\n            which is required by `UseTree: IntoIterator`\n            `&UseTree: Iterator`\n            which is required by `&UseTree: IntoIterator`\n            `&mut UseTree: Iterator`\n            which is required by `&mut UseTree: IntoIterator`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:61:37\n   |\n61 |                         if let Some((_, expr)) = &local.init {\n   |                                     ^^^^^^^^^    ----------- this expression has type `&Option<LocalInit>`\n   |                                     |\n   |                                     expected `LocalInit`, found `(_, _)`\n   |\n   = note: expected struct `LocalInit`\n               found tuple `(_, _)`\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Box_Init_With_System_Allocator_455_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0609]: no field `1` on type `&LocalInit`\n  --> src\\main.rs:65:67\n   |\n65 | ...                   if let Expr::Call(expr_call) = &*init.1 {\n   |                                                             ^ unknown field\n   |\n   = note: available fields are: `eq_token`, `expr`, `diverge`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Box_Init_With_System_Allocator_455_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:64:37\n   |\n64 |                         if let Some((_, init_expr)) = &local.init {\n   |                                     ^^^^^^^^^^^^^^    ----------- this expression has type `&Option<LocalInit>`\n   |                                     |\n   |                                     expected `LocalInit`, found `(_, _)`\n   |\n   = note: expected struct `LocalInit`\n               found tuple `(_, _)`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Box_Init_With_System_Allocator_455_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `expr_call.args` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:72:53\n   |\n72 | ...                   expr_call.args.pop();\n   |                       ^^^^^^^^^^^^^^ `expr_call` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nerror[E0596]: cannot borrow `expr_call.args` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:73:53\n   |\n73 | ...                   expr_call.args.push(new_expr);\n   |                       ^^^^^^^^^^^^^^ `expr_call` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_box_init_with_system_allocator_455.rs"
    },
    {
        "mutator_name": "Modify_Box_New_In_With_Mutable_Refs_451",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_box_new_in_with_mutable_refs_451.rs"
    },
    {
        "mutator_name": "Modify_Cfg_Attributes_458",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Cfg_Attributes_458_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:32:24\n   |\n32 |                 if let Some(attrs) = &mut func.attrs {\n   |                        ^^^^^^^^^^^   --------------- this expression has type `&mut Vec<Attribute>`\n   |                        |\n   |                        expected `Vec<Attribute>`, found `Option<_>`\n   |\n   = note: expected struct `Vec<Attribute>`\n                found enum `Option<_>`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Cfg_Attributes_458_compling_err_2.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0615]: attempted to take value of method `path` on type `&mut Attribute`\n  --> src\\main.rs:33:29\n   |\n33 |                     if attr.path.is_ident(\"cfg\") {\n   |                             ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n33 |                     if attr.path().is_ident(\"cfg\") {\n   |                                 ++\n\nerror[E0599]: no method named `parse_meta` found for mutable reference `&mut Attribute` in the current scope\n   --> src\\main.rs:34:65\n    |\n34  |                         if let Ok(Meta::List(meta_list)) = attr.parse_meta() {\n    |                                                                 ^^^^^^^^^^\n    |\nhelp: there is a method `parse_nested_meta` with a similar name, but with different arguments\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\attr.rs:391:5\n    |\n391 | /     pub fn parse_nested_meta(\n392 | |         &self,\n393 | |         logic: impl FnMut(ParseNestedMeta) -> Result<()>,\n394 | |     ) -> Result<()> {\n    | |___________________^\n\nerror[E0609]: no field `tokens` on type `&mut Attribute`\n  --> src\\main.rs:37:34\n   |\n37 | ...                   attr.tokens = new_tokens;\n   |                            ^^^^^^ unknown field\n   |\n   = note: available fields are: `pound_token`, `style`, `bracket_token`, `meta`\n\nSome errors have detailed explanations: E0599, E0609, E0615.\nFor more information about an error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Cfg_Attributes_458_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0560]: struct `MetaList` has no field named `paren_token`\n  --> src\\main.rs:39:33\n   |\n39 | ...                   paren_token: meta_list.paren_token,\n   |                       ^^^^^^^^^^^ `MetaList` does not have this field\n   |\n   = note: available fields are: `delimiter`, `tokens`\n\nerror[E0609]: no field `paren_token` on type `&MetaList`\n  --> src\\main.rs:39:56\n   |\n39 | ...                   paren_token: meta_list.paren_token,\n   |                                              ^^^^^^^^^^^ unknown field\n   |\n   = note: available fields are: `path`, `delimiter`, `tokens`\n\nerror[E0560]: struct `MetaList` has no field named `nested`\n  --> src\\main.rs:40:33\n   |\n40 | ...                   nested: syn::punctuated::Punctuated::new(),\n   |                       ^^^^^^ `MetaList` does not have this field\n   |\n   = note: available fields are: `delimiter`, `tokens`\n\nSome errors have detailed explanations: E0560, E0609.\nFor more information about an error, try `rustc --explain E0560`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_cfg_attributes_458.rs"
    },
    {
        "mutator_name": "Modify_Const_Block_With_Intrinsic_Function_496",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Block_With_Intrinsic_Function_496_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:34:36\n   |\n34 |                         init: Some((_, expr)),\n   |                                    ^^^^^^^^^ expected `LocalInit`, found `(_, _)`\n35 |                         ..\n36 |                     }) = stmt\n   |                          ---- this expression has type `&mut Stmt`\n   |\n   = note: expected struct `LocalInit`\n               found tuple `(_, _)`\n\nerror[E0599]: no variant or associated item named `Semi` found for enum `Stmt` in the current scope\n  --> src\\main.rs:40:46\n   |\n40 | ...                   if let Stmt::Semi(Expr::Path(expr_path), _) = stmt {\n   |                                    ^^^^ variant or associated item not found in `Stmt`\n\nerror[E0599]: no variant or associated item named `Semi` found for enum `Stmt` in the current scope\n  --> src\\main.rs:46:59\n   |\n46 | ...                   *stmt = Stmt::Semi(new_expr, token::Semi::default());\n   |                                     ^^^^ variant or associated item not found in `Stmt`\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Block_With_Intrinsic_Function_496_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:40:51\n   |\n40 | ...                   if let Stmt::Expr(Expr::Path(expr_path)) = stmt {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n40 |                                 if let Stmt::Expr(Expr::Path(expr_path), _) = stmt {\n   |                                                                        +++\n\nerror[E0061]: this enum variant takes 2 arguments but 1 argument was supplied\n  --> src\\main.rs:46:53\n   |\n46 | ...                   *stmt = Stmt::Expr(new_expr);\n   |                               ^^^^^^^^^^---------- argument #2 of type `Option<Semi>` is missing\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:9\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |         ^^^^\nhelp: provide the argument\n   |\n46 |                                             *stmt = Stmt::Expr(new_expr, /* Option<Semi> */);\n   |                                                                        ++++++++++++++++++++\n\nSome errors have detailed explanations: E0023, E0061.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Block_With_Intrinsic_Function_496_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:23:66\n   |\n23 | ...                   let new_expr: Expr = parse_quote! {\n   |                                            ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:13:28\n   |\n13 |                     if let Stmt::Local(Local {\n   |                            ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `Local` in this scope\n  --> src\\main.rs:13:40\n   |\n13 |                     if let Stmt::Local(Local {\n   |                                        ^^^^^ not found in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Local;\n   |\n1  + use syn::Stmt::Local;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `LocalInit` in this scope\n  --> src\\main.rs:14:36\n   |\n14 |                         init: Some(LocalInit { expr, .. }),\n   |                                    ^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::LocalInit;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:18:32\n   |\n18 |                         if let Expr::Block(expr_block) = &**expr {\n   |                                ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:20:40\n   |\n20 | ...                   if let Stmt::Expr(Expr::Path(expr_path), _) = stmt {\n   |                              ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:20:51\n   |\n20 | ...                   if let Stmt::Expr(Expr::Path(expr_path), _) = stmt {\n   |                                         ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0412]: cannot find type `Expr` in this scope\n  --> src\\main.rs:23:59\n   |\n23 | ...                   let new_expr: Expr = parse_quote! {\n   |                                     ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:26:53\n   |\n26 | ...                   *stmt = Stmt::Expr(new_expr, None);\n   |                               ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nSome errors have detailed explanations: E0412, E0422, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 9 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Block_With_Intrinsic_Function_496_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Modify_Const_Block_With_Intrinsic_Function_496 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Block_With_Intrinsic_Function_496_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:21:51\n   |\n21 | ...                   if let Stmt::Expr(Expr::Path(expr_path)) = stmt {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n21 |                                 if let Stmt::Expr(Expr::Path(expr_path), _) = stmt {\n   |                                                                        +++\n\nerror[E0061]: this enum variant takes 2 arguments but 1 argument was supplied\n  --> src\\main.rs:27:53\n   |\n27 | ...                   *stmt = Stmt::Expr(new_expr);\n   |                               ^^^^^^^^^^---------- argument #2 of type `Option<Semi>` is missing\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:9\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |         ^^^^\nhelp: provide the argument\n   |\n27 |                                             *stmt = Stmt::Expr(new_expr, /* Option<Semi> */);\n   |                                                                        ++++++++++++++++++++\n\nSome errors have detailed explanations: E0023, E0061.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Block_With_Intrinsic_Function_496_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0596]: cannot borrow `expr_block.block.stmts` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:20:41\n   |\n20 | ...                   for stmt in &mut expr_block.block.stmts {\n   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ `expr_block` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Const_Block_With_Intrinsic_Function_496_compling_err_7.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:21:51\n   |\n21 | ...                   if let Stmt::Expr(Expr::Path(expr_path)) = stmt {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n21 |                                 if let Stmt::Expr(Expr::Path(expr_path), _) = stmt {\n   |                                                                        +++\n\nerror[E0061]: this enum variant takes 2 arguments but 1 argument was supplied\n  --> src\\main.rs:27:53\n   |\n27 | ...                   *stmt = Stmt::Expr(new_expr);\n   |                               ^^^^^^^^^^---------- argument #2 of type `Option<Semi>` is missing\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:9\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |         ^^^^\nhelp: provide the argument\n   |\n27 |                                             *stmt = Stmt::Expr(new_expr, /* Option<Semi> */);\n   |                                                                        ++++++++++++++++++++\n\nSome errors have detailed explanations: E0023, E0061.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_const_block_with_intrinsic_function_496.rs"
    },
    {
        "mutator_name": "Modify_Const_Generic_Expr_483",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [],
        "label": "Negative",
        "file": ".\\mutators\\modify_const_generic_expr_483.rs"
    },
    {
        "mutator_name": "Modify_Macro_Definition_With_Undefined_Const_468",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Macro_Definition_With_Undefined_Const_468_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: could not find `MacroRule` in `syn`\n  --> src\\main.rs:33:33\n   |\n33 |                     if let syn::MacroRule::TokenTree(tt) = &mut rule.tts {\n   |                                 ^^^^^^^^^ could not find `MacroRule` in `syn`\n\nerror[E0599]: no variant or associated item named `MacroRules` found for enum `syn::Item` in the current scope\n  --> src\\main.rs:31:26\n   |\n31 |             if let Item::MacroRules(mac) = item {\n   |                          ^^^^^^^^^^ variant or associated item not found in `syn::Item`\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Macro_Definition_With_Undefined_Const_468_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:32:29\n   |\n32 |                 if let Some((_, ref mut tts)) = mac.mac.tokens.clone().into_iter().next() {\n   |                             ^^^^^^^^^^^^^^^^    ----------------------------------------- this expression has type `Option<proc_macro2::TokenTree>`\n   |                             |\n   |                             expected `TokenTree`, found `(_, _)`\n   |\n   = note: expected enum `proc_macro2::TokenTree`\n             found tuple `(_, _)`\n\nerror[E0614]: type `proc_macro2::TokenTree` cannot be dereferenced\n  --> src\\main.rs:36:29\n   |\n36 | ...                   *tt = TokenTree::Ident(undefined_const);\n   |                       ^^^ can't be dereferenced\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_macro_definition_with_undefined_const_468.rs"
    },
    {
        "mutator_name": "Modify_ProcMacro_Param_Type_477",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_ProcMacro_Param_Type_477_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0615]: attempted to take value of method `path` on type `&Attribute`\n  --> src\\main.rs:34:57\n   |\n34 |                 if item_fn.attrs.iter().any(|attr| attr.path.is_ident(\"proc_macro_attribute\")) {\n   |                                                         ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n34 |                 if item_fn.attrs.iter().any(|attr| attr.path().is_ident(\"proc_macro_attribute\")) {\n   |                                                             ++\n\nFor more information about this error, try `rustc --explain E0615`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_ProcMacro_Param_Type_477_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0499]: cannot borrow `file.items` as mutable more than once at a time\n  --> src\\main.rs:39:25\n   |\n32 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     first mutable borrow occurs here\n   |                     first borrow later used here\n...\n39 |                         file.items.insert(0, Item::Struct(custom_type));\n   |                         ^^^^^^^^^^ second mutable borrow occurs here\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_ProcMacro_Param_Type_477_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:17:55\n   |\n17 |                         let custom_type: ItemStruct = parse_quote! {\n   |                                                       ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:30:47\n   |\n30 | ...                   path: parse_quote!(MyCustomType),\n   |                             ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0412]: cannot find type `ItemStruct` in this scope\n  --> src\\main.rs:17:42\n   |\n17 |                         let custom_type: ItemStruct = parse_quote! {\n   |                                          ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::ItemStruct;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:20:46\n   |\n20 |                         items_to_insert.push(Item::Struct(custom_type));\n   |                                              ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `FnArg`\n  --> src\\main.rs:25:32\n   |\n25 |                         if let FnArg::Typed(pat_type) = input {\n   |                                ^^^^^ use of undeclared type `FnArg`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::FnArg;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:26:36\n   |\n26 | ...                   if let Type::Path(type_path) = &*pat_type.ty {\n   |                              ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:28:60\n   |\n28 | ...                   pat_type.ty = Box::new(Type::Path(TypePath {\n   |                                              ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypePath` in this scope\n  --> src\\main.rs:28:71\n   |\n28 | ...                   pat_type.ty = Box::new(Type::Path(TypePath {\n   |                                                         ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypePath;\n   |\n\nSome errors have detailed explanations: E0412, E0422, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 8 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_ProcMacro_Param_Type_477_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Modify_ProcMacro_Param_Type_477 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_ProcMacro_Param_Type_477_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0615]: attempted to take value of method `path` on type `&Attribute`\n  --> src\\main.rs:16:57\n   |\n16 |                 if item_fn.attrs.iter().any(|attr| attr.path.is_ident(\"proc_macro_attribute\")) {\n   |                                                         ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n16 |                 if item_fn.attrs.iter().any(|attr| attr.path().is_ident(\"proc_macro_attribute\")) {\n   |                                                             ++\n\nFor more information about this error, try `rustc --explain E0615`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_procmacro_param_type_477.rs"
    },
    {
        "mutator_name": "Modify_RefCell_Borrow_Usage_462",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_refcell_borrow_usage_462.rs"
    },
    {
        "mutator_name": "Modify_Return_Type_With_Undefined_Type_498",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_return_type_with_undefined_type_498.rs"
    },
    {
        "mutator_name": "Modify_Static_Init_With_Drop_464",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Static_Init_With_Drop_464_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:36:41\n   |\n36 | ...                   if let Some((_, expr)) = &local.init {\n   |                                   ^^^^^^^^^    ----------- this expression has type `&Option<LocalInit>`\n   |                                   |\n   |                                   expected `LocalInit`, found `(_, _)`\n   |\n   = note: expected struct `LocalInit`\n               found tuple `(_, _)`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Static_Init_With_Drop_464_compling_err_2.rs",
                "errors": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:18:58\n   |\n18 | ...                   let new_stmt: Stmt = parse_quote! {\n   |                                            ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Static(static_item) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:12:24\n   |\n12 |                 if let Expr::Block(expr_block) = &mut *static_item.expr {\n   |                        ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:15:32\n   |\n15 |                         if let Stmt::Local(local) = stmt {\n   |                                ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:17:40\n   |\n17 | ...                   if let Expr::Array(_) | Expr::Call(_) = &*init.expr {\n   |                              ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:17:57\n   |\n17 | ...                   if let Expr::Array(_) | Expr::Call(_) = &*init.expr {\n   |                                               ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0412]: cannot find type `Stmt` in this scope\n  --> src\\main.rs:18:51\n   |\n18 | ...                   let new_stmt: Stmt = parse_quote! {\n   |                                     ^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 7 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Static_Init_With_Drop_464_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Modify_Static_Init_With_Drop_464 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Static_Init_With_Drop_464_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:17:41\n   |\n17 | ...                   if let Some((_, init)) = &local.init {\n   |                                   ^^^^^^^^^    ----------- this expression has type `&Option<LocalInit>`\n   |                                   |\n   |                                   expected `LocalInit`, found `(_, _)`\n   |\n   = note: expected struct `LocalInit`\n               found tuple `(_, _)`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\modify_static_init_with_drop_464.rs"
    },
    {
        "mutator_name": "Modify_Trait_Associated_Type_Bounds_485",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Associated_Type_Bounds_485_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:34:32\n   |\n34 |                         if let Some(bounds) = &mut type_item.bounds {\n   |                                ^^^^^^^^^^^^   --------------------- this expression has type `&mut syn::punctuated::Punctuated<TypeParamBound, syn::token::Plus>`\n   |                                |\n   |                                expected `Punctuated<TypeParamBound, Plus>`, found `Option<_>`\n   |\n   = note: expected struct `syn::punctuated::Punctuated<TypeParamBound, syn::token::Plus>`\n                found enum `Option<_>`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_associated_type_bounds_485.rs"
    },
    {
        "mutator_name": "Modify_Trait_Fn_Align_459",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Fn_Align_459_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0615]: attempted to take value of method `path` on type `&mut Attribute`\n  --> src\\main.rs:36:37\n   |\n36 | ...                   if attr.path.is_ident(\"repr\") {\n   |                               ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n36 |                             if attr.path().is_ident(\"repr\") {\n   |                                         ++\n\nerror[E0599]: no method named `parse_meta` found for mutable reference `&mut Attribute` in the current scope\n   --> src\\main.rs:37:73\n    |\n37  | ...                   if let Ok(Meta::List(meta_list)) = attr.parse_meta() {\n    |                                                               ^^^^^^^^^^\n    |\nhelp: there is a method `parse_nested_meta` with a similar name, but with different arguments\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\attr.rs:391:5\n    |\n391 | /     pub fn parse_nested_meta(\n392 | |         &self,\n393 | |         logic: impl FnMut(ParseNestedMeta) -> Result<()>,\n394 | |     ) -> Result<()> {\n    | |___________________^\n\nerror[E0609]: no field `nested` on type `MetaList`\n  --> src\\main.rs:38:50\n   |\n38 | ...                   if meta_list.nested.iter().any(|nested| {\n   |                                    ^^^^^^ unknown field\n   |\n   = note: available fields are: `path`, `delimiter`, `tokens`\n\nerror[E0433]: failed to resolve: use of undeclared type `NestedMeta`\n  --> src\\main.rs:39:48\n   |\n39 | ...                   if let NestedMeta::Meta(Meta::Path(path)) = nested {\n   |                              ^^^^^^^^^^ use of undeclared type `NestedMeta`\n\nSome errors have detailed explanations: E0433, E0599, E0609, E0615.\nFor more information about an error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Fn_Align_459_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `parse_meta` found for mutable reference `&mut Attribute` in the current scope\n   --> src\\main.rs:37:73\n    |\n37  | ...                   if let Ok(Meta::List(meta_list)) = attr.parse_meta() {\n    |                                                               ^^^^^^^^^^\n    |\nhelp: there is a method `parse_nested_meta` with a similar name, but with different arguments\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\attr.rs:391:5\n    |\n391 | /     pub fn parse_nested_meta(\n392 | |         &self,\n393 | |         logic: impl FnMut(ParseNestedMeta) -> Result<()>,\n394 | |     ) -> Result<()> {\n    | |___________________^\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Fn_Align_459_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:24:48\n   |\n24 | ...                   fn_item.attrs.push(parse_quote!(#[repr(align)]));\n   |                                          ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:3:6\n  |\n3 | impl Mutator for Modify_Trait_Fn_Align_459 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n --> src\\main.rs:9:20\n  |\n9 |             if let Item::Trait(trait_item) = item {\n  |                    ^^^^ use of undeclared type `Item`\n  |\nhelp: consider importing this enum\n  |\n1 + use syn::Item;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `TraitItem`\n  --> src\\main.rs:11:28\n   |\n11 |                     if let TraitItem::Fn(fn_item) = item {\n   |                            ^^^^^^^^^ use of undeclared type `TraitItem`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TraitItem;\n   |\n\nSome errors have detailed explanations: E0405, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_fn_align_459.rs"
    },
    {
        "mutator_name": "Modify_Trait_Function_Lifetime_473",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Function_Lifetime_473_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `contains` found for struct `syn::punctuated::Punctuated` in the current scope\n  --> src\\main.rs:39:59\n   |\n39 | ...                   if !lifetime_param.bounds.contains(&constraint) {\n   |                                                 ^^^^^^^^ method not found in `syn::punctuated::Punctuated<syn::Lifetime, syn::token::Plus>`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Function_Lifetime_473_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.59s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:38:50:\nexpected lifetime\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Function_Lifetime_473_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.08s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:38:60:\nexpected lifetime\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Function_Lifetime_473_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.88s\n     Running `target\\debug\\test_frame.exe`\n\nthread 'main' panicked at src\\main.rs:38:65:\nexpected lifetime\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn't exit successfully: `target\\debug\\test_frame.exe` (exit code: 101)\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_function_lifetime_473.rs"
    },
    {
        "mutator_name": "Modify_Trait_Impl_With_Recursive_Async_492",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Impl_With_Recursive_Async_492_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0061]: this enum variant takes 2 arguments but 1 argument was supplied\n  --> src\\main.rs:39:53\n   |\n39 | ...                   method.block.stmts.push(Stmt::Expr(recursive_call));\n   |                                               ^^^^^^^^^^---------------- argument #2 of type `Option<Semi>` is missing\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:9\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |         ^^^^\nhelp: provide the argument\n   |\n39 |                             method.block.stmts.push(Stmt::Expr(recursive_call, /* Option<Semi> */));\n   |                                                                              ++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0061`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_impl_with_recursive_async_492.rs"
    },
    {
        "mutator_name": "Modify_Trait_Method_Signature_487",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Method_Signature_487_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `TraitItem` in the current scope\n  --> src\\main.rs:33:44\n   |\n33 |                     if let syn::TraitItem::Method(method) = trait_item {\n   |                                            ^^^^^^ variant or associated item not found in `TraitItem`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Method_Signature_487_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0432]: unresolved imports `syn::TraitItemMethod`, `syn::ImplItemMethod`\n --> src\\main.rs:2:47\n  |\n2 |     ItemTrait, TraitItem, ImplItem, ItemImpl, TraitItemMethod, ImplItemMethod,\n  |                                               ^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^ no `ImplItemMethod` in the root\n  |                                               |\n  |                                               no `TraitItemMethod` in the root\n  |\nhelp: a similar name exists in the module\n  |\n2 -     ItemTrait, TraitItem, ImplItem, ItemImpl, TraitItemMethod, ImplItemMethod,\n2 +     ItemTrait, TraitItem, ImplItem, ItemImpl, TraitItemMacro, ImplItemMethod,\n  |\nhelp: a similar name exists in the module\n  |\n2 -     ItemTrait, TraitItem, ImplItem, ItemImpl, TraitItemMethod, ImplItemMethod,\n2 +     ItemTrait, TraitItem, ImplItem, ItemImpl, TraitItemMethod, ImplItemMacro,\n  |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:15:67\n   |\n15 | ...                   let new_generic_param: GenericParam = parse_quote!(T);\n   |                                                             ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror: cannot find macro `parse_quote` in this scope\n  --> src\\main.rs:26:67\n   |\n26 | ...                   let new_generic_param: GenericParam = parse_quote!(T);\n   |                                                             ^^^^^^^^^^^\n   |\nhelp: consider importing this macro\n   |\n1  + use syn::parse_quote;\n   |\n\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Modify_Trait_Method_Signature_487 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nerror[E0412]: cannot find type `Modify_Trait_Method_Signature_487` in this scope\n --> src\\main.rs:5:18\n  |\n5 | impl Mutator for Modify_Trait_Method_Signature_487 {\n  |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Trait(trait_item) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0412]: cannot find type `GenericParam` in this scope\n  --> src\\main.rs:15:52\n   |\n15 | ...                   let new_generic_param: GenericParam = parse_quote!(T);\n   |                                              ^^^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:22:20\n   |\n22 |             if let Item::Impl(impl_item) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0412]: cannot find type `GenericParam` in this scope\n  --> src\\main.rs:26:52\n   |\n26 | ...                   let new_generic_param: GenericParam = parse_quote!(T);\n   |                                              ^^^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericParam;\n   |\n\nerror[E0425]: cannot find value `Modify_Trait_Method_Signature_487` in this scope\n  --> src\\main.rs:60:13\n   |\n60 |             Modify_Trait_Method_Signature_487.mutate(&mut file_ast);\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nSome errors have detailed explanations: E0405, E0412, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 10 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Method_Signature_487_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `TraitItem` in the current scope\n  --> src\\main.rs:21:39\n   |\n21 |                     if let TraitItem::Method(method) = trait_item {\n   |                                       ^^^^^^ variant or associated item not found in `TraitItem`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:32:38\n   |\n32 |                     if let ImplItem::Method(method) = impl_item {\n   |                                      ^^^^^^ variant or associated item not found in `ImplItem`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Method_Signature_487_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0432]: unresolved imports `syn::TraitItemMethod`, `syn::ImplItemMethod`\n --> src\\main.rs:2:80\n  |\n2 |     ItemTrait, TraitItem, ImplItem, ItemImpl, Item, GenericParam, parse_quote, TraitItemMethod, ImplItemMethod,\n  |                                                                                ^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^ no `ImplItemMethod` in the root\n  |                                                                                |\n  |                                                                                no `TraitItemMethod` in the root\n  |\nhelp: a similar name exists in the module\n  |\n2 -     ItemTrait, TraitItem, ImplItem, ItemImpl, Item, GenericParam, parse_quote, TraitItemMethod, ImplItemMethod,\n2 +     ItemTrait, TraitItem, ImplItem, ItemImpl, Item, GenericParam, parse_quote, TraitItemMacro, ImplItemMethod,\n  |\nhelp: a similar name exists in the module\n  |\n2 -     ItemTrait, TraitItem, ImplItem, ItemImpl, Item, GenericParam, parse_quote, TraitItemMethod, ImplItemMethod,\n2 +     ItemTrait, TraitItem, ImplItem, ItemImpl, Item, GenericParam, parse_quote, TraitItemMethod, ImplItemMacro,\n  |\n\nerror[E0599]: no variant or associated item named `Method` found for enum `TraitItem` in the current scope\n  --> src\\main.rs:21:39\n   |\n21 |                     if let TraitItem::Method(method) = trait_item {\n   |                                       ^^^^^^ variant or associated item not found in `TraitItem`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `ImplItem` in the current scope\n  --> src\\main.rs:32:38\n   |\n32 |                     if let ImplItem::Method(method) = impl_item {\n   |                                      ^^^^^^ variant or associated item not found in `ImplItem`\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_method_signature_487.rs"
    },
    {
        "mutator_name": "Modify_Trait_Method_Signature_Include_Non_Existent_Trait_484",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Method_Signature_Include_Non_Existent_Trait_484_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `TraitItem` in the current scope\n  --> src\\main.rs:33:44\n   |\n33 |                     if let syn::TraitItem::Method(method) = trait_item {\n   |                                            ^^^^^^ variant or associated item not found in `TraitItem`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Method_Signature_Include_Non_Existent_Trait_484_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0432]: unresolved import `syn::TraitItemMethod`\n --> src\\main.rs:9:49\n  |\n9 |     PathArguments, ReturnType, Stmt, TraitItem, TraitItemMethod, Type, TypeImplTrait,\n  |                                                 ^^^^^^^^^^^^^^^\n  |                                                 |\n  |                                                 no `TraitItemMethod` in the root\n  |                                                 help: a similar name exists in the module: `TraitItemMacro`\n\nerror[E0599]: no variant or associated item named `Method` found for enum `TraitItem` in the current scope\n  --> src\\main.rs:33:39\n   |\n33 |                     if let TraitItem::Method(TraitItemMethod { sig, .. }) = trait_item {\n   |                                       ^^^^^^ variant or associated item not found in `TraitItem`\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Method_Signature_Include_Non_Existent_Trait_484_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:33:42\n   |\n33 |                     if let TraitItem::Fn(ref mut trait_item_fn) = trait_item {\n   |                                          ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:33:28\n   |\n33 |                     if let TraitItem::Fn(ref mut trait_item_fn) = trait_item {\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n33 -                     if let TraitItem::Fn(ref mut trait_item_fn) = trait_item {\n33 +                     if let TraitItem::Fn(trait_item_fn) = trait_item {\n   |\n\nerror[E0596]: cannot borrow `path.segments` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:36:61\n   |\n36 | ...                   if let Some(last_segment) = path.segments.last_mut() {\n   |                                                   ^^^^^^^^^^^^^ `path` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nerror[E0596]: cannot borrow `path.segments` as mutable, as it is behind a `&` reference\n  --> src\\main.rs:52:65\n   |\n52 | ...                   if let Some(last_segment) = path.segments.last_mut() {\n   |                                                   ^^^^^^^^^^^^^ `path` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Method_Signature_Include_Non_Existent_Trait_484_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: expected `,`\n  --> src\\main.rs:19:108\n   |\n19 | ...                   if let GenericArgument::Type(Type::Path(TypePath { ref mut path: inner_path, .. })) = arg {\n   |                                                               --------               ^\n   |                                                               |\n   |                                                               while parsing the fields for this pattern\n   |\nhelp: the pattern modifiers belong after the `:`\n   |\n19 -                                             if let GenericArgument::Type(Type::Path(TypePath { ref mut path: inner_path, .. })) = arg {\n19 +                                             if let GenericArgument::Type(Type::Path(TypePath { path: ref mut inner_path, .. })) = arg {\n   |\n\nerror: expected `,`\n  --> src\\main.rs:35:112\n   |\n35 | ...                   if let GenericArgument::Type(Type::Path(TypePath { ref mut path: inner_path, .. })) = arg {\n   |                                                               --------               ^\n   |                                                               |\n   |                                                               while parsing the fields for this pattern\n   |\nhelp: the pattern modifiers belong after the `:`\n   |\n35 -                                                 if let GenericArgument::Type(Type::Path(TypePath { ref mut path: inner_path, .. })) = arg {\n35 +                                                 if let GenericArgument::Type(Type::Path(TypePath { path: ref mut inner_path, .. })) = arg {\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src\\main.rs:11:20\n   |\n11 |             if let Item::Trait(item_trait) = item {\n   |                    ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `TraitItem`\n  --> src\\main.rs:13:28\n   |\n13 |                     if let TraitItem::Fn(trait_item_fn) = trait_item {\n   |                            ^^^^^^^^^ use of undeclared type `TraitItem`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::TraitItem;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `ReturnType`\n  --> src\\main.rs:14:32\n   |\n14 |                         if let ReturnType::Type(_, ref mut ty) = trait_item_fn.sig.output {\n   |                                ^^^^^^^^^^ use of undeclared type `ReturnType`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::ReturnType;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:15:36\n   |\n15 | ...                   if let Type::Path(TypePath { ref mut path, .. }) = &mut **ty {\n   |                              ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypePath` in this scope\n  --> src\\main.rs:15:47\n   |\n15 | ...                   if let Type::Path(TypePath { ref mut path, .. }) = &mut **ty {\n   |                                         ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypePath;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `PathArguments`\n  --> src\\main.rs:17:44\n   |\n17 | ...                   if let PathArguments::AngleBracketed(ref mut args) = last_segment.arguments {\n   |                              ^^^^^^^^^^^^^ use of undeclared type `PathArguments`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::PathArguments;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericArgument`\n  --> src\\main.rs:19:52\n   |\n19 | ...                   if let GenericArgument::Type(Type::Path(TypePath { ref mut path: inner_path, .. })) = arg {\n   |                              ^^^^^^^^^^^^^^^ use of undeclared type `GenericArgument`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericArgument;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:19:74\n   |\n19 | ...                   if let GenericArgument::Type(Type::Path(TypePath { ref mut path: inner_path, .. })) = arg {\n   |                                                    ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypePath` in this scope\n  --> src\\main.rs:19:85\n   |\n19 | ...                   if let GenericArgument::Type(Type::Path(TypePath { ref mut path: inner_path, .. })) = arg {\n   |                                                               ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypePath;\n   |\n\nerror[E0425]: cannot find value `inner_path` in this scope\n  --> src\\main.rs:20:78\n   |\n20 | ...                   if let Some(inner_segment) = inner_path.segments.last_mut() {\n   |                                                    ^^^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:21:75\n   |\n21 | ...                   inner_segment.ident = Ident::new(\"UnknownTrait\", Span::call_site());\n   |                                             ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:21:102\n   |\n21 | ...                   inner_segment.ident = Ident::new(\"UnknownTrait\", Span::call_site());\n   |                                                                        ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `FnArg`\n  --> src\\main.rs:30:36\n   |\n30 | ...                   if let FnArg::Typed(pat_type) = input {\n   |                              ^^^^^ use of undeclared type `FnArg`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::FnArg;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:31:40\n   |\n31 | ...                   if let Type::Path(TypePath { ref mut path, .. }) = &mut *pat_type.ty {\n   |                              ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypePath` in this scope\n  --> src\\main.rs:31:51\n   |\n31 | ...                   if let Type::Path(TypePath { ref mut path, .. }) = &mut *pat_type.ty {\n   |                                         ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypePath;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `PathArguments`\n  --> src\\main.rs:33:48\n   |\n33 | ...                   if let PathArguments::AngleBracketed(ref mut args) = last_segment.arguments {\n   |                              ^^^^^^^^^^^^^ use of undeclared type `PathArguments`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::PathArguments;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `GenericArgument`\n  --> src\\main.rs:35:56\n   |\n35 | ...                   if let GenericArgument::Type(Type::Path(TypePath { ref mut path: inner_path, .. })) = arg {\n   |                              ^^^^^^^^^^^^^^^ use of undeclared type `GenericArgument`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::GenericArgument;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Type`\n  --> src\\main.rs:35:78\n   |\n35 | ...                   if let GenericArgument::Type(Type::Path(TypePath { ref mut path: inner_path, .. })) = arg {\n   |                                                    ^^^^ use of undeclared type `Type`\n   |\nhelp: consider importing one of these items\n   |\n1  + use syn::Type;\n   |\n1  + use syn::token::Type;\n   |\n\nerror[E0422]: cannot find struct, variant or union type `TypePath` in this scope\n  --> src\\main.rs:35:89\n   |\n35 | ...                   if let GenericArgument::Type(Type::Path(TypePath { ref mut path: inner_path, .. })) = arg {\n   |                                                               ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  + use syn::TypePath;\n   |\n\nerror[E0425]: cannot find value `inner_path` in this scope\n  --> src\\main.rs:36:82\n   |\n36 | ...                   if let Some(inner_segment) = inner_path.segments.last_mut() {\n   |                                                    ^^^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n  --> src\\main.rs:37:79\n   |\n37 | ...                   inner_segment.ident = Ident::new(\"UnknownTrait\", Span::call_site());\n   |                                             ^^^^^ use of undeclared type `Ident`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use proc_macro2::Ident;\n   |\n1  + use syn::Ident;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n  --> src\\main.rs:37:106\n   |\n37 | ...                   inner_segment.ident = Ident::new(\"UnknownTrait\", Span::call_site());\n   |                                                                        ^^^^ use of undeclared type `Span`\n   |\nhelp: consider importing this struct\n   |\n1  + use proc_macro2::Span;\n   |\n\nSome errors have detailed explanations: E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 24 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Method_Signature_Include_Non_Existent_Trait_484_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:6:6\n  |\n6 | impl Mutator for Modify_Trait_Method_Signature_Include_Non_Existent_Trait_484 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Method_Signature_Include_Non_Existent_Trait_484_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:17:58\n   |\n17 | ...                   if let Type::Path(TypePath { ref mut path, .. }) = &mut **ty {\n   |                                                    ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:17:36\n   |\n17 | ...                   if let Type::Path(TypePath { ref mut path, .. }) = &mut **ty {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n17 -                             if let Type::Path(TypePath { ref mut path, .. }) = &mut **ty {\n17 +                             if let Type::Path(TypePath { path, .. }) = &mut **ty {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:21:102\n   |\n21 | ...                   if let GenericArgument::Type(Type::Path(TypePath { path: ref mut inner_path, .. })) = arg {\n   |                                                                                ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:21:52\n   |\n21 | ...                   if let GenericArgument::Type(Type::Path(TypePath { path: ref mut inner_path, .. })) = arg {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n21 -                                             if let GenericArgument::Type(Type::Path(TypePath { path: ref mut inner_path, .. })) = arg {\n21 +                                             if let GenericArgument::Type(Type::Path(TypePath { path: inner_path, .. })) = arg {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:33:62\n   |\n33 | ...                   if let Type::Path(TypePath { ref mut path, .. }) = &mut *pat_type.ty {\n   |                                                    ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:33:40\n   |\n33 | ...                   if let Type::Path(TypePath { ref mut path, .. }) = &mut *pat_type.ty {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n33 -                                 if let Type::Path(TypePath { ref mut path, .. }) = &mut *pat_type.ty {\n33 +                                 if let Type::Path(TypePath { path, .. }) = &mut *pat_type.ty {\n   |\n\nerror: binding modifiers may only be written when the default binding mode is `move`\n  --> src\\main.rs:37:106\n   |\n37 | ...                   if let GenericArgument::Type(Type::Path(TypePath { path: ref mut inner_path, .. })) = arg {\n   |                                                                                ^^^^^^^ binding modifier not allowed under `ref mut` default binding mode\n   |\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2024/match-ergonomics.html>\nnote: matching on a reference type with a non-reference pattern changes the default binding mode\n  --> src\\main.rs:37:56\n   |\n37 | ...                   if let GenericArgument::Type(Type::Path(TypePath { path: ref mut inner_path, .. })) = arg {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this matches on type `&mut _`\nhelp: remove the unnecessary binding modifier\n   |\n37 -                                                 if let GenericArgument::Type(Type::Path(TypePath { path: ref mut inner_path, .. })) = arg {\n37 +                                                 if let GenericArgument::Type(Type::Path(TypePath { path: inner_path, .. })) = arg {\n   |\n\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_method_signature_include_non_existent_trait_484.rs"
    },
    {
        "mutator_name": "Modify_Trait_Method_Signature_With_Lifetime_490",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Method_Signature_With_Lifetime_490_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `TraitItem` in the current scope\n  --> src\\main.rs:44:44\n   |\n44 |                     if let syn::TraitItem::Method(method) = trait_item {\n   |                                            ^^^^^^ variant or associated item not found in `TraitItem`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Modify_Trait_Method_Signature_With_Lifetime_490_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no variant or associated item named `Method` found for enum `TraitItem` in the current scope\n  --> src\\main.rs:44:44\n   |\n44 |                     if let syn::TraitItem::Method(method) = trait_item {\n   |                                            ^^^^^^ variant or associated item not found in `TraitItem`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_method_signature_with_lifetime_490.rs"
    },
    {
        "mutator_name": "Modify_Trait_Object_Syntax_In_Type_Alias_479",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [],
        "label": "Positive",
        "file": ".\\mutators\\modify_trait_object_syntax_in_type_alias_479.rs"
    },
    {
        "mutator_name": "Negate_Integer_Literals_469",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Negate_Integer_Literals_469_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:36:28\n   |\n36 |                     if let Some(ty) = lit_int.suffix() {\n   |                            ^^^^^^^^   ---------------- this expression has type `&str`\n   |                            |\n   |                            expected `str`, found `Option<_>`\n   |\n   = note: expected type `str`\n              found enum `Option<_>`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\negate_integer_literals_469.rs"
    },
    {
        "mutator_name": "Recursive_Function_Return_Type_Mutation_463",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Recursive_Function_Return_Type_Mutation_463_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:35:47\n   |\n35 | ...                   if let Stmt::Expr(Expr::Call(ExprCall { func, .. })) = stmt {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n35 |                             if let Stmt::Expr(Expr::Call(ExprCall { func, .. }), _) = stmt {\n   |                                                                                +++\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:55:56\n   |\n55 | ...                   token::RArrow { spans: [Span::call_site()] },\n   |                                              ^^^^^^^^^^^^^^^^^^^ expected an array with a size of 2, found one with a size of 1\n   |\n   = note: expected array `[Span; 2]`\n              found array `[Span; 1]`\n\nSome errors have detailed explanations: E0023, E0308.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Recursive_Function_Return_Type_Mutation_463_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0499]: cannot borrow `file.items` as mutable more than once at a time\n  --> src\\main.rs:52:29\n   |\n30 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     first mutable borrow occurs here\n   |                     first borrow later used here\n...\n52 |                             file.items.push(Item::Trait(new_trait));\n   |                             ^^^^^^^^^^ second mutable borrow occurs here\n\nerror[E0499]: cannot borrow `file.items` as mutable more than once at a time\n  --> src\\main.rs:53:29\n   |\n30 |         for item in &mut file.items {\n   |                     ---------------\n   |                     |\n   |                     first mutable borrow occurs here\n   |                     first borrow later used here\n...\n53 |                             file.items.push(Item::Impl(impl_trait));\n   |                             ^^^^^^^^^^ second mutable borrow occurs here\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 2 previous errors\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\recursive_function_return_type_mutation_463.rs"
    },
    {
        "mutator_name": "Replace_Const_Block_With_Conditional_499",
        "compilable": true,
        "mutate_effect": false,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Replace_Const_Block_With_Conditional_499_compling_err_1.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:35:43\n   |\n35 |                         if let Stmt::Expr(Expr::Block(expr_block)) = stmt {\n   |                                           ^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n35 |                         if let Stmt::Expr(Expr::Block(expr_block), _) = stmt {\n   |                                                                  +++\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:37:51\n   |\n37 | ...                   if let Stmt::Expr(Expr::If(expr_if)) = &expr_block.block.stmts[0] {\n   |                                         ^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n37 |                                 if let Stmt::Expr(Expr::If(expr_if), _) = &expr_block.block.stmts[0] {\n   |                                                                    +++\n\nerror[E0061]: this enum variant takes 2 arguments but 1 argument was supplied\n  --> src\\main.rs:38:52\n   |\n38 | ...                   new_stmts.push(Stmt::Expr(Expr::If(expr_if.clone())));\n   |                                      ^^^^^^^^^^--------------------------- argument #2 of type `Option<Semi>` is missing\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:9\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |         ^^^^\nhelp: provide the argument\n   |\n38 |                                     new_stmts.push(Stmt::Expr(Expr::If(expr_if.clone()), /* Option<Semi> */));\n   |                                                                                        ++++++++++++++++++++\n\nSome errors have detailed explanations: E0023, E0061.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Replace_Const_Block_With_Conditional_499_compling_err_2.rs",
                "errors": "    Blocking waiting for file lock on build directory\n   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:15:32\n   |\n15 |                         if let Stmt::Expr(Expr::Block(expr_block), _) = stmt {\n   |                                ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:15:43\n   |\n15 |                         if let Stmt::Expr(Expr::Block(expr_block), _) = stmt {\n   |                                           ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:17:40\n   |\n17 | ...                   if let Stmt::Expr(Expr::If(expr_if), _) = &expr_block.block.stmts[0] {\n   |                              ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:17:51\n   |\n17 | ...                   if let Stmt::Expr(Expr::If(expr_if), _) = &expr_block.block.stmts[0] {\n   |                                         ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Stmt`\n  --> src\\main.rs:18:52\n   |\n18 | ...                   new_stmts.push(Stmt::Expr(Expr::If(expr_if.clone()), None));\n   |                                      ^^^^ use of undeclared type `Stmt`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Stmt;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Expr`\n  --> src\\main.rs:18:63\n   |\n18 | ...                   new_stmts.push(Stmt::Expr(Expr::If(expr_if.clone()), None));\n   |                                                 ^^^^ use of undeclared type `Expr`\n   |\nhelp: consider importing this enum\n   |\n1  + use syn::Expr;\n   |\n\nFor more information about this error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 6 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Replace_Const_Block_With_Conditional_499_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0405]: cannot find trait `Mutator` in this scope\n --> src\\main.rs:5:6\n  |\n5 | impl Mutator for Replace_Const_Block_With_Conditional_499 {\n  |      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this trait\n  |\n1 + use crate::mutator::Mutator;\n  |\n\nFor more information about this error, try `rustc --explain E0405`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Replace_Const_Block_With_Conditional_499_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:16:43\n   |\n16 |                         if let Stmt::Expr(Expr::Block(expr_block)) = stmt {\n   |                                           ^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n16 |                         if let Stmt::Expr(Expr::Block(expr_block), _) = stmt {\n   |                                                                  +++\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n  --> src\\main.rs:18:51\n   |\n18 | ...                   if let Stmt::Expr(Expr::If(expr_if)) = &expr_block.block.stmts[0] {\n   |                                         ^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n   |\n  ::: C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:14\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |              ----  ----------------- tuple variant has 2 fields\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n18 |                                 if let Stmt::Expr(Expr::If(expr_if), _) = &expr_block.block.stmts[0] {\n   |                                                                    +++\n\nerror[E0061]: this enum variant takes 2 arguments but 1 argument was supplied\n  --> src\\main.rs:19:52\n   |\n19 | ...                   new_stmts.push(Stmt::Expr(Expr::If(expr_if.clone())));\n   |                                      ^^^^^^^^^^--------------------------- argument #2 of type `Option<Semi>` is missing\n   |\nnote: tuple variant defined here\n  --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\stmt.rs:29:9\n   |\n29 |         Expr(Expr, Option<Token![;]>),\n   |         ^^^^\nhelp: provide the argument\n   |\n19 |                                     new_stmts.push(Stmt::Expr(Expr::If(expr_if.clone()), /* Option<Semi> */));\n   |                                                                                        ++++++++++++++++++++\n\nSome errors have detailed explanations: E0023, E0061.\nFor more information about an error, try `rustc --explain E0023`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            }
        ],
        "label": "Negative",
        "file": ".\\mutators\\replace_const_block_with_conditional_499.rs"
    },
    {
        "mutator_name": "Replace_Doc_Comment_With_Normal_Comment_476",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Replace_Doc_Comment_With_Normal_Comment_476_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:38:67\n   |\n38 | ...                   bracket_token: token::Bracket { span: Span::call_site() },\n   |                                                             ^^^^^^^^^^^^^^^^^ expected `DelimSpan`, found `Span`\n\nerror[E0560]: struct `Attribute` has no field named `path`\n  --> src\\main.rs:39:29\n   |\n39 | ...                   path: syn::Path::from(Ident::new(\"doc\", Span::call_site())),\n   |                       ^^^^ `Attribute` does not have this field\n   |\n   = note: available fields are: `meta`\n\nerror[E0560]: struct `Attribute` has no field named `tokens`\n  --> src\\main.rs:40:29\n   |\n40 | ...                   tokens: quote! { = #doc_comment },\n   |                       ^^^^^^ `Attribute` does not have this field\n   |\n   = note: available fields are: `meta`\n\nerror[E0599]: no method named `parse_meta` found for reference `&Attribute` in the current scope\n   --> src\\main.rs:57:36\n    |\n57  |             if let Ok(meta) = attr.parse_meta() {\n    |                                    ^^^^^^^^^^\n    |\nhelp: there is a method `parse_nested_meta` with a similar name, but with different arguments\n   --> C:\\Users\\love\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.90\\src\\attr.rs:391:5\n    |\n391 | /     pub fn parse_nested_meta(\n392 | |         &self,\n393 | |         logic: impl FnMut(ParseNestedMeta) -> Result<()>,\n394 | |     ) -> Result<()> {\n    | |___________________^\n\nerror[E0609]: no field `lit` on type `MetaNameValue`\n  --> src\\main.rs:59:56\n   |\n59 |                     if let syn::Lit::Str(lit_str) = nv.lit {\n   |                                                        ^^^ unknown field\n   |\n   = note: available fields are: `path`, `eq_token`, `value`\n\nerror[E0615]: attempted to take value of method `path` on type `&Attribute`\n  --> src\\main.rs:73:10\n   |\n73 |     attr.path.is_ident(\"doc\")\n   |          ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n73 |     attr.path().is_ident(\"doc\")\n   |              ++\n\nSome errors have detailed explanations: E0308, E0560, E0599, E0609, E0615.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 6 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Replace_Doc_Comment_With_Normal_Comment_476_compling_err_2.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `DelimSpan`\n  --> src\\main.rs:38:67\n   |\n38 | ...                   bracket_token: token::Bracket { span: DelimSpan::from_single(Span::call_site()) },\n   |                                                             ^^^^^^^^^ use of undeclared type `DelimSpan`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use crate::extra::DelimSpan;\n   |\n1  + use proc_macro2::extra::DelimSpan;\n   |\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:42:40\n   |\n42 | ...                   value: syn::Lit::Str(syn::LitStr::new(&doc_comment, Span::call_site())),\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Expr`, found `Lit`\n\nerror[E0599]: no method named `meta` found for reference `&Attribute` in the current scope\n  --> src\\main.rs:60:51\n   |\n60 |             if let Ok(Meta::NameValue(nv)) = attr.meta() {\n   |                                                   ^^^^-- help: remove the arguments\n   |                                                   |\n   |                                                   field, not a method\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:61:24\n   |\n61 |                 if let syn::Lit::Str(lit_str) = nv.value {\n   |                        ^^^^^^^^^^^^^^^^^^^^^^   -------- this expression has type `syn::Expr`\n   |                        |\n   |                        expected `Expr`, found `Lit`\n\nSome errors have detailed explanations: E0308, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Replace_Doc_Comment_With_Normal_Comment_476_compling_err_3.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:38:67\n   |\n38 | ...                   bracket_token: token::Bracket { span: Span::call_site() },\n   |                                                             ^^^^^^^^^^^^^^^^^ expected `DelimSpan`, found `Span`\n\nerror[E0560]: struct `MetaNameValue` has no field named `lit`\n  --> src\\main.rs:42:33\n   |\n42 | ...                   lit: syn::Lit::Str(syn::LitStr::new(&doc_comment, Span::call_site())),\n   |                       ^^^ `MetaNameValue` does not have this field\n   |\n   = note: available fields are: `value`\n\nerror[E0609]: no field `lit` on type `&MetaNameValue`\n  --> src\\main.rs:61:53\n   |\n61 |                 if let syn::Lit::Str(lit_str) = &nv.lit {\n   |                                                     ^^^ unknown field\n   |\n   = note: available fields are: `path`, `eq_token`, `value`\n\nerror[E0615]: attempted to take value of method `path` on type `&Attribute`\n  --> src\\main.rs:74:10\n   |\n74 |     attr.path.is_ident(\"doc\")\n   |          ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n74 |     attr.path().is_ident(\"doc\")\n   |              ++\n\nSome errors have detailed explanations: E0308, E0560, E0609, E0615.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 4 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Replace_Doc_Comment_With_Normal_Comment_476_compling_err_4.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `DelimSpan`\n  --> src\\main.rs:38:67\n   |\n38 | ...                   bracket_token: token::Bracket { span: DelimSpan::from_single(Span::call_site()) },\n   |                                                             ^^^^^^^^^ use of undeclared type `DelimSpan`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use crate::extra::DelimSpan;\n   |\n1  + use proc_macro2::extra::DelimSpan;\n   |\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:42:40\n   |\n42 | ...                   value: syn::Lit::Str(syn::LitStr::new(&doc_comment, Span::call_site())),\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Expr`, found `Lit`\n\nerror[E0308]: mismatched types\n  --> src\\main.rs:61:24\n   |\n61 |                 if let syn::Lit::Str(lit_str) = &nv.value {\n   |                        ^^^^^^^^^^^^^^^^^^^^^^   --------- this expression has type `&syn::Expr`\n   |                        |\n   |                        expected `Expr`, found `Lit`\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Replace_Doc_Comment_With_Normal_Comment_476_compling_err_5.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:38:67\n   |\n38 | ...                   bracket_token: token::Bracket { span: Span::call_site() },\n   |                                                             ^^^^^^^^^^^^^^^^^ expected `DelimSpan`, found `Span`\n\nerror[E0560]: struct `MetaNameValue` has no field named `lit`\n  --> src\\main.rs:42:33\n   |\n42 | ...                   lit: syn::Lit::Str(syn::LitStr::new(&doc_comment, Span::call_site())),\n   |                       ^^^ `MetaNameValue` does not have this field\n   |\n   = note: available fields are: `value`\n\nerror[E0609]: no field `lit` on type `&MetaNameValue`\n  --> src\\main.rs:61:53\n   |\n61 |                 if let syn::Lit::Str(lit_str) = &nv.lit {\n   |                                                     ^^^ unknown field\n   |\n   = note: available fields are: `path`, `eq_token`, `value`\n\nSome errors have detailed explanations: E0308, E0560, E0609.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 3 previous errors\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Replace_Doc_Comment_With_Normal_Comment_476_compling_err_6.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0433]: failed to resolve: use of undeclared type `DelimSpan`\n  --> src\\main.rs:38:67\n   |\n38 | ...                   bracket_token: token::Bracket { span: DelimSpan::from_single(Span::call_site()) },\n   |                                                             ^^^^^^^^^ use of undeclared type `DelimSpan`\n   |\nhelp: consider importing one of these structs\n   |\n1  + use crate::extra::DelimSpan;\n   |\n1  + use proc_macro2::extra::DelimSpan;\n   |\n\nFor more information about this error, try `rustc --explain E0433`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            },
            {
                "error_code_file": ".\\mutators_err\\Replace_Doc_Comment_With_Normal_Comment_476_compling_err_7.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0308]: mismatched types\n  --> src\\main.rs:38:67\n   |\n38 | ...                   bracket_token: token::Bracket { span: Span::call_site() },\n   |                                                             ^^^^^^^^^^^^^^^^^ expected `DelimSpan`, found `Span`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\replace_doc_comment_with_normal_comment_476.rs"
    },
    {
        "mutator_name": "Union_Field_Manipulation_474",
        "compilable": true,
        "mutate_effect": true,
        "error_pairs": [
            {
                "error_code_file": ".\\mutators_err\\Union_Field_Manipulation_474_compling_err_1.rs",
                "errors": "   Compiling test_frame v0.1.0 (D:\\rust_test\\gpt_generate_mutators\\test_frame)\nerror[E0599]: no method named `push` found for enum `Fields` in the current scope\n  --> src\\main.rs:40:48\n   |\n40 | ...                   item_struct.fields.push(new_field);\n   |                                          ^^^^ method not found in `Fields`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `test_frame` (bin \"test_frame\") due to 1 previous error\n"
            }
        ],
        "label": "Positive",
        "file": ".\\mutators\\union_field_manipulation_474.rs"
    }
]